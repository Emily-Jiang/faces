:sectnums:
= Jakarta Server Faces Specification, Version 2.3

Copyright (c) 2007, 2019 Oracle and/or its affiliates. All rights reserved.

Oracle and Java are registered trademarks of Oracle and/or its 
affiliates. Other names may be trademarks of their respective owners. 

=== 

image:SF-3.png[image]

Preface

image:SF-4.png[image]

This is the JavaServer Faces 2.3 (JSF 2.3)
specification, developed by the JSR-372 expert group under the Java
Community Process (see <http://www.jcp.org> for more information about
the JCP).

=== 

image:SF-5.png[image]

Changes between 2.2 and 2.3

This section gives the reader a survey of the
changes between this version of the specification and the previous
version, using the categories from the issue tracker at <
http://jsf-spec.java.net/issues/ >.

=== Big Ticket Features

WebSocket Integration

Issue ID 1396

See the VDLDocs for _<f:websocket />_ _and_
link:JSF.html#a5904[See <f:websocket>].

Multi-field Validation

Issue ID 1

See the VDLDocs for _<f:validateWholeBean />_ .

Java Time Support

Issue ID 1370

See the VDLDocs for _<f:convertDateTime />_ .

Use CDI for evaluation of JSF specific EL
implicit Objects

Issue ID
1311,1322,1325,1327,1328,1334,1332,1331,1328,1384,1385,1383,1386 - 1394

{empty}See link:JSF.html#a3070[See EL
Resolution]

Issue ID 1417

Deprecate javax.faces.bean.

Support @Inject on JSF specific artifacts

Issue ID
1316,527,1309,1323,1283,1353,1335,1333,1323,1349,1351,1350,1345

{empty}See link:JSF.html#a3054[See JSF
Objects Valid for @Inject Injection]

UIData and <ui:repeat> supports Map and
Iterable

Issue ID 1102

ui:repeat condition check.

Issue ID 1418

CDI Replacement for @ManagedProperty. See
javadocs for _javax.faces.annotation.ManagedProperty_ .

Issue ID 1103, 1364

See the Javadoc for
_javax.faces.component.UIData_ , and
_javax.faces.model.IterableDataModel_ .

 _DataModel_ implementations can be registered

Issue ID 1078

See the javadoc for annotation
_javax.faces.model.FacesDataModel_ .

Issue ID 1412

See the javadoc for annotation
_javax.faces.partialViewContext.getEvalScripts()_ .

Issue ID 613

Ajax Method Invocation. See vdldoc for
<h:commandScript>.

Issue ID 1238

Enhanced component search facility. See the
javadoc for package _javax.faces.component.search_ . __

=== Other Features, by Functional Area

Components/Renderers

=== Larger Changes

Issue ID 217

styleClass attribute added to h:column

Issue ID 329

Add “group” attribute to <h:selectOneRadio>.

Issue ID 1423,1404

ResourceHandler.markResourceRendered(), and
isResourceRendered(), UIViewRoot.getComponentResources() enable the
discovery of dynamically added resources, even within Ajax requests.

Issue ID 1404

Add API to check if a resource has already been
rendered. See Javadoc for
_javax.faces.application.ResourceHandler.markResourceRendered()_ and
_isResourceRendered()_ .

Issue ID 1436

In link:JSF.html#a457[See Render
Response], specify how Server Push is utilized.

=== Smaller Changes

Issue ID 1422

UISelectMany detects converter based on first
item.

Issue ID 1007

Explicit support for dynamic component
manipulation

Issue ID 819

Add “disabled” attribute for h:button

Issue ID 1300

 _UIViewRoot.getViewMap()_ and _publishEvent()_
.

Issue ID 1229

Document _UIData.setRowStatePreserved()_ in
VDLDoc and RenderKit Doc.

Issue ID 1135

Add _PostRenderViewEvent_ .

Issue ID 1258

Clarify text escaping for _<h:outputText>_ or
equivalent EL expressions.

Issue ID 807

Pass _FacesContext_ to system event listeners.

Issue ID 1113

Remove _onselect_ attribute from _SELECT_
components.

Issue ID 1433

Add a context-param to enable forcing
validation to happen even when there is no parameter corresponding to
the current component.

Lifecycle

=== Larger Changes

Issue ID 790

javax.faces.ViewState and ajax with cross form
submit.

=== Smaller Changes

Issue ID 473

FacesEvent.getFacesContext().

Issue ID 1241

 _faces-config_ supports
_client-window-factory_ .

Issue ID 1346

Simplify decoration of _FaceletCacheFactory_ .

Issue ID 1361

Correct oversight regarding re-entrancy of flow
scoped beans.

Issue ID 821

Implement _ExternalContext.getRealPath()_ on
startup and shutdown.

Issue ID 1401

Explicitly prohibit using _NavigationHandler_
from within _ExceptionHandler_ __ invoked during RENDER RESPONSE.

Issue ID 1306

 _@FlowScoped_ should be
_@NormalScope(passivating=true)._

Issue ID 1382

Generify return from
_ExternalContext.getInitParameterMap()_ .

Issue ID 1329

 _@NotNull_ and _<f:viewParam>_ .

Issue ID 1403

Allow entry into flow via _<f:viewAction>_ .

Issue ID 1216

Improve consistency in handling _PhaseListener_
instances registered on _UIViewRoot_ components.

Issue ID 1435

Add ResourceHandler.getViewResources() method.

Platform Integration

Issue ID 1379


_ExternalContext.getResponseCharacterEncoding()_ and Portlet 3.0.

Facelets/VDL

=== Larger Changes

Issue ID 1424

Add tag <f:importConstants>, see VDLDoc for
that tag.

=== Smaller Changes

Issue ID 1362

Revisit some cardinality rules regarding
_<tag>_ and _<component>_ elements.

Issue ID 936

Set _FACELETS_REFRESH_PERIOD_ to -1 if
_ProjectStage_ is _Production_ .

Spec Clarifications

Issue ID 1254

Loosen language regarding the contracts
attribute on <f:view>.

Issue ID 1338

Clarify pseudocode for resource libraries.

Issue ID 1279

Specify UIInput.isEmpty()

Issue ID 1242

Remove mentione of OpenAjax hub.

Issue ID 1215

Additional warning on
DelegatingMetaTagHandler.getTagHandlerDelegate.

Issue ID 1131

“name” attribute not required.

Issue ID 1270

TagDecorator spec namespace modifications.

Issue ID 1401

Advisory text for ExceptionHandler.

Issue ID 1402

Explicitly declare that flow eagerness not
supported.

Issue ID 677

Document automatic UIPanel behavior for
f:facet.

Issue ID 1095

Description for “rendered” attribute for repeat
and fragment.

Issue ID 1066

Application.getNavigationHandler() and
application element.

Issue ID 803

VisitHint.EXECUTE_LIFECYCLE clarifications.

Issue ID 1217

EnumConverter.getAsString() clarifications.

Issue ID 1356

UIInput.processValidators() clarifications.

Issue ID 1424

Public constants for source, behavior, and
partial.event. See the Javadocs for
_javax.faces.component.behavior.ClientBehaviorContext_ , and
_javax.faces.conetxt.PartialViewContext_ .

Issue ID 1428

API constants for jsf.js and javax.faces in
JavaScript.

Issue ID 1260

Support for exact mapping of FacesServlet. See
link:JSF.html#a3913[See ViewHandler Methods that Derive
Information From the Incoming Request] and
link:JSF.html#a3955[See ViewHandler Methods Relating to
Navigation].

Issue ID 1250

Fix entries in table
link:JSF.html#a2541[See JSF Artifacts Eligible for Injection].

Resources

=== Larger Changes

=== Smaller Changes

Expression Language.

Configuration and Bootstrapping

Miscellaneous

Issue ID 1225

{empty}Clarify requirements to support BCP-47
regarding localization. See link:JSF.html#a554[See Determining
the active Locale]

Issue ID 1429

Add constructor to make wrapping easier.

Issue ID 1430

Leverage Java SE 8 repeatable annotations where
appropriate.

=== Backward Compatibility with Previous Versions

JSF 2.3 is fully backward compatible with
previous releases of JSF, unless any of the following context-parameter
values are specified. See Section 11.1.3 “Application Configuration
Parameters” for details.

javax.faces.ALWAYS_PERFORM_VALIDATION_WHEN_REQUIRED_IS_TRUE

javax.faces.DISABLE_FACESSERVLET_TO_XHTML

javax.faces.VIEWROOT_PHASE_LISTENER_QUEUES_EXCEPTIONS.

JSF 2.3 is fully backward compatible with
previous releases of JSF unless a CDI managed bean is included in the
application with the annotation _@javax.faces.annotation.FacesConfig_ .
See the javadocs for that annotation for details.

=== Breakages in Backward Compatibility

=== 

image:SF-5.png[image]

Related Technologies

=== [[a173]]Other Java™ Platform Specifications

JSF is based on the following Java API
specifications:

JavaServer Pages™ Specification, version 2.2
(JSP™), including Expression Language 2.2
<http://jcp.org/aboutJava/communityprocess/mrel/jsr245/>

Expression Language 3.0
<http://jcp.org/en/jsr/detail?id=341> (optional)

Java™ Servlet Specification, version 4.0
(Servlet) <http://jcp.org/en/jsr/detail?id=369>

Java™ Platform, Enterprise Edition, version 8.0
<http://jcp.org/en/jsr/detail?id=366>

Contexts and Dependency Injection for Java 2.0
<http://jcp.org/en/jsr/detail?id=365>

Java™ Platform, Standard Edition, version 8.0
<http://jcp.org/en/jsr/detail?id=337>

JavaBeans™ Specification, version 1.0.1
<http://www.oracle.com/technetwork/java/javase/documentation/spec-136004.html>

JavaServer Pages™ Standard Tag Library, version
1.2 (JSTL) <http://jcp.org/en/jsr/detail?id=52>

Java™ API for WebSocket, version 1.1
<https://www.jcp.org/en/jsr/detail?id=356>

Java™ API for JSON-Processing, version 1.1
<https://www.jcp.org/en/jsr/detail?id=353>

Therefore, a JSF container must support all of
the above specifications. This requirement allows faces applications to
be portable across a variety of JSF implementations.

In addition, JSF is designed to work
synergistically with other web-related Java APIs, including:

Portlet Specification, 1.0 JSR-168
<http://jcp.org/en/jsr/detail?id=168>

Portlet Specification, 2.0 JSR-286
<http://jcp.org/en/jsr/detail?id=286>

Portlet Specification, 3.0 JSR-286
<http://jcp.org/en/jsr/detail?id=362>

JSF Portlet Bridge Specification, JSR-301
<http://jcp.org/en/jsr/detail?id=301>

=== Related Documents and Specifications

The following documents and specifications of
the World Wide Web Consortium will be of interest to JSF implementors,
as well as developers of applications and components based on JavaServer
Faces.

Hypertext Markup Language (HTML), version 4.01
<http://www.w3.org/TR/html4/>

Extensible HyperText Markup Language (XHTML),
version 1.0 <http://www.w3.org/TR/xhtml1>

Extensible Markup Language (XML), version 1.0
(Second Edition) <http://www.w3.org/TR/REC-xml>

The class and method Javadoc documentation for
the classes and interfaces in _javax.faces_ (and its subpackages) are
incorporated by reference as requirements of this Specification.

The JSP and Facelet tag library for the
HTML_BASIC standard RenderKit is specified in the VDLDocs and
incorporated by reference in this Specification.

=== Terminology

The key words MUST, MUST NOT, REQUIRED, SHALL,
SHALL NOT, SHOULD, SHOULD NOT, RECOMMENDED, MAY, and OPTIONAL in this
document are to be interpreted as described in

Key words for use in RFCs to Indicate
Requirement Levels (RFC 2119)
<http://www.rfc-editor.org/rfc/rfc2119.txt>

=== Providing Feedback

We welcome any and all feedback about this
specification. Please email your comments to
<users@javaserverfaces-spec-public.java.net>.

Please note that, due to the volume of feedback
that we receive, you will not normally receive a reply from an engineer.
However, each and every comment is read, evaluated, and archived by the
specification team.

=== Acknowledgements

The JavaServer Faces Specification (version
2.3) is the result of the diligent efforts of the JSR-372 Expert Group,
working under the auspices of the Java Community Process. The Expert
Group is

Frank Caputo

Cagatay Civici

Ken Fyten

Neil Griffin

Josh Juneau

Brian Leatham

Kito Mann

Michael Müller

Paul Nicolucci

Bauke Scholtz

Arjan Tijms

Leonardo Uribe

The editors would like to recognize the
following individuals who have contributed to the success of JavaServer
Faces over the years.

[width="100%",cols="50%,50%",]
|===
|Dan Allen |Thomas
Andraschko

|Thomas Asel |Jennifer
Ball

|Lincoln Baxter III
|Hans Bergsten

|Shawn Bayern |Joseph
Berkovitz

|Dennis Byrne |Pete
Carapetyan

|Ryan DeLaplante
|Keith Donald

|Jim Driscoll
|Hanspeter Duennenberger

|Ken Finnigan |Amy
Fowler

|Mike Freedman |David
Geary

|Manfred Geiler |Ted
Goddard

|Juan Gonzalez |Jeremy
Grelle

|Rick Hightower |Jacob
Hookom

|Justyna Horwat
|Alexander Jesse

|Max Katz |Roger Keays

|Gavin King |Roger
Kitain

|Eric Lazarus |Jason
Lee

|Felipe Leme |Cody
Lerum

|Alberto Lemos |Ryan
Lubke

|Barbara Louis |Martin
Marinschek

|Kumar Mettu |Craig
McClanahan

|Pete Muir |Bernd
Müller

|Michael Müller |Hans
Muller

|Brendan Murray
|Michael Nash

|Imre Osswald |Joe
Ottinger

|Ken Paulsen |Dhiru
Pandey

|Raj Premkumar |Werner
Punz

|Matt Raible |Hazem
Saleh

|Andy Schwartz |Yara
Senger

|Stan Silvert |Vernon
Singleton

|Bernhard Slominski
|Alexander Smirnov

|Thomas Spiegel |Kyle
Stiemann

|James Strachan
|Jayashri Visvanathan

|Ana von Klopp
|Matthias Wessendorf

|Adam Winer |Mike
Youngstrom

|John Zukowski |
|===



=== 

image:SF-6.png[image]

Overview

image:SF-7.png[image]

JavaServer Faces (JSF) is a _user interface_
(UI) framework for Java web applications. It is designed to
significantly ease the burden of writing and maintaining applications
that run on a Java application server and render their UIs back to a
target client. JSF provides ease-of-use in the following ways:

Makes it easy to construct a UI from a set of
reusable UI components

Simplifies migration of application data to
and from the UI

Helps manage UI state across server requests

Provides a simple model for wiring
client-generated events to server-side application code

Allows custom UI components to be easily
built and re-used

Most importantly, JSF establishes standards
which are designed to be leveraged by tools to provide a developer
experience which is accessible to a wide variety of developer types,
ranging from corporate developers to systems programmers. A “corporate
developer” is characterized as an individual who is proficient in
writing procedural code and business logic, but is not necessarily
skilled in object-oriented programming. A “systems programmer”
understands object-oriented fundamentals, including abstraction and
designing for re-use. A corporate developer typically relies on tools
for development, while a system programmer may define his or her tool as
a text editor for writing code.

Therefore, JSF is designed to be tooled, but
also exposes the framework and programming model as APIs so that it can
be used outside of tools, as is sometimes required by systems
programmers.

=== 

image:SF-8.png[image]

Solving Practical Problems of the Web

JSF’s core architecture is designed to be
independent of specific protocols and markup. However it is also aimed
directly at solving many of the common problems encountered when writing
applications for HTML clients that communicate via HTTP to a Java
application server that supports servlets and JavaServer Pages (JSP)
based applications. These applications are typically form-based, and are
comprised of one or more HTML pages with which the user interacts to
complete a task or set of tasks. JSF tackles the following challenges
associated with these applications:

Managing UI component state across requests

Supporting encapsulation of the differences
in markup across different browsers and clients

Supporting form processing (multi-page, more
than one per page, and so on)

Providing a strongly typed event model that
allows the application to write server-side handlers (independent of
HTTP) for client generated events

Validating request data and providing
appropriate error reporting

Enabling type conversion when migrating
markup values (Strings) to and from application data objects (which are
often not Strings)

Handling error and exceptions, and reporting
errors in human-readable form back to the application user

Handling page-to-page navigation in response
to UI events and model interactions.

=== 

image:SF-8.png[image]

Specification Audience

The _JavaServer Faces Specification_ , and
the technology that it defines, is addressed to several audiences that
will use this information in different ways. The following sections
describe these audiences, the roles that they play with respect to JSF,
and how they will use the information contained in this document. As is
the case with many technologies, the same person may play more than one
of these roles in a particular development scenario; however, it is
still useful to understand the individual viewpoints separately.

=== Page Authors

A _page author_ is primarily responsible for
creating the user interface of a web application. He or she must be
familiar with the markup and scripting languages (such as HTML and
JavaScript) that are understood by the target client devices, as well as
the rendering technology (such as JavaServer Pages) used to create
dynamic content. Page authors are often focused on graphical design and
human factors engineering, and are generally not familiar with
programming languages such as Java or Visual Basic (although many page
authors will have a basic understanding of client side scripting
languages such as JavaScript).

Page authors will generally assemble the
content of the pages being created from libraries of prebuilt user
interface components that are provided by component writers, tool
providers, and JSF implementors. The components themselves will be
represented as configurable objects that utilize the dynamic markup
capabilities of the underlying rendering technology. When JavaServer
Pages are in use, for example, components will be represented as JSP
custom actions, which will support configuring the attributes of those
components as custom action attributes in the JSP page. In addition, the
pages produced by a page author will be used by the JSF framework to
create component tree hierarchies, called “views”, that represent the
components on those pages.

Page authors will generally utilize
development tools, such as HTML editors, that allow them to deal
directly with the visual representation of the page being created.
However, it is still feasible for a page author that is familiar with
the underlying rendering technology to construct pages “by hand” using a
text editor.

=== Component Writers

 _Component writers_ are responsible for
creating libraries of reusable user interface objects. Such components
support the following functionality:

Convert the internal representation of the
component’s properties and attributes into the appropriate markup
language for pages being rendered (encoding).

Convert the properties of an incoming
request—parameters, headers, and cookies—into the corresponding
properties and attributes of the component (decoding)

Utilize request-time events to initiate
visual changes in one or more components, followed by redisplay of the
current page.

Support validation checks on the syntax and
semantics of the representation of this component on an incoming
request, as well as conversion into the internal form that is
appropriate for this component.

Saving and restoring component state across
requests

As will be discussed in
link:JSF.html#a4219[See Rendering Model],” the encoding and
decoding functionality may optionally be delegated to one or more
_Render Kits_ , which are responsible for customizing these operations
to the precise requirements of the client that is initiating a
particular request (for example, adapting to the differences between
JavaScript handling in different browsers, or variations in the WML
markup supported by different wireless clients).

The component writer role is sometimes
separate from other JSF roles, but is often combined. For example,
reusable components, component libraries, and render kits might be
created by:

A page author creating a custom “widget” for
use on a particular page

An application developer providing components
that correspond to specific data objects in the application’s business
domain

A specialized team within a larger
development group responsible for creating standardized components for
reuse across applications

Third party library and framework providers
creating component libraries that are portable across JSF
implementations

Tool providers whose tools can leverage the
specific capabilities of those libraries in development of JSF-based
applications

JSF implementors who provide
implementation-specific component libraries as part of their JSF product
suite

Within JSF, user interface components are
represented as Java classes that follow the design patterns outlined in
the JavaBeans Specification. Therefore, new and existing tools that
facilitate JavaBean development can be leveraged to create new JSF
components. In addition, the fundamental component APIs are simple
enough for developers with basic Java programming skills to program by
hand.

=== Application Developers

 _Application Developers_ are responsible for
providing the server-side functionality of a web application that is not
directly related to the user interface. This encompasses the following
general areas of responsibility:

Define mechanisms for persistent storage of
the information required by JSF-based web applications (such as creating
schemas in a relational database management system)

Create a Java object representation of the
persistent information, such as Entity Enterprise JavaBeans (Entity
EJBs), and call the corresponding beans as necessary to perform
persistence of the application’s data.

Encapsulate the application’s functionality,
or business logic, in Java objects that are reusable in web and non-web
applications, such as Session EJBs.

Expose the data representation and functional
logic objects for use via JSF, as would be done for any servlet- or
JSP-based application.

Only the latter responsibility is directly
related to JavaServer Faces APIs. In particular, the following steps are
required to fulfill this responsibility:

Expose the underlying data required by the
user interface layer as objects that are accessible from the web tier
(such as via request or session attributes in the Servlet API), via
_value reference expressions_ , as described in
link:JSF.html#a1823[See Standard User Interface Components].”

Provide application-level event handlers for
the events that are enqueued by JSF components during the request
processing lifecycle, as described in link:JSF.html#a454[See
Invoke Application].

Application modules interact with JSF through
standard APIs, and can therefore be created using new and existing tools
that facilitate general Java development. In addition, application
modules can be written (either by hand, or by being generated) in
conformance to an application framework created by a tool provider.

=== Tool Providers

 _Tool providers_ , as their name implies,
are responsible for creating tools that assist in the development of
JSF-based applications, rather than creating such applications directly.
JSF APIs support the creation of a rich variety of development tools,
which can create applications that are portable across multiple JSF
implementations. Examples of possible tools include:

GUI-oriented page development tools that
assist page authors in creating the user interface for a web application

IDEs that facilitate the creation of
components (either for a particular page, or for a reusable component
library)

Page generators that work from a high level
description of the desired user interface to create the corresponding
page and component objects

IDEs that support the development of general
web applications, adapted to provide specialized support (such as
configuration management) for JSF

Web application frameworks (such as MVC-based
and workflow management systems) that facilitate the use of JSF
components for user interface design, in conjunction with higher level
navigation management and other services

Application generators that convert high
level descriptions of an entire application into the set of pages, UI
components, and application modules needed to provide the required
application functionality

Tool providers will generally leverage the
JSF APIs for introspection of the features of component libraries and
render kit frameworks, as well as the application portability implied by
the use of standard APIs in the code generated for an application.

=== JSF Implementors

Finally, _JSF implementors_ will provide
runtime environments that implement all of the requirements described in
this specification. Typically, a JSF implementor will be the provider of
a Java 2 Platform, Enterprise Edition (J2EE) application server,
although it is also possible to provide a JSF implementation that is
portable across J2EE servers.

Advanced features of the JSF APIs allow JSF
implementors, as well as application developers, to customize and extend
the basic functionality of JSF in a portable way. These features provide
a rich environment for server vendors to compete on features and quality
of service aspects of their implementations, while maximizing the
portability of JSF-based applications across different JSF
implementations.

=== 

image:SF-8.png[image]

Introduction to JSF APIs

This section briefly describes major
functional subdivisions of the APIs defined by JavaServer Faces. Each
subdivision is described in its own chapter, later in this
specification.

=== package _javax.faces_

This package contains top level classes for
the JavaServer(tm) Faces API. The most important class in the package is
_FactoryFinder_ , which is the mechanism by which users can override
many of the key pieces of the implementation with their own.

Please see
link:JSF.html#a6147[See FactoryFinder].

=== package _javax.faces.application_

This package contains APIs that are used to
link an application’s business logic objects to JavaServer Faces, as
well as convenient pluggable mechanisms to manage the execution of an
application that is based on JavaServer Faces. The main class in this
package is _Application_ .

Please see link:JSF.html#a3400[See
Application].

=== package _javax.faces.component_

This package contains fundamental APIs for
user interface components.

Please see link:JSF.html#a883[See
User Interface Component Model].

=== package _javax.faces.component.html_

This package contains concrete base classes
for each valid combination of component + renderer.

=== package _javax.faces.context_

This package contains classes and interfaces
defining per-request state information. The main class in this package
is _FacesContext_ , which is the access point for all per-request
information, as well as the gateway to several other helper classes.

Please see link:JSF.html#a3091[See
FacesContext].

=== package _javax.faces.convert_

This package contains classes and interfaces
defining converters. The main class in this package is _Converter_ .

Please see link:JSF.html#a1251[See
Conversion Model].

=== package _javax.faces.el_

As of version 1.2 of this specification, all
classes and interfaces in this package have been deprecated in favor of
the Unified Expression Language (EL) from JSP 2.1.

Please see link:JSF.html#a2344[See
Expression Language and Managed Bean Facility].

=== package _javax.faces.flow_ and _javax.faces.flow.builder_

The runtime API for Faces Flows.

Please see _link:JSF.html#a3840[See
FlowHandler]._

=== package _javax.faces.lifecycle_

This package contains classes and interfaces
defining lifecycle management for the JavaServer Faces implementation.
The main class in this package is _Lifecycle_ . _Lifecycle_ is the
gateway to executing the request processing lifecycle.

Please see link:JSF.html#a369[See
Request Processing Lifecycle].

=== package _javax.faces.event_

This package contains interfaces describing
events and event listeners, and concrete event implementation classes.
All component-level events extend from _FacesEvent_ and all
component-level listeners extend from _FacesListener_ .

Please see link:JSF.html#a1300[See
Event and Listener Model].

=== package _javax.faces.render_

This package contains classes and interfaces
defining the rendering model. The main class in this package is
_RenderKit_ . _RenderKit_ maintains references to a collection of
_Renderer_ instances which provide rendering capability for a specific
client device type.

Please see link:JSF.html#a4219[See
Rendering Model].

=== package _javax.faces.validator_

Interface defining the validator model, and
concrete validator implementation classes.

{empty}Please see
link:JSF.html#a1410[See Validation Model]

=== package _javax.faces.webapp_

Classes required for integration of
JavaServer Faces into web applications, including a standard servlet,
base classes for JSP custom component tags, and concrete tag
implementations for core tags.

Please see link:JSF.html#a6060[See
Using JSF in Web Applications].





=== 

image:SF-9.png[image]

[[a369]]Request Processing Lifecycle

image:SF-10.png[image]

Web user interfaces generally follow a
pattern where the user-agent sends one or more requests to the server
with the end goal of displaying a user-interface. In the case of Web
browsers, an initial HTTP GET or POST request is made to the server,
which responds with a document which the browser interprets and
automatically makes subsequent requests on the user’s behalf. The
responses to each of these subsequent requests are usually images,
JavaScript files, CSS Style Sheets, and other artifacts that fit “into”
the original document. If the JSF lifecycle is involved in rendering the
initial response, the entire process of initial request, the response to
that request, and any subsequent requests made automatically by the
user-agent, and their responses, is called a _Faces View
Request/Response_ for discussion. The following graphic illustrates a
Faces View Request/Response.

image:SF-11.png[image]

Each Faces View Request/Response goes through
a well-defined _request processing lifecycle_ made up of _phases_ .
There are three different scenarios that must be considered, each with
its own combination of phases and activities:

Non-Faces Request generates Faces Response

Faces Request generates Faces Response

Faces Request generates Non-Faces Response

Where the terms being used are defined as
follows:

 _Faces Response_ —A response that was
created by the execution of the _Render Response_ phase of the request
processing lifecycle.

 _Non-Faces Response_ —A response that was
not created by the execution of the _render response_ phase of the
request processing lifecycle. Examples would be a servlet-generated or
JSP-rendered response that does not incorporate JSF components, a
response that sets an HTTP status code other than the usual 200 (such as
a redirect), or a response whose HTTP body consists entirely of the
bytes of an in page resource, such as a JavaScript file, a CSS file, an
image, or an applet. This last scenario is considered a special case of
a Non-Faces Response and will be referred to as a _Faces Resource
Response_ for the remainder of this specification.

 _Faces Request_ —A request that was sent
from a previously generated _Faces response_ . Examples would be a
hyperlink or form submit from a rendered user interface component, where
the request URI was crafted (by the component or renderer that created
it) to identify the view to use for processing the request. Another
example is a request for a resource that the user-agent was instructed
to fetch an artifact such as an image, a JavaScript file, a CSS
stylesheet, or an applet. This last scenario is considered a special
case of a Faces Request and will be referred to as a _Faces Resource
Request_ for the remainder of this specification.

 _Non-Faces Request_ —A request that was sent
to an application component (e.g. a servlet or JSP page), rather than
directed to a Faces view.

In addition, of course, your web application
may receive non-Faces requests that generate non-Faces responses.
Because such requests do not involve JavaServer Faces at all, their
processing is outside the scope of this specification, and will not be
considered further.

READER NOTE: The dynamic behavior
descriptions in this Chapter make forward references to the sections
that describe the individual classes and interfaces. You will probably
find it useful to follow the reference and skim the definition of each
new class or interface as you encounter them, then come back and finish
the behavior description. Later, you can study the characteristics of
each JSF API in the subsequent chapters.

=== 

image:SF-12.png[image]

[[a383]]Request Processing Lifecycle Scenarios

Each of the scenarios described above has a
lifecycle that is composed of a particular set of phases, executed in a
particular order. The scenarios are described individually in the
following subsections.

=== Non-Faces Request Generates Faces Response

An application that is processing a non-Faces
request may use JSF to render a Faces response to that request. In order
to accomplish this, the application must perform the common activities
that are described in the following sections:

Acquire Faces object references, as described
in link:JSF.html#a502[See Acquire Faces Object References],
below.

Create a new view, as described in
link:JSF.html#a516[See Create And Configure A New View], below.

Store the view into the _FacesContext_ by
calling the _setViewRoot()_ method on the _FacesContext._

=== [[a390]]Faces Request Generates Faces Response

The most common lifecycle will be the case
where a previous Faces response includes user interface controls that
will submit a subsequent request to this web application, utilizing a
request URI that is mapped to the JSF implementation’s controller, as
described in link:JSF.html#a6076[See Servlet Mapping]. Because
such a request will be initially handled by the JSF implementation, the
application need not take any special steps—its event listeners,
validators, and application actions will be invoked at appropriate times
as the standard request processing lifecycle, described in the following
diagrams, is invoked.

image:SF-13.png[image]

The “Handle Resource Request” box, and its
subsequent boxes, are explained in link:JSF.html#a746[See
Resource Handling]. The following diagram explains the “Execute and
Render Lifecycle” box.

image:SF-14.png[image]

The behavior of the individual phases of the
request processing lifecycle are described in individual subsections of
link:JSF.html#a401[See Standard Request Processing Lifecycle
Phases]. Note that, at the conclusion of several phases of the request
processing lifecycle, common event processing logic (as described in
link:JSF.html#a494[See Common Event Processing]) is performed
to broadcast any _FacesEvents_ generated by components in the component
tree to interested event listeners.

=== Faces Request Generates Non-Faces Response

Normally, a JSF-based application will
utilize the _Render Response_ phase of the request processing lifecycle
to actually create the response that is sent back to the client. In some
circumstances, however, this behavior might not be desirable. For
example:

A Faces Request needs to be redirected to a
different web application resource (via a call to
_HttpServletResponse.sendRedirect_ ).

A Faces Request causes the generation of a
response using some other technology (such as a servlet, or a JSP page
not containing JSF components).

A Faces Request causes the generation of a
response simply by serving up the bytes of a resource, such as an image,
a JavaScript file, a CSS file, or an applet

In any of these scenarios, the application
will have used the standard mechanisms of the servlet or portlet API to
create the response headers and content. It is then necessary to tell
the JSF implementation that the response has already been created, so
that the _Render Response_ phase of the request processing lifecycle
should be skipped. This is accomplished by calling the
_responseComplete()_ method on the _FacesContext_ instance for the
current request, prior to returning from event handlers or application
actions.

=== 

image:SF-12.png[image]

[[a401]]Standard Request Processing Lifecycle Phases

The standard phases of the request processing
lifecycle are described in the following subsections.

{empty}[P1-start-currentPhaseId]The default
request lifecycle processing implementation must ensure that the
_currentPhaseId_ property of the _FacesContext_ instance for this
request is set with the proper _PhaseId_ constant for the current phase
as early as possible at the beginning of each phase.[P1-end]

=== [[a404]]Restore View

[P1-start-restoreView]The JSF implementation
must perform the following tasks during the _Restore View_ phase of the
request processing lifecycle:

Call _initView()_ on the _ViewHandler_ . This
will set the character encoding properly for this request.

Examine the _FacesContext_ instance for the
current request. If it already contains a _UIViewRoot_ :

 Set the _locale_ on this _UIViewRoot_ to the
value returned by the _getRequestLocale()_ method on the
_ExternalContext_ for this request.

Take no further action during this phase, and
return. The presence of a UIViewRoot already installed in the
FacesContext before the Restore View Phase implementation indicates that
the phase should assume the view has already been restored by other
means.

Derive the _viewId_ according to the
following algorithm, or one semantically equivalent to it.

 Look in the request map for a value under
the key _javax.servlet.include.path_info_ . If found, let it be the
_viewId_ .

Call _getRequestPathInfo()_ on the current
_ExternalContext_ . If this value is non-null, let this be the _viewId_
.

Look in the request map for a value under the
key _javax.servlet.include.servlet_path_ . If found, let it be the
_viewId_ .

If none of these steps yields a non- _null_
viewId, throw a _FacesException_ with an appropriate localized message.

Determine if this request is a postback or
initial request by executing the following algorithm. Find the
render-kit-id for the current request by calling
_calculateRenderKitId()_ on the _Application_ ’s _ViewHandler_ . Get
that _RenderKit_ ’s _ResponseStateManager_ and call its _isPostback()_
method, passing the current _FacesContext_ . If the current request is
an attempt by the servlet container to display a servlet error page, do
not interpret the request as a postback, even if it is indeed a
postback.

If the request is a postback, call
_setProcessingEvents(false)_ on the current _FacesContext_ . Then call
_ViewHandler.restoreView()_ , passing the _FacesContext_ instance for
the current request and the view identifier, and returning a
_UIViewRoot_ for the restored view. If the return from
_ViewHandler.restoreView()_ is null, throw a _ViewExpiredException_ with
an appropriate error message.
_javax.faces.application.ViewExpiredException_ is a _FacesException_
that must be thrown to signal to the application that the expected view
was not returned for the view identifier. An application may choose to
perform some action based on this exception.

Store the restored _UIViewRoot_ in the
_FacesContext_ .

Call _setProcessingEvents(true)_ on the
current _FacesContext_ . __

If the request is not a postback, try to
obtain the _ViewDeclarationLanguage_ from the _ViewHandler_ , for the
current _viewId_ by calling _ViewHandler.deriveLogicalViewId()_ and
passing the result to _ViewHandler.getViewDeclarationLanguage()_ . If no
such instance can be obtained, call _facesContext.renderResponse()_ .
Otherwise, call _getViewMetadata()_ on the _ViewDeclarationLanguage_
instance. If the result is non- _null_ , call _createMetadataView()_ on
the _ViewMetadata_ instance. Call _ViewMetadata.hasMetadata()_ , passing
the newly created _viewRoot_ . If this method returns false, call
_facesContext.renderResponse()_ . If it turns out that the previous call
to _createViewMetadata()_ did not create a _UIViewRoot_ instance, call
_createView()_ on the _ViewHandler_ .

=== View Protection

Call
ViewHandler.getProtectedViewsUnmodifiable() to determine if the view for
this viewId is protected. If not, assume the requested view is not
protected and take no additional view protection steps. Obtain the value
of the value of the request parameter whose name is given by the value
of ResponseStateManager.NON_POSTBACK_VIEW_TOKEN_PARAM. If there is no
value, throw ProtectedViewException. If the value is present, compare it
to the return from
ResponseStateManager.getCryptographicallyStrongTokenFromSession(). If
the values do not match, throw ProtectedViewException. If the values do
match, look for a Referer [sic] request header. If the header is
present, use the protected view API to determine if any of the declared
protected views match the value of the Referer header. If so, conclude
that the previously visited page is also a protected view and it is
therefore safe to continue. Otherwise, try to determine if the value of
the Referer header corresponds to any of the views in the current web
application. If not, throw a ProtectedViewException. If the Origin
header is present, additionally perform the same steps as with the
Referer header.

Call _renderResponse()_ on the _FacesContext_
.

Obtain a reference to the _FlowHandler_ from
the _Application_ . Call its _clientWindowTransition()_ method. This
ensures that navigation that happened as a result of the renderer for
the _javax.faces.OutcomeTarget_ component-family is correctly handled
with respect to flows. For example, this enables _<h:button>_ to work
correctly with flows.

Using _Application.publishEvent()_ , publish
a _PostAddToViewEvent_ with the created _UIViewRoot_ as the event
source.

{empty}In all cases, the implementation must
ensure that the restored tree is traversed and the
_PostRestoreStateEvent_ is published for every node in the tree.[P1-end]

At the end of this phase, the _viewRoot_
property of the _FacesContext_ instance for the current request will
reflect the saved configuration of the view generated by the previous
Faces Response, or a new view returned by _ViewHandler.createView()_ for
the view identifier.

=== [[a427]]Apply Request Values

The purpose of the _Apply Request Values_
phase of the request processing lifecycle is to give each component the
opportunity to update its current state from the information included in
the current request (parameters, headers, cookies, and so on). When the
information from the current request has been examined to update the
component’s current state, the component is said to have a “local
value”.

[P1-start-applyRequestDecode]During the
_Apply Request Values_ phase, the JSF implementation must call the
_processDecodes()_ method of the _UIViewRoot_ of the component
tree.[P1-end] This will normally cause the _processDecodes()_ method of
each component in the tree to be called recursively, as described in the
Javadocs for the _UIComponent.processDecodes()_ method.
[P1-start-partialDecode] The _processDecodes()_ method must determine if
the current request is a “partial request” by calling
_FacesContext.getCurrentInstance().getPartialViewContext().isPartialRequest()_
. If
_FacesContext.getCurrentInstance().getPartialViewContext().isPartialRequest()_
returns _true_ , perform the sequence of steps as outlined in
link:JSF.html#a436[See
Apply Request Values Partial Processing].[P1-end] Details of the
decoding process follow.

During the decoding of request values, some
components perform special processing, including:

Components that implement _ActionSource_
(such as _UICommand_ ), which recognize that they were activated, will
queue an _ActionEvent_ . The event will be delivered at the end of
_Apply Request Values_ phase if the _immediate_ property of the
component is _true_ , or at the end of _Invoke Application_ phase if it
is _false_ .

Components that implement
_EditableValueHolder_ (such as _UIInput_ ), and whose _immediate_
property is set to _true_ , will cause the conversion and validation
processing (including the potential to fire _ValueChangeEvent_ events)
that normally happens during _Process Validations_ phase to occur during
_Apply Request Values_ phase instead.

As described in
link:JSF.html#a494[See Common Event Processing], the
_processDecodes()_ method on the _UIViewRoot_ component at the root of
the component tree will have caused any queued events to be broadcast to
interested listeners.

{empty}At the end of this phase, all
_EditableValueHolder_ components in the component tree will have been
updated with new submitted values included in this request (or enough
data to reproduce incorrect input will have been stored, if there were
conversion errors). [P1-start-applyRequestConversion]In addition,
conversion and validation will have been performed on
_EditableValueHolder_ components whose _immediate_ property is set to
_true_ , as described in the _UIInput_ Javadocs. Conversions and
validations that failed will have caused messages to be enqueued via
calls to the _addMessage()_ method of the _FacesContext_ instance for
the current request, and the _valid_ property on the corresponding
component(s) will be set to _false_ . [P1-end]

{empty}If any of the _decode()_ methods that
were invoked, or an event listener that processed a queued event, called
_responseComplete()_ on the _FacesContext_ instance for the current
request, clear the remaining events from the event queue and terminate
lifecycle processing of the current request.
[P1-start-applyRequestComplete]If any of the _decode()_ methods that
were invoked, or an event listener that processed a queued event, called
_renderResponse()_ on the _FacesContext_ instance for the current
request, clear the remaining events from the event queue and transfer
control to the _Render Response_ phase of the request processing
lifecycle. Otherwise, control must proceed to the _Process Validations_
phase.[P1-end]

=== [[a436]]Apply Request Values Partial Processing

{empty}[P1-start-apply-partial-processing]Call
FacesContext.getPartialViewContext(). Call
PartialViewContext.processPartial() passing the FacesContext,
PhaseID.APPLY_REQUEST_VALUES as arguments. [P1-end]

=== [[a438]]Process Validations

As part of the creation of the view for this
request, zero or more _Validator_ instances may have been registered for
each component. In addition, component classes themselves may implement
validation logic in their _validate()_ methods.

[P1-start-validation]During the _Process
Validations_ phase of the request processing lifecycle, the JSF
implementation must call the _processValidators()_ method of the
_UIViewRoot_ of the tree.[P1-end] This will normally cause the
_processValidators()_ method of each component in the tree to be called
recursively, as described in the API reference for the
_UIComponent.processValidators()_ method. [P1-start-partialValidate] The
_processValidators()_ method must determine if the current request is a
“partial request” by calling
_FacesContext.getCurrentInstance().getPartialViewContext().isPartialRequest()_
. If
_FacesContext.getCurrentInstance().getPartialViewContext().isPartialRequest()_
returns _true_ , perform the sequence of steps as outlined in
link:JSF.html#a444[See
Partial Validations Partial Processing].[P1-end] Note that
_EditableValueHolder_ components whose _immediate_ property is set to
_true_ will have had their conversion and validation processing
performed during _Apply Request Values_ phase.

During the processing of validations, events
may have been queued by the components and/or _Validator_ s whose
_validate()_ method was invoked. As described in
link:JSF.html#a494[See Common Event Processing], the
_processValidators()_ method on the _UIViewRoot_ component at the root
of the component tree will have caused any queued events to be broadcast
to interested listeners.

At the end of this phase, all conversions and
configured validations will have been completed. Conversions and
Validations that failed will have caused messages to be enqueued via
calls to the _addMessage()_ method of the _FacesContext_ instance for
the current request, and the _valid_ property on the corresponding
components will have been set to _false_ .

{empty}If any of the _validate()_ methods
that were invoked, or an event listener that processed a queued event,
called _responseComplete()_ on the _FacesContext_ instance for the
current request, clear the remaining events from the event queue and
terminate lifecycle processing of the current request.
[P1-start-validationValidate]If any of the _validate()_ methods that
were invoked, or an event listener that processed a queued event, called
_renderResponse()_ on the _FacesContext_ instance for the current
request, clear the remaining events from the event queue and transfer
control to the _Render Response_ phase of the request processing
lifecycle. Otherwise, control must proceed to the _Update Model Values_
phase.[P1-end]

=== [[a444]]Partial Validations Partial Processing

{empty}[P1-start-val-partial-processing]Call
FacesContext.getPartialViewContext(). Call
PartialViewContext.processPartial() passing the FacesContext,
PhaseID.PROCESS_VALIDATIONS as arguments. [P1-end]

=== [[a446]]Update Model Values

If this phase of the request processing
lifecycle is reached, it is assumed that the incoming request is
syntactically and semantically valid (according to the validations that
were performed), that the local value of every component in the
component tree has been updated, and that it is now appropriate to
update the application's model data in preparation for performing any
application events that have been enqueued.

[P1-start-updateModel]During the _Update
Model Values_ phase, the JSF implementation must call the
_processUpdates()_ method of the _UIViewRoot_ component of the
tree.[P1-end] This will normally cause the _processUpdates()_ method of
each component in the tree to be called recursively, as described in the
API reference for the _UIComponent.processUpdates()_ method.
[P1-start-partialUpdate] The _processUpdates()_ method must determine if
the current request is a “partial request” by calling
_FacesContext.getCurrentInstance().getPartialViewContext().isPartialRequest()_
. If
_FacesContext.getCurrentInstance().getPartialViewContext().isPartialRequest()_
returns _true_ , perform the sequence of steps as outlined in
link:JSF.html#a452[See
Update Model Values Partial Processing]. [P1-end]The actual model update
for a particular component is done in the _updateModel()_ method for
that component.

During the processing of model updates,
events may have been queued by the components whose _updateModel()_
method was invoked. As described in link:JSF.html#a494[See
Common Event Processing], the _processUpdates()_ method on the
UIViewRoot component at the root of the component tree will have caused
any queued events to be broadcast to interested listeners.

At the end of this phase, all appropriate
model data objects will have had their values updated to match the local
value of the corresponding component, and the component local values
will have been cleared.

{empty}If any of the _updateModel()_ methods
that were invoked, or an event listener that processed a queued event,
called _responseComplete()_ on the _FacesContext_ instance for the
current request, clear the remaining events from the event queue and
terminate lifecycle processing of the current request.
[P1-start-updateModelComplete]If any of the _updateModel()_ methods that
was invoked, or an event listener that processed a queued event, called
_renderResponse()_ on the _FacesContext_ instance for the current
request, clear the remaining events from the event queue and transfer
control to the _Render Response_ phase of the request processing
lifecycle. Otherwise, control must proceed to the _Invoke Application_
phase.[P1-end]

=== [[a452]]Update Model Values Partial Processing

{empty}[P1-start-upd-partial-processing]Call
FacesContext.getPartialViewContext(). Call
PartialViewContext.processPartial() passing the FacesContext,
PhaseID.UPDATE_MODEL_VALUES as arguments. [P1-end]

=== [[a454]]Invoke Application

If this phase of the request processing
lifecycle is reached, it is assumed that all model updates have been
completed, and any remaining event broadcast to the application needs to
be performed. [P1-start-invokeApplication]The implementation must ensure
that the _processApplication()_ method of the _UIViewRoot_ instance is
called.[P1-end] The default behavior of this method will be to broadcast
any queued events that specify a phase identifier of
_PhaseId.INVOKE_APPLICATION_ . If _responseComplete()_ was called on the
_FacesContext_ instance for the current request, clear the remaining
events from the event queue and terminate lifecycle processing of the
current request. If _renderResponse()_ was called on the _FacesContext_
instance for the current request, clear the remaining events from the
event queue.

{empty}Advanced applications (or application
frameworks) may replace the default _ActionListener_ instance by calling
the _setActionListener()_ method on the _Application_ instance for this
application. [P1-start-invokeApplicationListener]However, the JSF
implementation must provide a default _ActionListener_ instance that
behaves as described in link:JSF.html#a3402[See ActionListener
Property].[P1-end]

=== [[a457]]Render Response

This phase accomplishes two things:

Causes the response to be rendered to the
client

Causes the state of the response to be saved
for processing on subsequent requests.

JSF supports a range of approaches that JSF
implementations may utilize in creating the response text that
corresponds to the contents of the response view, including:

Deriving all of the response content directly
from the results of the encoding methods (on either the components or
the corresponding renderers) that are called.

Interleaving the results of component
encoding with content that is dynamically generated by application
programming logic.

Interleaving the results of component
encoding with content that is copied from a static “template” resource.

Interleaving the results of component
encoding by embedding calls to the encoding methods into a dynamic
resource (such as representing the components as custom tags in a JSP
page).

Because of the number of possible options,
the mechanism for implementing the _Render Response_ phase cannot be
specified precisely. [P1-start-renderResponse]However, all JSF
implementations of this phase must conform to the following
requirements:

If it is possible to obtain a
_ViewDeclarationLanguage_ instance for the current _viewId_ , from the
_ViewHandler_ , its _buildView()_ method must be called. __

Publish the
_javax.faces.event.PreRenderViewEvent_ .

JSF implementations must provide a default
_ViewHandler_ implementation that is capable of handling views written
in JSP as well as views written in the Faces View Declaration Language
(VDL). In the case of JSP, the ViewHandler must perform a
_RequestDispatcher.forward()_ call to a web application resource whose
context-relative path is equal to the view identifier of the component
tree.

If all of the response content is being
derived from the encoding methods of the component or associated
_Renderer_ s, the component tree should be walked in the same
depth-first manner as was used in earlier phases to process the
component tree, but subject to the additional constraints listed here.
Generally this is handled by a call to _ViewHandler.renderView()_ . __

If the response content is being interleaved
from additional sources and the encoding methods, the components may be
selected for rendering in any desired orderlink:#a9083[1].

During the rendering process, additional
components may be added to the component tree based on information
available to the _ViewHandler_ implementationlink:#a9084[2].
However, before adding a new component, the _ViewHandler_ implementation
must first check for the existence of the corresponding component in the
component tree. If the component already exists (perhaps because a
previous phase has pre-created one or more components), the existing
component’s properties and attributes must be utilized.

Under no circumstances should a component be
selected for rendering when its parent component, or any of its
ancestors in the component tree, has its _rendersChildren_ property set
to true. In such cases, the parent or ancestor component must render the
content of this child component when the parent or ancestor was
selected.

If the _isRendered()_ method of a component
returns _false_ , the renderer for that component must not generate any
markup, and none of its facets or children (if any) should be rendered.

It must be possible for the application to
programmatically modify the component tree at any time during the
request processing lifecycle (except during the rendering of the view)
and have the system behave as expected. For example, the following must
be permitted. Modification of the view during rendering may lead to
undefined results. It must be possible to allow components added by the
templating system (such as JSP) to be removed from the tree before
rendering. It must be possible to programmatically add components to the
tree and have them render in the proper place in the hierarchy. It must
be possible to re-order components in the tree before rendering. These
manipulations do require that any components added to the tree have ids
that are unique within the scope of the closest parent _NamingContainer_
component. The value of the _rendersChildren_ property is handled as
expected, and may be either _true_ or _false_ .

If running on a container that supports
Servlet 4.0 or later, after any dynamic component manipulations have
been completed, any resources that have been added to the UIViewRoot,
such as scripts, images, or stylesheets, and any inline images, must be
pushed to the client using the Servlet Server Push API. All of the
pushes must be started before any of the HTML of the response is
rendered to the client.

For partial requests, where partial view
rendering is required, there must be no content written outside of the
view (outside _f:view_ ). Response writing must be disabled. Response
writing must be enabled again at the start of _encodeBegin._

When each particular component in the
component tree is selected for rendering, calls to its _encodeXxx()_
methods must be performed in the manner described in
link:JSF.html#a1041[See Component Specialization Methods]. For
components that implement _ValueHolder_ (such as _UIInput_ and
_UIOutput_ ), data conversion must occur as described in the _UIOutput_
Javadocs.

{empty}Upon completion of rendering, but
before state saving the JSF runtime must publish a
_javax.faces.event.PostRenderViewEvent_ . After doing so the JSF runtime
must save the completed state using the methods of the class
_StateManager._ This state information must be made accessible on a
subsequent request, so that the _Restore View_ can access it.[P1-end]
For more on _StateManager_ , see link:JSF.html#a4140[See State
Saving Methods.]

=== [[a480]]Render Response Partial Processing

[P1-start-render-partial-processing]
According to _UIViewRoot.encodeChildren()_ ,
_FacesContext.processPartial(PhaseId.RENDER_RESPONSE)_ , will be called
if and only if the current request is an Ajax request. Take these
actions in this case.

On the _ExternalContext_ for the request,
call _setResponseContentType("text/xml")_ and
_addResponseHeader("Cache-control", "no-cache")_ . Call
_startDocument()_ on the _PartialResponseWriter_ .

Call _writePreamble(“<?xml version=’1.0’
encoding=’currentEncoding’?>\n”)_ on the _PartialResponseWriter_ , where
_encoding_ is the return from the _getCharacterEncoding()_ on the
_PartialResponseWriter_ , or UTF-8 if that method returns _null_ . __

If _isResetValues()_ returns _true_ , call
_getRenderIds()_ and pass the result to _UIViewRoot.resetValues()_ . __

If _isRenderAll()_ returns _true_ and the
view root is not an instance of _NamingContainer_ , call
_startUpdate(PartialResponseWriter.RENDER_ALL_MARKER)_ on the
_PartialResponseWriter_ . For each child of the _UIViewRoot_ , call
_encodeAll()_ . Call _endUpdate()_ on the _PartialResponseWriter_ .
Render the state using the algorithm described below in
link:JSF.html#a487[See Partial State Rendering], call
_endDocument()_ on the _PartialResponseWriter_ and return. If
_isRenderAll()_ returns _true_ and this _UIViewRoot_ is a
_NamingContainer_ , treat this as a case where _isRenderAll()_ returned
_false_ , but use the _UIViewRoot_ itself as the one and only component
from which the tree visit must start.

If _isRenderAll()_ returns _false_ , if there
are ids to render, visit the subset of components in the tree to be
rendered in similar fashion as for other phases, but for each
_UIComponent_ in the traversal, call _startUpdate(id)_ on the
_PartialResponseWriter_ , where _id_ is the client id of the component.
Call _encodeAll()_ on the component, and then _endUpdate()_ on the
_PartialResponseWriter_ . If there are no ids to render, this step is
un-necessary. After the subset of components (if any) have been
rendered, Render the state using the algorithm described below in
link:JSF.html#a487[See Partial State Rendering], call
_endDocument()_ on the _PartialResponseWriter_ and return.

=== [[a487]]Partial State Rendering

This section describes the requirements for
rendering the _<update>_ elements pertaining to view state and window id
in the case of partial response rendering.

If the view root is marked transient, take no
action and return.

Obtain a unique id for the view state, as
described in the JavaDocs for the constant field
_ResponseStateManager.VIEW_STATE_PARAM_ . Pass this id to a call to
_startUpdate()_ on the _PartialResponseWriter_ . Obtain the view state
to render by calling _getViewState()_ on the application’s
_StateManager_ . Write the state by calling _write()_ on the
_PartialResponseWriter_ , passing the state as the argument. Call
_endUpdate()_ on the _PartialResponseWriter_ .

If _getClientWindow()_ on the
_ExternalContext_ , returns non- _null_ , obtain an id for the
_<update>_ element for the window id as described in the JavaDocs for
the constant _ResponseStateManager.WINDOW_ID_PARAM_ . Pass this id to a
call to _startUpdate()_ on the _PartialResponseWriter_ . Call _write()_
on that same writer, passing the result of calling _getId()_ on the
_ClientWindow_ . Call _endUpdate()_ on the _PartialResponseWriter_ .

{empty}[P1-end]

=== 

image:SF-12.png[image]

[[a494]]Common Event Processing

For a complete description of the event
processing model for JavaServer Faces components, see
link:JSF.html#a1300[See Event and Listener Model].

During several phases of the request
processing lifecycle, as described in link:JSF.html#a401[See
Standard Request Processing Lifecycle Phases], the possibility exists
for events to be queued (via a call to the _queueEvent()_ method on the
source _UIComponent_ instance, or a call to the _queue()_ method on the
_FacesEvent_ instance), which must now be broadcast to interested event
listeners. The broadcast is performed as a side effect of calling the
appropriate lifecycle management method ( _processDecodes()_ ,
_processValidators()_ , _processUpdates()_ , or _processApplication()_ )
on the _UIViewRoot_ instance at the root of the current component tree.

[P1-start-eventBroadcast]For each queued
event, the _broadcast()_ method of the source _UIComponent_ must be
called to broadcast the event to all event listeners who have registered
an interest, on this source component for events of the specified type,
after which the event is removed from the event queue.[P1-end] See the
API reference for the _UIComponent.broadcast()_ method for the detailed
functional requirements.

{empty}It is also possible for event
listeners to cause additional events to be enqueued for processing
during the current phase of the request processing lifecycle.
[P1-start-eventOrder]Such events must be broadcast in the order they
were enqueued, after all originally queued events have been broadcast,
before the lifecycle management method returns.[P1-end]

=== 

image:SF-12.png[image]

Common Application Activities

The following subsections describe common
activities that may be undertaken by an application that is using JSF to
process an incoming request and/or create an outgoing response. Their
use is described in link:JSF.html#a383[See Request Processing
Lifecycle Scenarios], for each request processing lifecycle scenario in
which the activity is relevant.

=== [[a502]]Acquire Faces Object References

This phase is only required when the request
being processed was not submitted from a previous response, and
therefore did not initiate the _Faces Request Generates Faces Response_
lifecycle. In order to generate a Faces Response, the application must
first acquire references to several objects provided by the JSF
implementation, as described below.

=== Acquire and Configure Lifecycle Reference

[P1-start-lifeReference]As described in
link:JSF.html#a6608[See Lifecycle], the JSF implementation must
provide an instance of _javax.faces.lifecycle.Lifecycle_ that may be
utilized to manage the remainder of the request processing
lifecycle.[P1-end] An application may acquire a reference to this
instance in a portable manner, as follows:

[width="100%",cols="100%",]
|===
a|
LifecycleFactory lFactory =
(LifecycleFactory)
FactoryFinder.getFactory(FactoryFinder.LIFECYCLE_FACTORY);

Lifecycle lifecycle =
lFactory.getLifecycle(LifecycleFactory.DEFAULT_LIFECYCLE);

|===

It is also legal to specify a different
lifecycle identifier as a parameter to the _getLifecycle()_ method, as
long as this identifier is recognized and supported by the JSF
implementation you are using. However, using a non-default lifecycle
identifier will generally not be portable to any other JSF
implementation.

=== Acquire and Configure FacesContext Reference

[P1-start-contextReference]As described in
link:JSF.html#a3091[See FacesContext], the JSF implementation
must provide an instance of _javax.faces.context.FacesContext_ to
contain all of the per-request state information for a Faces Request or
a Faces Response. An application that is processing a Non-Faces Request,
but wants to create a Faces Response, must acquire a reference to a
_FacesContext_ instance as follows

[width="100%",cols="100%",]
|===
a|
FacesContextFactory fcFactory =
(FacesContextFactory)
FactoryFinder.getFactory(FactoryFinder.FACES_CONTEXT_FACTORY);

FacesContext facesContext =

 fcFactory.getFacesContext(context, request,
response, lifecycle);



|===

where the _context_ , _request_ , and
_response_ objects represent the corresponding instances for the
application environment.[P1-end] For example, in a servlet-based
application, these would be the _ServletContext_ , _HttpServletRequest_
, and _HttpServletResponse_ instances for the current request.

=== [[a516]]Create And Configure A New View

When a Faces response is being intially
created, or when the application decides it wants to create and
configure a new view that will ultimately be rendered, it may follow the
steps described below in order to set up the view that will be used. You
must start with a reference to a _FacesContext_ instance for the current
request.

=== [[a518]]Create A New View

Views are represented by a data structure
rooted in an instance of _javax.faces.component.UIViewRoot_ , and
identified by a view identifier whose meaning depends on the
_ViewHandler_ implementation to be used during the _Render Response_
phase of the request processing lifecyclelink:#a9085[3]. The
_ViewHandler_ provides a factory method that may be utilized to
construct new component trees, as follows:

[width="100%",cols="100%",]
|===
a|
String viewId = ... _identifier of the
desired Tree_ ...;

ViewHandler viewHandler =
application.getViewHandler();

UIViewRoot view =
viewHandler.createView(facesContext, viewId);

|===

[P1-start-createViewRoot]The _UIViewRoot_
instance returned by the _createView()_ method must minimally contain a
single _UIViewRoot_ provided by the JSF implementation, which must
encapsulate any implementation-specific component management that is
required.[P1-end] Optionally, a JSF implementation’s _ViewHandler_ may
support the automatic population of the returned _UIViewRoot_ with
additional components, perhaps based on some external metadata
description.

[P1-start-createView]The caller of
_ViewHandler.createView()_ must cause the _FacesContext_ to be populated
with the new _UIViewRoot._ Applications must make sure that it is safe
to discard any state saved in the view rooted at the _UIViewRoot_
currently stored in the _FacesContext_ .[P1-end] If Facelets is the page
definition language, _FacesContext.setViewRoot()_ must be called before
returning from _ViewHandler.createView()._ Refer to
link:JSF.html#a3910[See Default ViewHandler Implementation] for
more _ViewHandler_ details.

=== Configure the Desired RenderKit

{empty}[P1-start-defaultRenderkit]The
_UIViewRoot_ instance provided by the _ViewHandler_ , as described in
the previous subsection, must automatically be configured to utilize the
default _javax.faces.render.RenderKit_ implementation provided by the
JSF implementation, as described in link:JSF.html#a4223[See
RenderKit]. This _RenderKit_ must support the standard components and
_Renderer_ s described later in this specification, to maximize the
portability of your application.[P1-end]

However, a different _RenderKit_ instance
provided by your JSF implementation (or as an add-on library) may be
utilized instead, if desired. A reference to this _RenderKit_ instance
can be obtained from the standard _RenderKitFactory_ , and then assigned
to the _UIViewRoot_ instance created previously, as follows:

[width="100%",cols="100%",]
|===
a|
String renderKitId = ... identifier of
desired RenderKit ...;

RenderKitFactory rkFactory =
(RenderKitFactory)
FactoryFinder.getFactory(FactoryFinder.RENDER_KIT_FACTORY);

RenderKit renderKit =
rkFactory.getRenderKit(renderKitId, facesContext);

view.setRenderKitId(renderKitId);

|===

As described in Chapter 8, changing the
_RenderKit_ being used changes the set of _Renderer_ s that will
actually perform decoding and encoding activities. Because the
components themselves store only a _rendererType_ property (a logical
identifier of a particular _Renderer_ ), it is thus very easy to switch
between _RenderKit_ s, as long as they support renderers with the same
renderer types.

[P1-start-calcRenderkitId]The default
_ViewHandler_ must call _calculateRenderKitId()_ on itself and set the
result into the _UIViewRoot_ ’s _renderKitId_ property.[P1-end] This
allows applications that use alternative _RenderKit_ s to dynamically
switch on a per-view basis.

=== Configure The View’s Components

At any time, the application can add new
components to the view, remove them, or modify the attributes and
properties of existing components. For example, a new _FooComponent_ (an
implementation of _UIComponent_ ) can be added as a child to the root
_UIViewRoot_ in the component tree as follows:

[width="100%",cols="100%",]
|===
a|
FooComponent component = ... _create a
FooComponent instance_ ...;

facesContext.getViewRoot().getChildren().add(component);

|===

=== Store the new View in the FacesContext

{empty}[P1-start-setViewRoot]Once the view
has been created and configured, the _FacesContext_ instance for this
request must be made aware of it by calling _setViewRoot()_ .[P1-end]

=== 

image:SF-12.png[image]

Concepts that impact several lifecycle phases

This section is intended to give the reader a
“big picture” perspective on several complex concepts that impact
several request processing lifecycle phases.

=== Value Handling

At a fundamental level, JavaServer Faces is a
way to get values from the user, into your model tier for processing.
The process by which values flow from the user to the model has been
documented elsewhere in this spec, but a brief holistic survey comes in
handy. The following description assumes the JSP/HTTP case, and that all
components have Renderers.

=== Apply Request Values Phase

The user presses a button that causes a form
submit to occur. This causes the state of the form to be sent as
_name=value_ pairs in the _POST_ data of the HTTP request. The JSF
request processing lifecycle is entered, and eventually we come to the
_Apply Request Values Phase_ . In this phase, the _decode()_ method for
each _Renderer_ for each _UIComponent_ in the view is called. The
_Renderer_ takes the value from the request and passes it to the
_setSubmittedValue()_ method of the component, which is, of course, an
instance of _EditableValueHolder_ . If the component has the "
_immediate_ " property set to _true_ , we execute validation immediately
after decoding. See below for what happens when we execute validation.

=== Process Validators Phase

 _processValidators()_ is called on the root
of the view. For each _EditableValueHolder_ in the view, If the “
_immediate_ ” property is not set, we execute validation for each
_UIInput_ in the view. Otherwise, validation has already occurred and
this phase is a no-op.

=== Executing Validation

Please see the javadocs for
_UIInput.validate()_ for more details, but basically, this method gets
the submitted value from the component (set during _Apply Request
Values_ ), gets the _Renderer_ for the component and calls its
_getConvertedValue()_ , passing the submitted value. If a conversion
error occurs, it is dealt with as described in the javadocs for that
method. Otherwise, all validators attached to the component are asked to
validate the converted value. If any validation errors occur, they are
dealt with as described in the javadocs for _Validator.validate()_ . The
converted value is pushed into the component's _setValue()_ method, and
a _ValueChangeEvent_ is fired if the value has changed.

=== Update Model Values Phase

For each _UIInput_ component in the view, its
_updateModel()_ method is called. This method only takes action if a
local value was set when validation executed and if the page author
configured this component to push its value to the model tier. This
phase simply causes the converted local value of the _UIInput_ component
to be pushed to the model in the way specified by the page author. Any
errors that occur as a result of the attempt to push the value to the
model tier are dealt with as described in the javadocs for
_UIInput.updateModel()_ .

=== Localization and Internationalization (L10N/I18N)

JavaServer Faces is fully internationalized.
The I18N capability in JavaServer Faces builds on the I18N concepts
offered in the Servlet, JSP and JSTL specifications. I18N happens at
several points in the request processing lifecycle, but it is easiest to
explain what goes on by breaking the task down by function.

=== [[a554]]Determining the active _Locale_

JSF has the concept of an active _Locale_
which is used to look up all localized resources. Converters must use
this _Locale_ when performing their conversion. This _Locale_ is stored
as the value of the _locale_ JavaBeans property on the _UIViewRoot_ of
the current _FacesContext_ . The application developer can tell JSF what
locales the application supports in the applications’
_WEB-INF/faces-config.xml_ file. For example:

<faces-config>

 <application>

 <locale-config>

 <default-locale>en</default-locale>

 <supported-locale>de</supported-locale>

 <supported-locale>fr</supported-locale>

 <supported-locale>es</supported-locale>

 </locale-config>

 </application>

This application’s default locale is _en_ ,
but it also supports _de, fr,_ and _es_ locales. These elements cause
the _Application_ instance to be populated with _Locale_ data. Please
see the javadocs for details.

The _UIViewRoot_ ’s _Locale_ is determined
and set by the _ViewHandler_ during the execution of the _ViewHandler_
’s _createView()_ method. [P1-start-locale]This method must cause the
active _Locale_ to be determined by looking at the user’s preferences
combined with the application’s stated supported locales.[P1-end] Please
see the javadocs for details.

{empty}The application can call
_UIViewRoot.setLocale()_ directly, but it is also possible for the page
author to override the _UIViewRoot_ ’s locale by using the _locale_
attribute on the _<f:view_ > tag. [P1-start-localeValue]The value of
this attribute must be specified as
_language[\{-|_}country[\{-|_}variant]]_ without the colons, for example
" _ja_JP_SJIS_ ". The separators between the segments must be ' _-_ ' or
' ___ '.[P1-end]

In all cases where JSP is utilized, the
active _Locale_ is set under “request scope” into the JSTL class
_javax.servlet.jsp.jstl.core.Config_ , under the key _Config.FMT_LOCALE_
.

To facilitate BCP 47 support, the Locale
parsing mentioned above is done only if the JDK Locale.languageForTag
method does not return a Locale with a language in it. The additional
format of the Locale string is as specified by that method.

=== Determining the Character Encoding

The request and response character encoding
are set and interpreted as follows.

On an initial request to a Faces webapp, the
request character encoding is left unmodified, relying on the underlying
request object (e.g., the servlet or portlet request) to parse request
parameter correctly.

[P1-start-setLocale]At the beginning of the
render-response phase, the ViewHandler must ensure that the response
Locale is set to be that of the UIViewRoot, for example by calling
_ServletResponse.setLocale()_ when running in the servlet
environment.[P1-end] Setting the response Locale may affect the response
character encoding, see the Servlet and Portlet specifications for
details.

[P1-start-encoding]At the end of the
render-response phase, the ViewHandler must store the response character
encoding used by the underlying response object (e.g., the servlet or
portlet response) in the session (if and only if a session already
exists) under a well known, implementation-dependent key.

{empty}On a subsequent postback, before any
of the ExternalContext methods for accessing request parameters are
invoked, the ViewHandler must examine the Content-Type header to read
the charset attribute and use its value to set it as the request
encoding for the underlying request object. If the Content-Type header
doesn't contain a charset attribute, the encoding previously stored in
the session (if and only if a session already exists), must be used to
set the encoding for the underlying request object. If no character
encoding is found, the request encoding must be left unmodified.[P1-end]

The above algorithm allows an application to
use the mechanisms of the underlying technologies to adjust both the
request and response encoding in an application-specific manner, for
instance using the page directive with a fixed character encoding
defined in the contentType attribute in a JSP page, see the Servlet,
Portlet and JSP specifications for details. Note, though, that the
character encoding rules prior to Servlet 2.4 and JSP 2.0 are imprecise
and special care must be taken for portability between containers.

=== Localized Text

There is no direct support for this in the
API, but the JSP layer provides a convenience tag that converts a
_ResourceBundle_ into a _java.util.Map_ and stores it in the scoped
namespace so all may get to it. This section describes how resources
displayed to the end user may be localized. This includes images,
labels, button text, tooltips, alt text, etc.

Since most JSF components allow pulling their
display value from the model tier, it is easy to do the localization at
the model tier level. As a convenience, JSF provides the
_<f:loadBundle>_ tag, which takes a _ResourceBundle_ and loads it into a
_Map_ , which is then stored in the scoped namespace in request scope,
thus making its messages available using the same mechanism for
accessing data in the model tier. For example:

<f:loadBundle
basename=”com.foo.industryMessages.chemical”

 var=”messages” />

<h:outputText value=”#\{messages.benzene}” />

This must cause the _ResourceBundle_ named
_com.foo.industryMessages.chemical_ to be loaded as a Map into the
request scope under the key _messages_ . Localized content can then be
pulled out of it using the normal value expression syntax.

=== [[a584]]Localized Application Messages

This section describes how JSF handles
localized error and informational messages that occur as a result of
conversion, validation, or other application actions during the request
processing lifecycle. The JSF class
_javax.faces.application.FacesMessage_ is provided to encapsulate
summary, detail, and severity information for a message.
[P1-start-bundle]A JSF implementation must provide a
_javax.faces.Messages ResourceBundle_ containing all of the necessary
keys for the standard messages. The required keys (and a non-normative
indication of the intended message text) are as follows:

javax.faces.component.UIInput.CONVERSION --
\{0}: Conversion error occurred

javax.faces.component.UIInput.REQUIRED --
\{0}: Validation Error: Value is required

javax.faces.component.UIInput.UPDATE -- \{0}:
An error occurred when processing your submitted information

javax.faces.component.UISelectOne.INVALID --
\{0}: Validation Error: Value is not valid

javax.faces.component.UISelectMany.INVALID --
\{0}: Validation Error: Value is not valid

javax.faces.converter.BigDecimalConverter.DECIMAL=\{2}:
''\{0}'' must be a signed decimal number.

javax.faces.converter.BigDecimalConverter.DECIMAL_detail=\{2}:
''\{0}'' must be a signed decimal number consisting of zero or more
digits, that may be followed by a decimal point and fraction. Example:
\{1}

javax.faces.converter.BigIntegerConverter.BIGINTEGER=\{2}:
''\{0}'' must be a number consisting of one or more digits.

javax.faces.converter.BigIntegerConverter.BIGINTEGER_detail=\{2}:
''\{0}'' must be a number consisting of one or more digits. Example:
\{1}

javax.faces.converter.BooleanConverter.BOOLEAN=\{1}:
''\{0}'' must be 'true' or 'false'.

javax.faces.converter.BooleanConverter.BOOLEAN_detail=\{1}:
''\{0}'' must be 'true' or 'false'. Any value other than 'true' will
evaluate to 'false'.

javax.faces.converter.ByteConverter.BYTE=\{2}:
''\{0}'' must be a number between -128 and 127.

javax.faces.converter.ByteConverter.BYTE_detail=\{2}:
''\{0}'' must be a number between -128 and 127. Example: \{1}

javax.faces.converter.CharacterConverter.CHARACTER=\{1}:
''\{0}'' must be a valid character.

javax.faces.converter.CharacterConverter.CHARACTER_detail=\{1}:
''\{0}'' must be a valid ASCII character.

javax.faces.converter.DateTimeConverter.DATE=\{2}:
''\{0}'' could not be understood as a date.

javax.faces.converter.DateTimeConverter.DATE_detail=\{2}:
''\{0}'' could not be understood as a date. Example: \{1}

javax.faces.converter.DateTimeConverter.TIME=\{2}:
''\{0}'' could not be understood as a time.

javax.faces.converter.DateTimeConverter.TIME_detail=\{2}:
''\{0}'' could not be understood as a time. Example: \{1}

javax.faces.converter.DateTimeConverter.DATETIME=\{2}:
''\{0}'' could not be understood as a date and time.

javax.faces.converter.DateTimeConverter.DATETIME_detail=\{2}:
''\{0}'' could not be understood as a date and time. Example: \{1}

javax.faces.converter.DateTimeConverter.PATTERN_TYPE=\{1}:
A 'pattern' or 'type' attribute must be specified to convert the value
''\{0}''.

javax.faces.converter.DoubleConverter.DOUBLE=\{2}:
''\{0}'' must be a number consisting of one or more digits.

javax.faces.converter.DoubleConverter.DOUBLE_detail=\{2}:
''\{0}'' must be a number between 4.9E-324 and 1.7976931348623157E308
Example: \{1}

javax.faces.converter.EnumConverter.ENUM=\{2}:
''\{0}'' must be convertible to an enum.

javax.faces.converter.EnumConverter.ENUM_detail=\{2}:
''\{0}'' must be convertible to an enum from the enum that contains the
constant ''\{1}''.

javax.faces.converter.EnumConverter.ENUM_NO_CLASS=\{1}:
''\{0}'' must be convertible to an enum from the enum, but no enum class
provided.

javax.faces.converter.EnumConverter.ENUM_NO_CLASS_detail=\{1}:
''\{0}'' must be convertible to an enum from the enum, but no enum class
provided.

javax.faces.converter.FloatConverter.FLOAT=\{2}:
''\{0}'' must be a number consisting of one or more digits.

javax.faces.converter.FloatConverter.FLOAT_detail=\{2}:
''\{0}'' must be a number between 1.4E-45 and 3.4028235E38 Example: \{1}

javax.faces.converter.IntegerConverter.INTEGER=\{2}:
''\{0}'' must be a number consisting of one or more digits.

javax.faces.converter.IntegerConverter.INTEGER_detail=\{2}:
''\{0}'' must be a number between -2147483648 and 2147483647 Example:
\{1}

javax.faces.converter.LongConverter.LONG=\{2}:
''\{0}'' must be a number consisting of one or more digits.

javax.faces.converter.LongConverter.LONG_detail=\{2}:
''\{0}'' must be a number between -9223372036854775808 to
9223372036854775807 Example: \{1}

javax.faces.converter.NumberConverter.CURRENCY=\{2}:
''\{0}'' could not be understood as a currency value.

javax.faces.converter.NumberConverter.CURRENCY_detail=\{2}:
''\{0}'' could not be understood as a currency value. Example: \{1}

javax.faces.converter.NumberConverter.PERCENT=\{2}:
''\{0}'' could not be understood as a percentage.

javax.faces.converter.NumberConverter.PERCENT_detail=\{2}:
''\{0}'' could not be understood as a percentage. Example: \{1}

javax.faces.converter.NumberConverter.NUMBER=\{2}:
''\{0}'' is not a number.

javax.faces.converter.NumberConverter.NUMBER_detail=\{2}:
''\{0}'' is not a number. Example: \{1}

javax.faces.converter.NumberConverter.PATTERN=\{2}:
''\{0}'' is not a number pattern.

javax.faces.converter.NumberConverter.PATTERN_detail=\{2}:
''\{0}'' is not a number pattern. Example: \{1}

javax.faces.converter.ShortConverter.SHORT=\{2}:
''\{0}'' must be a number consisting of one or more digits.

javax.faces.converter.ShortConverter.SHORT_detail=\{2}:
''\{0}'' must be a number between -32768 and 32767 Example: \{1}

javax.faces.converter.STRING=\{1}: Could not
convert ''\{0}'' to a string.

javax.faces.validator.BeanValidator.MESSAGE
-- \{0}

javax.faces.validator.DoubleRangeValidator.MAXIMUM
-- \{1}: Validation Error: Value is greater than allowable maximum of
‘’\{0}’’

javax.faces.validator.DoubleRangeValidator.MINIMUM
-- \{1}: Validation Error: Value is less than allowable minimum of
‘’\{0}’’

javax.faces.validator.DoubleRangeValidator.NOT_IN_RANGE
-- \{2}: Validation Error: Specified attribute is not between the
expected values of \{0} and \{1}.

javax.faces.validator.DoubleRangeValidator.TYPE
-- \{0}: Validation Error: Value is not of the correct type

javax.faces.validator.LengthValidator.MAXIMUM
-- \{1}: Validation Error: Length is greater than allowable maximum of
‘’\{0}’’

javax.faces.validator.LengthValidator.MINIMUM
-- \{1}: Validation Error: Length is less than allowable minimum of
‘’\{0}’’

javax.faces.validator.LongRangeValidator.MAXIMUM
-- \{1}: Validation Error: Value is greater than allowable maximum of
‘’\{0}’’

javax.faces.validator.LongRangeValidator.MINIMUM
-- \{1}: Validation Error Value is less than allowable minimum of
‘’\{0}’’

javax.faces.validator.LongRangeValidator.NOT_IN_RANGE=\{2}:
Validation Error: Specified attribute is not between the expected values
of \{0} and \{1}.

javax.faces.validator.LongRangeValidator.TYPE
-- \{0}: Validation Error: Value is not of the correct type

The following message keys are deprecated:

{empty}javax.faces.validator.NOT_IN_RANGE --
Specified attribute is not between the expected values of \{0} and
\{1}[P1-end]

A JSF application may provide its own
messages, or overrides to the standard messages by supplying a
_<message-bundle>_ element to in the application configuration
resources. Since the _ResourceBundle_ provided in the Java platform has
no notion of summary or detail, JSF adopts the policy that
_ResourceBundle_ key for the message looks up the message summary. The
detail is stored under the same key as the summary, with __detail_
appended. [P1-start-bundleKey]These _ResourceBundle_ keys must be used
to look up the necessary values to create a localized _FacesMessage_
instance. Note that the value of the summary and detail keys in the
_ResourceBundle_ may contain parameter substitution tokens, which must
be substituted with the appropriate values using
_java.text.MessageFormat_ .[P1-end] Replace the last parameter
substitution token shown in the messages above with the input
component’s _label_ attribute. For example, _\{1}_ for
_“DoubleRangeValidator.MAXIMUM”, \{2}_ for _“ShortConverter.SHORT”._ The
_label_ attribute is a generic attribute. Please see
_link:JSF.html#a993[See Generic Attributes]_ and
_link:JSF.html#a4314[See Standard HTML RenderKit
Implementation]_ for more information on these attributes. If the input
component’s _label_ attribute is not specified, use the component’s
client identifier.

These messages can be displayed in the page
using the _UIMessage_ and _UIMessages_ components and their
corresponding tags, _<h:message>_ and _<h:messages>._

[P1-start-facesMessage]The following
algorithm must be used to create a _FacesMessage_ instance given a
message key.

Call _getMessageBundle()_ on the
_Application_ instance for this web application, to determine if the
application has defined a resource bundle name. If so, load that
ResourceBundle and look for the message there.

If not there, look in the
_javax.faces.Messages_ resource bundle.

{empty}In either case, if a message is found,
use the above conventions to create a _FacesMessage_ instance.[P1-end]

=== State Management

JavaServer Faces introduces a powerful and
flexible system for saving and restoring the state of the view between
requests to the server. It is useful to describe state management from
several viewpoints. For the page author, state management happens
transparently. For the app assembler, state management can be configured
to save the state in the client or on the server by setting the
ServletContext InitParameter named _javax.faces.STATE_SAVING_METHOD_ to
either _client_ or _server_ . The value of this parameter directs the
state management decisions made by the implementation.

=== State Management Considerations for the Custom Component Author

Since the component developer cannot know
what the state saving method will be at runtime, they must be aware of
state management. As shown in link:JSF.html#a1834[See The
javax.faces.component package], all JSF components implement the
_StateHolder_ interface. As a consequence the standard components
provide implementations of _PartialStateHolder_ to suit their needs.
[P1-start-componentStateHolder]A custom component that extends
_UIComponent_ directly, and does not extend any of the standard
components, must implement _PartialStateHolder_ (or its older
super-interface, _StateHolder_ ), manually. The helper class
_StateHelper_ exists to simplify this process for the custom component
author. [P1-end]Please see _link:JSF.html#a1159[See
PartialStateHolder]_ or link:JSF.html#a1138[See StateHolder] for
details.

A custom component that does extend from one
of the standard components and maintains its own state, in addition to
the state maintained by the superclass must take special care to
implement _StateHolder_ or _PartialStateHolder_ correctly.
[P1-start-saveState]Notably, calls to _saveState()_ must not alter the
state in any way.[P1-end] The subclass is responsible for saving and
restoring the state of the superclass. Consider this example. My custom
component represents a “slider” ui widget. As such, it needs to keep
track of the maximum value, minimum value, and current values as part of
its state.

public class Slider extends UISelectOne \{

 protected Integer min = null;

 protected Integer max = null;

 protected Integer cur = null;



// ... details omitted

public Object saveState(FacesContext context)
\{

 Object values[] = new Object[4];

 values[0] = super.saveState(context);

 values[1] = min;

 values[2] = max;

 values[3] = cur;

}



public void restoreState(FacesContext
context, Object state) \{

 Object values[] = (Object \{}) state; //
guaranteed to succeed

 super.restoreState(context, values[0]);

 min = (Integer) values[1];

 max = (Integer) values[2];

 cur = (Integer) values[3];

}

Note that we call _super.saveState()_ and
_super.restoreState()_ as appropriate. This is absolutely vital! Failing
to do this will prevent the component from working.

=== State Management Considerations for the JSF Implementor

The intent of the state management facility
is to make life easier for the page author, app assembler, and component
author. However, the complexity has to live somewhere, and the JSF
implementor is the lucky role. Here is an overview of the key players.
Please see the javadocs for each individual class for more information.

=== Key Players in State Management

 _StateHelper_ the helper class that defines
a _Map_ -like contract that makes it easier for components to implement
_PartialStateHolder_ .

 _ViewHandler_ the entry point to the state
management system. Uses a helper class, _StateManager_ , to do the
actual work. In the JSP case, delegates to the tag handler for the
_<f:view>_ tag for some functionality.

 _StateManager_ abstraction for the hard work
of state saving. Uses a helper class, _ResponseStateManager_ , for the
rendering technology specific decisions.

 _ResponseStateManager_ abstraction for
rendering technology specific state management decisions.

 _UIComponent_ directs process of saving and
restoring individual component state.

=== [[a685]]Resource Handling

This section only applies to pages written
using Facelets for JSF 2 and later. link:JSF.html#a746[See
Resource Handling] is the starting point for the normative specification
for Resource Handling. This section gives a non-normative overview of
the feature. The following steps walk through the points in the
lifecycle where this feature is encountered. Consider a Faces web
application that contains resources that have been packaged into the
application as specified in link:JSF.html#a748[See Packaging
Resources]. Assume each page in the application includes references to
resources, specifically scripts and stylesheets. The first diagram in
this chapter is helpful in understanding this example.

Consider an initial request to the
application.

The _ViewHandler_ calls
_ViewDeclarationLanguage.buildView()_ . This ultimately causes the
_processEvent()_ method for the _javax.faces.resource.Script_ and
_javax.faces.resource.Stylesheet_ renderers (which implement
_ComponentSystemEventListener)_ to be called after each component that
declares them as their renderer is added to the view. This method is
specified to take actions that cause the resource to be rendered at the
correct part in the page based on user-specified or application
invariant rules. Here’s how it works.

Every _UIComponent_ instance in a view is
created with a call to some variant of _Application.createComponent()_ .
The specification for this method now includes some annotation
processing requirements. If the component or its renderer has an
_@ListenerFor_ or _@ListenersFor_ annotation, and the _Script_ and
_Stylesheet_ renderers must, the component or its renderer are added as
a component scoped listener for the appropriate event. In the case of
_Script_ and _Stylesheet_ renderers, they must listen for the
_PostAddToViewEvent_ .

When the _processEvent()_ method is called on
a _Script_ or _Stylesheet_ renderer, the renderer takes the specified
action to move the component to the proper point in the tree based on
what kind of resource it is, and on what hints the page author has
declared on the component in the view.

The _ViewHandler_ calls
_ViewDeclarationLanguage.renderView()_ . The view is traversed as normal
and because the components with _Script_ and _Stylesheet_ renderers have
already been reparented to the proper place in the view, the normal
renderering causes the resource to be encoded as described in
link:JSF.html#a842[See Rendering Resources].

The browser then parses the completely
rendered page and proceeds to issue subsequent requests for the
resources included in the page.

Now consider a request from the browser for
one of those resources included in the page.

The request comes back to the Faces server.
The _FacesServlet_ is specified to call
_ResourceHandler.isResourceRequest()_ as shown in the diagram in
link:JSF.html#a390[See Faces Request Generates Faces Response].
In this case, the method returns _true_ . The _FacesServlet_ is
specified to call _ResourceHandler.handleResourceRequest()_ to serve up
the bytes of the resource.

=== [[a695]]View Parameters

This section only applies to pages written
using Facelets for JSF 2 and later. The normative specification for this
feature is spread out across several places, including the View
Declaration Language Documentation for the _<f:metadata>_ element, the
javadocs for the _UIViewParameter_ , _ViewHandler_ , and
_ViewDeclarationLanguage_ classes, and the spec language requirements
for the default _NavigationHandler_ and the Request Processing
Lifecycle. This leads to a very diffuse field of specification
requirements. To aid in understanding the feature, this section provides
a non-normative overview of the feature. The following steps walk
through the points in the lifecycle where this feature is encountered.
Consider a web application that uses this feature exclusively on every
page. Therefore every page has the following features in common.

Every page has an _<f:metadata>_ tag, with at
least one _<f:viewParameter>_ element within it.

Every page has at least one _<h:link>_ or <
_h:button>_ with the appropriate parameters nested within it.

No other kind of navigation components are
used in the application.

Consider an initial request to the
application.

As specified in section
link:JSF.html#a404[See Restore View], the restore view phase of
the request processing lifecycle detects that this is an initial request
and tries to obtain the _ViewDeclarationLanguage_ instance from the
_ViewHandler_ for this _viewId_ . Because every page in the app is
written in Facelets for JSF 2.0, there is a _ViewDeclarationLanguage_
instance. Restore view phase calls
_ViewDeclarationLanguage.getViewMetadata()_ . Because every view in this
particular app does have _<f:metadata>_ on every page, this method
returns a _ViewMetadata_ instance. Restore view phase calls
_MetaData.createMetadataView()_ . This method creates a _UIViewRoot_
containing only children declared in the _<f:metadata>_ element. Restore
view phase calls _ViewMetadata.getViewParameters()_ . Because every
_<f:metadata>_ in the app has at least one _<f:viewParameter>_ element
within it, this method returns a non empty _Collection<UIViewParameter>_
. Restore view phase uses this fact to decide that the lifecycle must
not skip straight to render response, as is the normal action taken on
initial requests.

The remaining phases of the request
processing lifecycle execute: apply request values, process validations,
update model values, invoke application, and finally render response.
Because the view only contains _UIViewParameter_ children, only these
children are traversed during the lifecycle, but because this is an
initial request, with no query parameters, none of these compnents take
any action during the lifecycle.

Because the pages exclusively use _<h:link>_
and _<h:button>_ for their navigation, the renderers for these
components are called during the rendering of the page. As specified in
the renderkit docs for the renderers for those components, markup is
rendered that causes the browser to issue a GET request with query
parameters.

Consider when the user clicks on a link in
the application. The browser issues a GET request with query parameters

Restore view phase takes the same action as
in the previously explained request. Because this is a GET request, no
state is restored from the previous request.

Because this is a request with query
parameters, the _UIViewParameter_ children do take action when they are
traversed during the normal lifecycle, reading values during the apply
request values phase, doing conversion and processing validators
attached to the _<f:viewParam>_ elements, if any, and updating models
during the update model values phase. Because there are only _<h:link>_
and _<h:button>_ navigation elements in the page, no action action will
happen during the invoke application phase. The response is re-rendered
as normal. In such an application, the only navigation to a new page
happens by virtue of the browser issuing a GET request to a different
viewId.

=== [[a707]]Bookmarkability

Prior to JSF 2, every client server
interaction was an HTTP POST. While this works fine in many situations,
it does not work well when it comes to bookmarking pages in a web
application. Version 2 of the specification introduces bookmarking
capability with the use of two new Standard HTML RenderKit additions.

Provided is a new component (UIOutcomeTarget)
that provides properties that are used to produce a hyperlink at render
time. The component can appear in the form of a button or a link. This
feature introduces a concept known as “preemptive navigation”, which
means the target URL is determined at Render Response time - before the
user has activated the component. This feature allows the user to
leverage the navigation model while also providing the ability to
generate bookmarkable non-faces requests.

=== [[a710]]JSR 303 Bean Validation

{empty}Version 2 of the specification
introduces support for JSR 303 Bean Validation.
[p1-beanValidationRequired]A JSF implentation must support JSR 303 Bean
Validation if the environment in which the JSF runtime is included
requires JSR 303 Bean Validation. Currently the only such environment is
when JSF is included in a Java EE 6 runtime.[p1-end]

A detailed description of the usage of Bean
Validation with JSF is beyond the scope of this section, but this
section will provide a brief overview of the feature, touching on the
points of interest to a spec implementor. Consider a simple web
application that has one page, written in Facelets for JSF 2, that has a
several text fields inside of a form. This application is running in a
JSF runtime in an environment that does require JSR 303 Bean Validation,
and therefore this feature is available. Assume that every text field is
bound to a managed bean property that has at least one Bean Validation
constraint annotation attached to it.

During the render response phase that always
precedes a postback, due to the specification requirements in
link:JSF.html#a1419[See Validation Registration], every
_UIInput_ in this application has an instance of _Validator_ with id
_javax.faces.Bean_ attached to it.

During the process validations phase, due to
the specification for the _validate()_ method of this _Validator_ , Bean
Validation is invoked automatically, for the user specified validation
constraints, whenever such components are normally validated. The
_javax.faces.Bean_ standard validator also ensures that every
_ConstraintViolation_ that resulted in attempting to validate the model
data is wrapped in a _FacesMessage_ and added to the _FacesContext_ as
normal with every other kind of validator.

See also link:JSF.html#a1461[See Bean
Validation Integration].

=== [[a716]]Ajax

JSF and Ajax have been working well together
for a number of years. this has led to the sprouting of many JSF Ajax
frameworks. Although many of these frameworks may appear different, they
all contribute to a dynamic request response experience. The variations
in the way these frameworks provide that experience causes component
compatibility problems when using components from different libraries
together in the same web application.

JSF 2 introduces Ajax into the specification,
and it builds upon important concepts from a variety of existing JSF
Ajax frameworks. The specification introduces a JavaScript library for
performing basic Ajax operations. The library helps define a standard
way of sending an Ajax request, and processing an Ajax response, since
these are problem areas for component compatability. The specification
provides two ways of adding Ajax to JSF web applications. Page authors
may use the JavaScript library directly in their pages by attaching the
Ajax request call to a JSF component via a JavaScript event (such as
onclick). They may also take a more declarative aproach and use a core
Facelets tag (<f:ajax/>) that they can nest within JSF components to
“Ajaxify” them. It is also possible to “Ajaxify” regions of a page by
“wrapping” the tag around component groups.

The server side aspects of JSF Ajax
frameworks work with the standard JSF lifecycle. In addition to
providing a standard page authoring experience, the specification also
standardizes the server side processing of Ajax requests. Selected
components in a JSF view can be priocessed (known as partial processing)
and selected components can be rendered to the client (known as partial
rendering).

=== [[a720]]Component Behaviors

The JSF 2 specification introduces a new type
of attached object known as component behaviors. Component behaviors
play a similar role to converters and validators in that they are
attached to a component instance in order to enhance the component with
additional functionality not defined by the component itself. While
converters and validators are currently limited to the server-side
request processing lifecycle, component behaviors have impact that
extends to the client, within the scope of a particular instance
component in a view. In particular, the _ClientBehavior_ interface
defines a contract for behaviors that can enhance a component's rendered
content with behavior-defined "scripts". These scripts are executed on
the client in response to end user interaction, but can also trigger
postbacks back into the JSF request processing lifecycle.

The usage pattern for client behaviors is as
follows:

The page author attaches a client behavior to
a component, typically by specifying a behavior tag as a child of a
component tag.

When attaching a client behavior to a
component, the page author identifies the name of a client "event" to
attach to. The set of valid events are defined by the component.

At render time, the component (or renderer)
retrieves the client behavior and asks it for its script.

The component (or renderer) renders this
script at the appropriate location in its generated content (eg.
typically in a DOM event handler).

When the end user interacts with the
component's content in the browser, the behavior-defined script is
executed in response to the page author-specified event.

The script provides some client-side
interaction, for example, hiding or showing content or validating input
on the client, and possibly posts back to the server.

The first client behavior provided by the JSF
specification is the _AjaxBehavior_ . This behavior is exposed to a page
author as a Facelets _<f:ajax>_ tag, which can be embedded within any of
the standard HTML components as follows:

[width="100%",cols="100%",]
|===
a|
 <h:commandButton>

 <f:ajax event="mouseover"/>

 </h:commandButton>

|===

When activated in response to end user
activity, the _<f:ajax>_ client behavior generates an Ajax request back
into the JSF request processing lifecycle.

The component behavior framework is
extensible and allows developers to define custom behaviors and also
allows component authors to enhance custom components to work with
behaviors.

=== System Events

System Events are normatively specified in
link:JSF.html#a1359[See System Events]. This section provides an
overview of this feature as it relates to the lifecycle.

System events expand on the idea of lifecycle
_PhaseEvent_ s. With _PhaseEvent_ s, it is possible to have application
scoped _PhaseListeners_ that are given the opportunity to act on the
system before and after each phase in the lifecycle. System events
provide a much more fine grained insight into the system, allowing
application or component scoped listeners to be notified of a variety of
kinds of events. The set of events supported in the core specification
is given in link:JSF.html#a1361[See Event
Classes]. To accomodate extensibility, users may define their own kinds
of events.

The system event feature is a simple
publish/subscribe event model. There is no event queue, events are
published immediately, and always with a call to
_Application.publishEvent()_ . There are several ways to declare
interest in a particular kind of event.

Call _Application.subscribeToEvent()_ to add
an application scoped listener.

Call _UIComponent.subscribeToEvent()_ to add
a component scoped listener.

Use the _<f:event>_ tag to declare a
component scoped listener.

Use the _@ListenerFor_ or _@ListenersFor_
annotation. The scope of the listener is determined by the code that
processes the annotation.

Use the _<system-event-listener>_ element in
an application configuration resource to add an application scoped
listener.

This feature is conceptually related to the
lifecycle because there are calls to _Application.publishEvent()_
sprinkled throughout the code that gets executed when the lifecycle
runs.

=== 

image:SF-12.png[image]

[[a746]]Resource Handling

=== As shown in the diagram in link:JSF.html#a390[See Faces Request Generates Faces Response], [P1-start isResourceRequest rules] the JSF run-time must determine if the current Faces Request is a _Faces Resource Reques_ t or a _View Request_ . This must be accomplished by calling _Application.getResourceHandler().isResourceRequest()_ . [P1-end] Most of the normative specification for resource handling is contained in the Javadocs for _ResourceHandler_ and its related classes. This section contains the specification for resource handling that fits best in prose, rather than in Javadocs.

=== [[a748]]Packaging Resources

ResourceHandler defines a path based
packaging convention for resources. The default implementation of
ResourceHandler must support packaging resources in the web application
root or in the classpath, according to the following specification.Other
implementations of ResourceHandler are free to package resources however
they like.

=== [[a750]]Packaging Resources into the Web Application Root

[P1-start web app packaging ] The default
implementation must support packaging resources in the web application
root under the path

 _resources/<resourceIdentifier_ >

relative to the web app root. Resources
packaged into the web app root must be accessed using the
_getResource*()_ methods on _ExternalContext._ [P1-end] __

=== [[a754]]Packaging Resources into the Classpath

[P1-start classpath packaging ]For the
default implementation, resources packaged in the classpath must reside
under the JAR entry name:

 _META-INF/resources/<resourceIdentifier>_

{empty}Resources packaged into the classpath
must be accessed using the _getResource*()_ methods of the _ClassLoader_
obtained by calling the _getContextClassLoader()_ method of the curreth
_Thread_ .[P1-end]

=== [[a758]]Resource Identifiers

 _<resourceIdentifier>_ consists of several
segments, specified as follows.

{empty}[P1-start requirements for something
to be considered a valid resourceIdentifier]


_[localePrefix/][libraryName/][libraryVersion/]resourceName[/resourceVersion]_

The run-time must enforce the following rules
to consider a _<resourceIdentifier>_ valid. A _<resourceIdentifier>_
that does not follow these rules must not be considered valid and must
be ignored silently.

The set of characters that are valid for use
in the _localePrefix_ , _libraryName_ , _libraryVerison_ ,
_resourceName_ and _resourceVersion_ segments of the resource identifier
is specififed as XML NameChar excluding the path separator and ‘:’
characters. The specification for XML NameChar may be seen at
_http://www.w3.org/TR/REC-xml/#NT-NameChar_ .

A further restriction applies to
_libraryName_ . A _libraryName_ must not be an underscore separated
sequence of non-negative integers or a locale string. More rigorously, a
_libraryName_ must not match either of the following regular
expressions:

 _[0-9]+(_[0-9]+)*_

 _[A-Za-z]\{2}(_[A-Za-z]\{2}(_[A-Za-z]+)*)?_

Segments in square brackets [] are optional.

The segments must appear in the order shown
above.

If _libraryVersion_ is present, it must be
preceded by _libraryName._

If _libraryVersion_ is present, any leaf
files under _libraryName_ must be ignored. __

If _resourceVersion_ is present, it must be
preceded by _resourceName._

There must be a ’ _/_ ’ between adjacent
segments in a _<resourceIdentifier>_

If _libraryVersion_ or _resourceVersion_ are
present, both must be a ’ ___ ’ separated list of integers, neither
starting nor ending with ’ ___ ’

If _resourceVersion_ is present, it must be a
version number in the same format as _libraryVersion_ . An optional
“file extension” may be used with the _resourceVersion._ If “file
extension” is used, a “.” character, followed by a “file extension” must
be appended to the version number. See the following table for an
example.

{empty}[P1-end]

The following examples illustrate the nine
valid combinations of the above resource identifier segments.

[width="99%",cols="16%,14%,14%,14%,14%,14%,14%",]
|===
a|
localePrefx

{empty}[optional]

a|
libraryName

{empty}[optional]

a|
library

{empty}Version [optional]

a|
resourceName

{empty}[required]

a|
resource

{empty}Version [optional]

|Description
|actual resourceIdentifier

| __  | __  
| __  |
_duke.gif_ | __ 
|A non-localized, non-versioned image
resource called " _duke.gif_ ", not in a library
| _duke.gif_

| __  |
_corporate_ | __ 
| _duke.gif_ | __
 |A non-localized, non-versioned image
resource called " _duke.gif_ " in a library called " _corporate_ "
| _corporate/duke.gif_

| __  |
_corporate_ | _2_3_
| _duke.gif_ | __
 |A non-localized, non-versioned image
resource called " _duke.gif_ ", in version _2_3_ of the " _corporate_ "
library | _corporate/2_3/duke.gif_

| __  | _basic_
| _2_3_ |
_script.js_ | _1_3_4.js_ a|
A non-localized, version _1.3.4_ script
resource called " _script.js_ ", in versioned _2_3_

library called " _basic_ ".

| _basic/2_3/script.js/1_3_4.js_

| _de_ | __ 
| __  |
_header.css_ | __ 
|A non-versioned style resource called "
_header.css"_ localized for locale " _de_ " |
_de/header.css_

| _de_AT_ | __ 
| __  |
_footer.css_ | _1_4_2.css_
|Version _1_4_2_ of style resource "
_footer.css_ ", localized for locale " _de_AT_ "
| _de_AT/footer.css/1_4_2.css_

| _zh_ |
_extraFancy_ | __ 
| _menu-bar.css_ |
_2_4.css_ |Version _2_4_ of style resource
called, " _menu-bar.css_ " in non-versioned library, " _extraFancy_ ",
localized for locale " _zh_ " |
_zh/extraFancy/menu-bar.css/2_4.css_

| _ja_ | _mild_
| _0_1_ |
_ajaxTransaction.js_ | __ 
|Non-versioned script resource called, "
_ajaxTransaction.js_ ", in version _0_1_ of library called " _mild_ ",
localized for locale " _ja_ " |
_ja/mild/0_1/ajaxTransaction.js_

| _de_ch_ |
_grassy_ | _1_0_ |
_bg.png_ | _1_0.png_
|Version _1_0_ of image resource called "
_bg.png_ ", in version _1_0_ of library called " _grassy_ " localized
for locale " _de_ch_ " |
_de_ch/grassy/1_0/bg.png/1_0.png_
|===



=== [[a836]]Libraries of Localized and Versioned Resources

An important feature of the resource handler
is the ability for resources to be localized, versioned, and collected
into libraries. The localization and versioning scheme is completely
hidden behind the API of _ResourceHandler_ and _Resource_ and is not
exposed in any way to the JSF run-time.

[P1-start resource versioning] The default
implementation of _ResourceHandler.createResource()_ , for all variants
of that method, must implement the following to discover which actual
resource will be encapsulated within the returned _Resource_ instance.
An implementation may perform caching of the resource metadata to
improve performance if the _ProjectStage_ is _ProjectStage.Production_ .

Using the _resourceName_ and _libraryName_
arguments to _createResource()_ , and the resource packaging scheme
specified in link:JSF.html#a750[See Packaging Resources into
the Web Application Root], link:JSF.html#a754[See Packaging
Resources into the Classpath], and link:JSF.html#a758[See
Resource Identifiers], discover the file or entry that contains the
bytes of the resource. If there are multiple versions of the same
library, and _libraryVersion_ is not specified, the library with the
highest version is chosen. If there are multiple versions of the same
resource, and _resourceVersion_ is not specified, the resource with the
highest version is chosen. The algorithm is specified in pseudocode.

function createResource(resourceName,
libraryName) \{ +
var resource = null; +
var resourceId = null; +
for (var contract : getLibraryContracts()) \{ +
resourceId = deriveResourceIdConsideringResourceLoaders(contract,
resourceName, libraryName) +
if (null != resourceId) \{ +
resource = create the resource using the resourceId; +
return resource; +
} +
} +
 +
// try without a contract +
resourceId = deriveResourceIdConsideringResourceLoaders(null,
resourceName, libraryName) +
if (null != resourceId) \{ +
resource = create the resource using the resourceId; +
} +
return resource; +
} +
 +
function deriveResourceIdConsideringResourceLoaders(contract,
resourceName, libraryName) \{ +
var prefix = web app root resource prefix; +
var resourceLoader = web app resource loader; +
// these are shorthand for the prefix and resource loading +
// facility specified in Section 2.6.1.1. They are +
// not actual API per se. +
var resourceId = deriveResourceIdConsideringLocalePrefix(contract,
prefix, resourceLoader, resourceName, libraryName); +
 +
if (null == resourceId) \{ +
prefix = classpath resource prefix; +
resourceLoader = classpath resource loader; +
// these are shorthand for the prefix and resource +
// loading facility specified in Section 2.6.1.2. They are +
// not actual API per se. +
resourceId = deriveResourceIdConsideringLocalePrefix(contract, prefix,
resourceLoader, resourceName, libraryName); +
} +
return resourceId; +
} +
 +
function deriveResourceIdConsideringLocalePrefix(contract, prefix,
resourceLoader, resourceName, libraryName) \{ +
var localePrefix = getLocalePrefix(); +
var result = deriveResourceId(contract, prefix, resourceLoader,
resourceName, libraryName, localePrefix); +
// If the application has been configured to have a localePrefix, and
the resource +
// is not found, try to find it again, without the localePrefix. +
if (null == result && null != localePrefix) \{ +
result = deriveResourceId(contract, prefix, resourceLoader,
resourceName, libraryName, null); +
} +
return result; +
} +
 +
function deriveResourceId(contract, prefix, resourceLoader, +
resourceName, libraryName, localePrefix) \{ +
var resourceVersion = null; +
var libraryVersion = null; +
var resourceId; +
if (null != localePrefix) \{ +
prefix = localePrefix + '/' + prefix; +
} +
if (null != contract) \{ +
prefix = contract + '/' + prefix; +
} +
 +
if (null != libraryName) \{ +
// actual argument is
resourcesInContractInJar/resources/resourcesInContractInJar +
var libraryPaths = resourceLoader.getResourcePaths( +
prefix + '/' + libraryName); +
 +
if (null != libraryPaths && !libraryPaths.isEmpty()) \{ +
libraryVersion = // execute the comment +
// Look in the libraryPaths for versioned libraries. +
// If one or more versioned libraries are found, take +
// the one with the highest version number as the value +
// of libraryVersion. If no versioned libraries +
// are found, let libraryVersion remain null. +
} +
if (null != libraryVersion) \{ +
libraryName = libraryName + '/' + libraryVersion; +
} +
var resourcePaths = resourceLoader.getResourcePaths( +
prefix + '/' + libraryName + '/' + resourceName); +
if (null != resourcePaths && !resourcePaths.isEmpty()) \{ +
resourceVersion = // execute the comment +
// Look in the resourcePaths for versioned resources. +
// If one or more versioned resources are found, take +
// the one with the â€œhighestâ€? version number as the value +
// of resourceVersion. If no versioned libraries +
// are found, let resourceVersion remain null. +
} +
if (null != resourceVersion) \{ +
resourceId = prefix + '/' + libraryName + '/' + +
resourceName + '/' + resourceVersion; +
} +
else \{ +
resourceId = prefix + '/' + libraryName + '/' + resourceName; +
} +
} // end of if (null != libraryName) +
else \{ +
// libraryName == null +
var resourcePaths = resourceLoader.getResourcePaths( +
prefix + '/' + resourceName); +
if (null != resourcePaths && !resourcePaths.isEmpty()) \{ +
resourceVersion = // execute the comment +
// Look in the resourcePaths for versioned resources. +
// If one or more versioned resources are found, take +
// the one with the â€œhighestâ€? version number as the value +
// of resourceVersion. If no versioned libraries +
// are found, let resourceVersion remain null. +
} +
if (null != resourceVersion) \{ +
resourceId = prefix + '/' + resourceName + '/' + +
resourceVersion; +
} else \{ +
resourceId = prefix + '/' + resourceName; +
} +
} // end of else, when libraryName == null +
return resourceId; +
} +
 +
function getLocalePrefix() \{ +
var localePrefix; +
var appBundleName = facesContext.application.messageBundle; +
if (null != appBundleName) \{ +
var locale = +
// If there is a viewRoot on the current facesContext, use its locale. +
// Otherwise, use the locale of the application's ViewHandler +
ResourceBundle appBundle = ResourceBundle.getBundle( +
appBundleName, locale); +
localePrefix = appBundle.getString(ResourceHandler. LOCALE_PREFIX); +
} +
// Any MissingResourceException instances that are encountered +
// in the above code must be swallowed by this method, and null +
// returned; +
return localePrefix; +
}

{empty}[P1-end]

=== [[a842]]Rendering Resources

Resources such as images, stylesheets and
scripts use the resource handling mechanism as outlined in
link:JSF.html#a748[See Packaging Resources]. So, for example:

[width="100%",cols="100%",]
|===
a|
<h:graphicImage name=”Planets.gif”
library=”images”/>

<h:graphicImage
value=”#\{resource[‘images:Planets.gif’]}”/>

|===

These entries render exactly the same markup.
In addition to using the name and library attributes, stylesheet and
script resources can be “relocated” to other parts of the view. For
example, we could specify that a script resource be rendered within an
HTML “head”, “body” or “form” element in the page.

=== [[a847]]Relocatable Resources

Relocatable resources are resources that can
be told where to render themselves, and this rendered location may be
different than the resource tag placement in the view. For example, a
portion of the view may be described in the view declaration language as
follows:

<f:view contentType="text/html">

<h:head>

<meta http-equiv="Content-Type"
content="text/html;

charset=iso-8859-1" />

<title>Example View</title>

</h:head>

<h:body>

<h:form>

<h:outputScript name=”ajax.js”
library=”javax.faces”

target=”head”/>

</h:form>

</h:body>

</f:view>

The <h:outputScript> tag refers to the
renderer, ScriptRenderer, that listens for PostAddToViewEvent event
types:

[width="100%",cols="100%",]
|===
a|
@ListenerFor(facesEventClass=PostAddToViewEvent.class,

sourceClass=UIOutput.class)

public class ScriptRenderer extends Renderer
implements ComponentSystemEventListener \{...

|===

Refer to link:JSF.html#a1300[See
Event and Listener Model]. When the component for this resource is added
to the view, the ScriptRenderer processEvent method adds the component
to a facet (named by the target attribute) under the view root. using
the UIViewRoot component resource methods as described in
link:JSF.html#a2257[See Methods].

The <h:head> and <h:body> tags refer to the
renderers HeadRenderer and BodyRenderer respectively. They are described
in the Standard HTML Renderkit documentation referred to in
link:JSF.html#a4314[See Standard HTML RenderKit Implementation].
During the rendering phase, the encode methods for these renderers
render the HTML “head” and “body” elements respectively. Then they
render all component resources under the facet child (named by target)
under the UIViewRoot using the UIViewRoot component resource methods as
described in link:JSF.html#a2257[See Methods].

Existing component libraries (with existing
head and body components), that want to use this resource loading
feature must follow the rendering requirements described in
link:JSF.html#a4314[See Standard HTML RenderKit Implementation].

=== [[a869]]Resource Rendering Using Annotations

Components and renderers may be declared as
requiring a resource using the @ResourceDependency annotation. The
implementation must scan for the presence of this annotation on the
component that was added to the List of child components. Check for the
presence of the annotation on the renderer for this component (if there
is a renderer for the component). The annotation check must be done
immediately after the component is added to the List. Refer to
link:JSF.html#a937[See Component Tree Manipulation]for detailed
information.

=== 

image:SF-12.png[image]

[[a872]]Resource Library Contracts

[P1-start_contract_packaging]A resource
library contract is a resource library, as specified in the preceding
section, except that instead of residing in the _resources_ directory of
the web-app root, or in the _META-INF/resources_ JAR entry name in a JAR
file, it resides in the _contracts_ directory of the web-app root, or in
the _META-INF/contracts_ JAR entry name in a JAR file. When packaged in
a JAR file, there is one additional packaging requirement: each resource
library contract in the JAR must have a marker file. The name of the
file is given by the value of the symbolic constant
_javax.faces.application.ResourceHandler.RESOURCE_CONTRACT_XML_ . This
may be a zero length file, though future versions of the specification
may use the file to declare the usage contract. [P1-end] The requirement
to have a marker file enables implementations to optimize for faster
deployment while still enabling automatic discovery of the available
contracts.

Following is a listing of the entries in a
JAR file containing two resource library contracts.

[width="100%",cols="100%",]
|===
a|
META-INF/contracts/ +
siteLayout/ +
javax.faces.contract.xml +
topNav_template.xhtml +
leftNav_foo.xhtml +
styles.css +
script.js +
background.png

 subSiteLayout/ +
javax.faces.contract.xml +
sub_template.xhtml



|===



All of the other packaging, encoding and
decoding requirements are the same as for resource libraries.

See link:JSF.html#a5526[See Resource
Library Contracts Background] for a non-normative overview of the
feature, including a brief usage example.



=== 

image:SF-15.png[image]

[[a883]]User Interface Component Model

image:SF-16.png[image]

A JSF _user interface component_ is the basic
building block for creating a JSF user interface. A particular component
represents a configurable and reusable element in the user interface,
which may range in complexity from simple (such as a button or text
field) to compound (such as a tree control or table). Components can
optionally be associated with corresponding objects in the data model of
an application, via _value expressions_ .

JSF also supports user interface components
with several additional helper APIs:

 _Converters_ —Pluggable support class to
convert the markup value of a component to and from the corresponding
type in the model tier.

 _Events and Listeners_ —An event broadcast
and listener registration model based on the design patterns of the
JavaBeans Specification, version 1.0.1.

 _Validators_ —Pluggable support classes that
can examine the local value of a component (as received in an incoming
request) and ensure that it conforms to the business rules enforced by
each Validator. Error messages for validation failures can be generated
and sent back to the user during rendering.

The user interface for a particular page of a
JSF-based web application is created by assembling the user interface
components for a particular request or response into a _view_ . The view
is a tree of classes that implement _UIComponent_ . The components in
the tree have parent-child relationships with other components, starting
at the _root element_ of the tree, which must be an instance of
_UIViewRoot_ . Components in the tree can be anonymous or they can be
given a _component identifier_ by the framework user. Components in the
tree can be located based on _component identifiers_ , which must be
unique within the scope of the nearest ancestor to the component that is
a _naming container_ . For complex rendering scenarios, components can
also be attached to other components as _facets_ .

This chapter describes the basic architecture
and APIs for user interface components and the supporting APIs.

=== 

image:SF-17.png[image]

UIComponent and UIComponentBase

The base abstract class for all user
interface components is _javax.faces.component.UIComponent_ . This class
defines the state information and behavioral contracts for all
components through a Java programming language API, which means that
components are independent of a rendering technology such as JavaServer
Pages (JSP). A standard set of components (described in
link:JSF.html#a1823[See Standard User Interface Components]”)
that add specialized properties, attributes, and behavior, is also
provided as a set of concrete subclasses.

Component writers, tool providers,
application developers, and JSF implementors can also create additional
_UIComponent_ implementations for use within a particular application.
To assist such developers, a convenience subclass,
_javax.faces.component.UIComponentBase_ , is provided as part of JSF.
This class provides useful default implementations of nearly every
_UIComponent_ method, allowing the component writer to focus on the
unique characteristics of a particular _UIComponent_ implementation.

The following subsections define the key
functional capabilities of JSF user interface components.

=== [[a895]]Component Identifiers

[width="100%",cols="100%",]
|===
a|
public String getId();



public void setId(String componentId);

|===

[N/T-start may-component-identifier] Every
component may be named by a _component identifier_ that must conform to
the following rules:

They must start with a letter (as defined by
the _Character.isLetter()_ method).

Subsequent characters must be letters (as
defined by the _Character.isLetter()_ method), digits as defined by the
_Character.isDigit()_ method, dashes (‘-’), or underscores (‘_’).

[P1-end] To minimize the size of responses
generated by JavaServer Faces, it is recommended that component
identifiers be as short as possible.

If a component has been given an identifier,
it must be unique in the namespace of the closest ancestor to that
component that is a _NamingContainer_ (if any).

=== Component Type

While not a property of _UIComponent_ , the
_component-type_ is an important piece of data related to each
_UIComponent_ subclass that allows the _Application_ instance to create
new instances of _UIComponent_ subclasses with that type. Please see
link:JSF.html#a3468[See Object Factories] for more on
_component-type_ .

Component types starting with “javax.faces.”
are reserved for use by the JSF specification.

=== Component Family

[width="100%",cols="100%",]
|===
|public String getFamily();
|===

Each standard user interface component class
has a standard value for the component family, which is used to look up
renderers associated with this component. Subclasses of a generic
UIComponent class will generally inherit this property from its
superclass, so that renderers who only expect the superclass will still
be able to process specialized subclasses.

Component families starting with
“javax.faces.” are reserved for use by the JSF specification.

=== [[a911]]ValueExpression properties

Properties and attributes of standard
concrete component classes may be _value expression enabled_ . This
means that, rather than specifying a literal value as the parameter to a
property or attribute setter, the caller instead associates a
_ValueExpression_ (see link:JSF.html#a3029[See ValueBinding])
whose _getValue()_ method must be called (by the property getter) to
return the actual property value to be returned if no value has been set
via the corresponding property setter. If a property or attribute value
has been set, that value must be returned by the property getter
(shadowing any associated value binding expression for this property).

Value binding expressions are managed with
the following method calls:

[width="100%",cols="100%",]
|===
a|
public ValueExpression
getValueExpression(String name);



public void setValueExpression(String name,
ValueExpression expression);

|===

{empty}where _name_ is the name of the
attribute or property for which to establish the value expression.
[P1-start setValueExpression rules] The implementation of
setValueExpression must detemine if the expression is a literal by
calling ValueExpression.isLiteralText() on the expression argument. If
the expression argument is literal text, then ValueExpression.getValue()
must be called on the expression argument. The result must be used as
the value argument, along with the name argument to this component’s
getAttributes().put(name, value) method call. [P1-end] [P1-start which
properties are value expression enabled] For the standard component
classes defined by this specification, all attributes, and all
properties other than _id_ , _parent_ , _action_ , _listener_ ,
_actionListener_ , _valueChangeListener_ , and _validator_ are value
expression enabled. The _action_ , _listener_ , _actionListener_ ,
_valueChangeListener_ , and _validator_ attributes are method expression
enabled.[P1-end]

In previous versions of this specification,
this concept was called “value binding”. Methods and classes referring
to this concept are deprecated, but remain implemented to preserve
backwards compatibility.

[width="100%",cols="100%",]
|===
a|
public ValueBinding getValueBinding(String
name);



public void setValueBinding(String name,
ValueBinding binding);

|===

Please consult the javadoc for these methods
to learn how they are implemented in terms of the new “value expression”
concept.

=== [[a923]]Component Bindings

A _component binding_ is a special value
expression that can be used to facilitate “wiring up” a component
instance to a corresponding property of a JavaBean that is associated
with the page, and wants to manipulate component instances
programatically. It is established by calling _setValueExpression()_
(see link:JSF.html#a911[See ValueExpression properties]) with
the special property name _binding_ .

The specified _ValueExpression_ must point to
a read-write JavaBeans property of type _UIComponent_ (or appropriate
subclass). Such a component binding is used at two different times
during the processing of a Faces Request:

{empty}[P3-start how a component binding is
used from a JSP page] When a component instance is first created
(typically by virtue of being referenced by a _UIComponentELTag_ in a
JSP page), the JSF implementation will retrieve the _ValueExpression_
for the name _binding,_ and call _getValue()_ on it. If this call
returns a non-null _UIComponent_ value (because the JavaBean
programmatically instantiated and configured a component already), that
instance will be added to the component tree that is being created. If
the call returns _null_ , a new component instance will be created,
added to the component tree, and _setValue()_ will be called on the
_ValueExpression_ (which will cause the property on the JavaBean to be
set to the newly created component instance). [P3-end]

{empty}[P1-start how a component binding is
used when restoring the tree]When a component tree is recreated during
the _Restore View_ phase of the request processing lifecycle, for each
component that has a _ValueExpression_ associated with the name
“binding”, _setValue()_ will be called on it, passing the recreated
component instance. [P1-end]

Component bindings are often used in
conjunction with JavaBeans that are dynamically instantiated via the
Managed Bean Creation facility (see _link:JSF.html#a3020[See
VariableResolver and the Default VariableResolver]_ ). If application
developers place managed beans that are pointed at by component binding
expressions in any scope other than request scope, the system cannot
behave correctly. This is because placing it in a scope wider than
request scope would require thread safety, since UIComponent instances
depend on running inside of a single thread. There are also potentially
negative impacts on memory management when placing a component binding
in “session” or “view” scopes.

=== Client Identifiers

Client identifiers are used by JSF
implementations, as they decode and encode components, for any occasion
when the component must have a client side name. Some examples of such
an occasion are:

to name request parameters for a subsequent
request from the JSF-generated page.

to serve as anchors for client side scripting
code.

to serve as anchors for client side
accessibility labels.

[width="100%",cols="100%",]
|===
a|
public String getClientId(FacesContext
context);

protected String
getContainerClientId(FacesContext context);

|===

The client identifier is derived from the
component identifier (or the result of calling
_UIViewRoot.createUniqueId()_ if there is not one), and the client
identifier of the closest parent component that is a _NamingContainer_
according to the algorithm specified in the javadoc for
_UIComponent.getClientId()_ . The _Renderer_ associated with this
component, if any, will then be asked to convert this client identifier
to a form appropriate for sending to the client. The value returned from
this method must be the same throughout the lifetime of the component
instance unless _setId()_ is called, in which case it will be
recalculated by the next call to _getClientId()_ .

=== [[a937]]Component Tree Manipulation

[width="100%",cols="100%",]
|===
a|
public UIComponent getParent();



public void setParent(UIComponent parent);

|===

Components that have been added as children
of another component can identify the parent by calling the _getParent_
method. For the root node component of a component tree, or any
component that is not part of a component tree, _getParent_ will return
_null_ . In some special cases, such as transient components, it is
possible that a component in the tree will return _null_ from
getParent(). The _setParent()_ method should only be called by the
_List_ instance returned by calling the _getChildren()_ method, or the
_Map_ instance returned by calling the _getFacets()_ method, when child
components or facets are being added, removed, or replaced.

[width="100%",cols="100%",]
|===
|public List<UIComponent> getChildren();
|===

Return a mutable _List_ that contains all of
the child _UIComponent_ s for this component instance. [P1-start
requirements of UIComponent.getChildren() ] The returned _List_
implementation must support all of the required and optional methods of
the _List_ interface, as well as update the parent property of children
that are added and removed, as described in the Javadocs for this
method. [P1-end] Note that the _add()_ methods have a special
requirement to cause the _PostAddToViewEvent_ method to be fired, as
well as the processing of the _ResourceDependency_ annotation. See the
javadocs for _getChildren()_ for details.

[width="100%",cols="100%",]
|===
|public int getChildCount();
|===

{empty}A convenience method to return the
number of child components for this component. [P2-start
UIComponent.getChildCount requirements.] If there are no children, this
method must return 0. The method must not cause the creation of a child
component list, so it is preferred over calling _getChildren().size()_
when there are no children. [P2-end]

=== [[a946]]Component Tree Navigation

[width="100%",cols="100%",]
|===
|public UIComponent findComponent(String
expr);
|===

Search for and return the UIComponent with an
_id_ that matches the specified search expression (if any), according to
the algorithm described in the Javadocs for this method.

[width="100%",cols="100%",]
|===
|public Iterator<UIComponent>
getFacetsAndChildren();
|===

Return an immutable _Iterator_ over all of
the facets associated with this component (in an undetermined order),
followed by all the child components associated with this component (in
the order they would be returned by _getChildren()_ )..

[width="100%",cols="100%",]
|===
|public boolean
invokeOnComponent(FacesContext context, String clientId, ContextCallback
callback) throws FacesException;
|===

Starting at _this_ component in the view,
search for the UIComponent whose _getClientId()_ method returns a String
that exactly matches the argument _clientId_ using the algorithm
specified in the Javadocs for this method. If such a UIComponent is
found, call the _invokeContextCallback()_ method on the argument
_callback_ passing the current _FacesContext_ and the found UIComponent.
Upon normal return from the callback, return _true_ to the caller. If
the callback throws an exception, it must be wrapped inside of a
_FacesException_ and re-thrown. If no such UIComponent is found, return
_false_ to the caller.

Special consideration should be given to the
implementation of _invokeOnComponent()_ for UIComponent classes that
handle iteration, such as _UIData_ . Iterating components manipulate
their own internal state to handle iteration, and doing so alters the
clientIds of components nested within the iterating component.
Implementations of _invokeOnComponent()_ must guarantee that any state
present in the component or children is restored before returning.
Please see the Javadocs for _UIData.invokeOnComponent()_ for details.

The _ContextCallback_ interface is specified
as follows..

[width="100%",cols="100%",]
|===
a|
public interface ContextCallback \{

 public void
invokeContextCallback(FacesContext context, UIComponent target);



}

|===

Please consult the Javadocs for more details
on this interface.

[width="100%",cols="100%",]
|===
|public static UIComponent
getCurrentComponent(FacesContext context);
|===

Returns the UIComponent instance that is
currently being processed.

[width="100%",cols="100%",]
|===
|public static UIComponent
getCurrentCompositeComponent(FacesContext context);
|===

Returns the closest ancestor component
relative to getCurrentComponent that is a composite component, or null
if no such component is exists.

[width="100%",cols="100%",]
|===
a|
public boolean visitTree(VisitContext
context,

 VisitCallback callback);



|===

Uses the visit API introduced in version 2 of
the specification to perform a flexible and customizable visit of the
tree from this instance and its children. Please see the package
description for the package _javax.faces.component.visit_ for the
normative specification.

=== [[a968]]Facet Management

JavaServer Faces supports the traditional
model of composing complex components out of simple components via
parent-child relationships that organize the entire set of components
into a tree, as described in link:JSF.html#a937[See Component
Tree Manipulation]. However, an additional useful facility is the
ability to define particular subordinate components that have a specific
_role_ with respect to the owning component, which is typically
independent of the parent-child relationship. An example might be a
“data grid” control, where the children represent the columns to be
rendered in the grid. It is useful to be able to identify a component
that represents the column header and/or footer, separate from the usual
child collection that represents the column data.

To meet this requirement, JavaServer Faces
components offer support for _facets_ , which represent a named
collection of subordinate (but non-child) components that are related to
the current component by virtue of a unique _facet name_ that represents
the role that particular component plays. Although facets are not part
of the parent-child tree, they participate in request processing
lifecycle methods, as described in link:JSF.html#a1059[See
Lifecycle Management Methods].

[width="100%",cols="100%",]
|===
|public Map<String, UIComponent> getFacets();
|===

Return a mutable Map representing the facets
of this UIComponent, keyed by the facet name.

[width="100%",cols="100%",]
|===
|public UIComponent getFacet(String name);
|===

A convenience method to return a facet value,
if it exists, or _null_ otherwise. If the requested facet does not
exist, no facets _Map_ must not be created, so it is preferred over
calling _getFacets().get()_ when there are no _Facet_ s.

For easy use of components that use facets,
component authors may include type-safe getter and setter methods that
correspond to each named facet that is supported by that component
class. For example, a component that supports a _header_ facet of type
_UIHeader_ should have methods with signatures and functionality as
follows:

[width="100%",cols="100%",]
|===
a|
public UIHeader getHeader() \{

 return ((UIHeader) getFacet(“header”);

}



public void setHeader(UIHeader header) \{

 getFacets().put(“header”, header);

}

|===

=== [[a983]]Managing Component Behavior

 _UIComponentBase_ provides default
implementations for the methods from the _javax.faces.c_ o
_mponent.behavior.BehaviorHolder_ interface. _UIComponentBase_ does not
implement the _javax.faces.component.behavior.BehaviorHolder_ interface,
but it provides the default implementations to simplify subclass
implemenations. Refer to
link:JSF.html#a1707[See Component
Behavior Model] for more information.

[width="100%",cols="100%",]
|===
|public void addBehavior(String eventName,
Behavior behavior)
|===

This method attaches a _Behavior_ to the
component for the specified _eventName. The eventName_ must be one of
the values in the _Collection_ returned from _getEventNames(). F_ or
example, it may be desired to have some behavior defined when a “click”
event occurs. The behavior could be some client side behavior in the
form of a script executing, or a server side listener executing.

[width="100%",cols="100%",]
|===
|public Collection<String> getEventNames()
|===

Returns the logical event names that can be
associated with behavior for the component.

[width="100%",cols="100%",]
|===
|public Map<String, List<Behavior>>
getBehaviors()
|===

Returns a _Map_ defining the association of
events and behaviors. They keys in the _Map_ are event names.

[width="100%",cols="100%",]
|===
|public String getDefaultEventName()
|===

Returns the default event name (if any) for
the component.

=== [[a993]]Generic Attributes

[width="100%",cols="100%",]
|===
|public Map<String, Object> getAttributes();
|===

The render-independent characteristics of
components are generally represented as JavaBean component properties
with getter and setter methods (see link:JSF.html#a1021[See
Render-Independent Properties]). In addition, components may also be
associated with generic attributes that are defined outside the
component implementation class. Typical uses of generic attributes
include:

Specification of render-dependent
characteristics, for use by specific _Renderer_ s.

General purpose association of
application-specific objects with components.

The attributes for a component may be of any
Java programming language object type, and are keyed by attribute name
(a String). However, see link:JSF.html#a4135[See State Saving
Alternatives and Implications] for implications of your application’s
choice of state saving method on the classes used to implement attribute
values.

Attribute names that begin with _javax.faces_
are reserved for use by the JSF specification. Names that begin with
_javax_ are reserved for definition through the Java Community Process.
Implementations are not allowed to define names that begin with _javax._

[P1-start attribute property transparency
rules] The _Map_ returned by _getAttributes()_ must also support
attribute-property transparency, which operates as follows:

When the _get()_ method is called, if the
specified attribute name matches the name of a readable JavaBeans
property on the component implementation class, the value returned will
be acquired by calling the appropriate property getter method, and
wrapping Java primitive values (such as int) in their corresponding
wrapper classes (such as _java.lang.Integer_ ) if necessary. If the
specified attribute name does not match the name of a readable JavaBeans
property on the component implementation class, consult the internal
data-structure to in which generic attributes are stored. If no entry
exists in the internal data-structure, see if there is a
_ValueExpression_ for this attribute name by calling
_getValueExpression()_ , passing the attribute name as the key. If a
_ValueExpression_ exists, call _getValue()_ on it, returning the result.
If an _ELException_ is thrown wrap it in a _FacesException_ and re-throw
it.

When the _put()_ method is called, if the
specified attribute name matches the name of a writable JavaBeans
property on the component implementation class, the appropriate property
setter method will be called. If the specified attribute name does not
match the name of a writable JavaBeans property, simply put the value in
the data-structure for generic attributes.

When the _remove()_ method is called, if the
specified attribute name matches the name of a JavaBeans property on the
component, an _IllegalArgumentException_ must be thrown.

When the _containsKey()_ method is called, if
the specified attribute name matches the name of a JavaBeans property,
return _false_ . Otherwise, return _true_ if and only if the specified
attribute name exists in the internal data-structure for the generic
attributes.

{empty}The _Map_ returned by
_getAttributes()_ must also conform to the entire contract for the _Map_
interface. [P1-end]

=== [[a1006]]Special Attributes

=== UIComponent Constants

[width="100%",cols="100%",]
|===
|public static final String CURRENT_COMPONENT
= "javax.faces.component.CURRENT_COMPONENT";
|===

This is used as a key in the _FacesContext_
attributes Map to indicate the component that is currently being
processed.

[width="100%",cols="100%",]
|===
|public static final String
CURRENT_COMPOSITE_COMPONENT =
"javax.faces.component.CURRENT_COMPOSITE_COMPONENT";
|===

This is used as a key in the _FacesContext_
attributes Map to indicate the composite component that is currently
being processed.

[width="100%",cols="100%",]
|===
|public static final String BEANINFO_KEY =
"javax.faces.component.BEANINFO_KEY";
|===

This is a key in the component attributes Map
whose value is a java.beans.BeanInfo describing the composite component.

[width="100%",cols="100%",]
|===
|public static final String FACETS_KEY =
"javax.faces.component.FACETS_KEY";
|===

This is a key in the composite component
BeanDescriptor whose value is a Map<PropertyDescriptor> that contains
meta-information for the declared facets for the composite component.

[width="100%",cols="100%",]
|===
|public static final String
COMPOSITE_COMPONENT_TYPE_KEY =
"javax.faces.component.COMPOSITE_COMPONENT_TYPE";
|===

This is a key in the composite component
BeanDescriptor whose value is a ValueExpression that evaluates to the
component-type of the composite component root.

[width="100%",cols="100%",]
|===
|public static final String
COMPOSITE_FACET_NAME = "javax.faces.component.COMPOSITE_FACET_NAME";
|===

This is a key in the Map<PropertyDescriptor>
that is returned by using the key FACETS_KEY. The value of this constant
is also used as the key in the Map returned from getFacets(). In this
case, the value of this key is the facet (the UIPanel) that is the
parent of all the components in the composite implementation section of
the composite component VDL file.

Refer to the
javax.faces.component.UIComponent Javadocs for more detailed
information.

=== [[a1021]]Render-Independent Properties

The render-independent characteristics of a
user interface component are represented as JavaBean component
properties, following JavaBeans naming conventions. Specifically, the
method names of the getter and/or setter methods are determined using
standard JavaBeans component introspection rules, as defined by
_java.beans.Introspector_ . The render-independent properties supported
by all _UIComponent_ s are described in the following table:

[width="100%",cols="25%,25%,25%,25%",options="header",]
|===
|Name |Access
|Type |Description
| _id_ |RW
|String |The
component identifier, as described in link:JSF.html#a895[See
Component Identifiers].

| _parent_ |RW
| _UIComponent_
|The parent component for which this
component is a child or a facet.

| _rendered_ |RW
| _boolean_ |A
flag that, if set to _true_ , indicates that this component should be
processed during all phases of the request processing lifecycle. The
default value is “true”.

| _rendererType_
|RW | _String_
|Identifier of the _Renderer_ instance (from
the set of _Renderer_ instances supported by the _RenderKit_ associated
with the component tree we are processing. If this property is set,
several operations during the request processing lifecycle (such as
_decode_ and the _encodeXxx_ family of methods) will be delegated to a
_Renderer_ instance of this type. If this property is not set, the
component must implement these methods directly.

| _rendersChildren_
|RO | _boolean_
|A flag that, if set to _true_ , indicates
that this component manages the rendering of all of its children
components (so the JSF implementation should not attempt to render
them). The default implementation in _UIComponentBase_ delegates this
setting to the associated _Renderer_ , if any, and returns _false_
otherwise.

| _transient_ |RW
|boolean |A flag
that, if set to _true_ , indicates that this component must not be
included in the state of the component tree. The default implementation
in _UIComponentBase_ returns _false_ for this property.
|===

The method names for the render-independent
property getters and setters must conform to the design patterns in the
JavaBeans specification. See link:JSF.html#a4135[See State
Saving Alternatives and Implications] for implications of your
application’s choice of state saving method on the classes used to
implement property values.

=== [[a1041]]Component Specialization Methods

The methods described in this section are
called by the JSF implementation during the various phases of the
request processing lifecycle, and may be overridden in a concrete
subclass to implement specialized behavior for this component.

[width="100%",cols="100%",]
|===
|public boolean broadcast(FacesEvent event)
throws AbortProcessingException;
|===

The _broadcast()_ method is called during the
common event processing (see link:JSF.html#a494[See Common
Event Processing]) at the end of several request processing lifecycle
phases. For more information about the event and listener model, see
link:JSF.html#a1300[See Event and Listener Model]. Note that it
is not necessary to override this method to support additional event
types.

[width="100%",cols="100%",]
|===
|public void decode(FacesContext context);
|===

This method is called during the _Apply
Request Values_ phase of the request processing lifecycle, and has the
responsibility of extracting a new local value for this component from
an incoming request. The default implementation in _UIComponentBase_
delegates to a corresponding _Renderer_ , if the _rendererType_ property
is set, and does nothing otherwise.

Generally, component writers will choose to
delegate decoding and encoding to a corresponding _Renderer_ by setting
the _rendererType_ property (which means the default behavior described
above is adequate).

[width="100%",cols="100%",]
|===
a|
public void encodeAll(FacesContext context)
throws IOException

public void encodeBegin(FacesContext context)
throws IOException;



public void encodeChildren(FacesContext
context) throws IOException;



public void encodeEnd(FacesContext context)
throws IOException;

|===

{empty}These methods are called during the
_Render Response_ phase of the request processing lifecycle.
_encodeAll()_ will cause this component and all its children and facets
that return _true_ from _isRendered()_ to be rendered, regardless of the
value of the _getRendersChildren()_ return value. _encodeBegin()_ ,
_encodeChildren()_ , and _encodeEnd()_ have the responsibility of
creating the response data for the beginning of this component, this
component’s children (only called if the _rendersChildren_ property of
this component is _true_ ), and the ending of this component,
respectively. Typically, this will involve generating markup for the
output technology being supported, such as creating an HTML _<input>_
element for a _UIInput_ component. For clients that support it, the
encode methods might also generate client-side scripting code (such as
JavaScript), and/or stylesheets (such as CSS). The default
implementations in _UIComponentBase_ _encodeBegin()_ and _encodeEnd()_
delegate to a corresponding _Renderer_ , if the _rendererType_ property
is _true_ , and do nothing otherwise. [P1-start-comp-special]The default
implementation in UIComponentBase _encodeChildren()_ must iterate over
its children and call _encodeAll()_ for each child component.
_encodeBegin()_ must publish a _PreRenderComponentEvent._ [P1-end]

Generally, component writers will choose to
delegate encoding to a corresponding _Renderer_ , by setting the
_rendererType_ property (which means the default behavior described
above is adequate).

[width="100%",cols="100%",]
|===
|public void queueEvent(FacesEvent event);
|===

Enqueue the specified event for broadcast at
the end of the current request processing lifecycle phase. Default
behavior is to delegate this to the _queueEvent()_ of the parent
component, normally resulting in broadcast via the default behavior in
the _UIViewRoot_ lifecycle methods.

The component author can override any of the
above methods to customize the behavior of their component.

=== [[a1059]]Lifecycle Management Methods

The following methods are called by the
various phases of the request processing lifecycle, and implement a
recursive tree walk of the components in a component tree, calling the
component specialization methods described above for each component.
These methods are not generally overridden by component writers, but
doing so may be useful for some advanced component implementations. See
the javadocs for detailed information on these methods

In order to support the “component” implicit
object (See link:JSF.html#a2830[See Implicit Object ELResolver
for Facelets and Programmatic Access]), the following methods have been
added to _UIComponent_

[width="100%",cols="100%",]
|===
a|
protected void pushComponentToEL(FacesContext
context);

protected void
popComponentFromEL(FacesContext context)

|===

 _pushComponentToEL()_ and
_popComponentFromEL()_ must be called inside each of the lifecycle
management methods in this section as specified in the javadoc for that
method.

[width="100%",cols="100%",]
|===
|public void processRestoreState(FacesContext
context, Object state);
|===

Perform the component tree processing
required by the _Restore View_ phase of the request processing lifecycle
for all facets of this component, all children of this component, and
this component itself.

[width="100%",cols="100%",]
|===
|public void processDecodes(FacesContext
context);
|===

Perform the component tree processing
required by the _Apply Request Values_ phase of the request processing
lifecycle for all facets of this component, all children of this
component, and this component itself

[width="100%",cols="100%",]
|===
|public void processValidators(FacesContext
context);
|===

Perform the component tree processing
required by the _Process Validations_ phase of the request processing
lifecycle for all facets of this component, all children of this
component, and this component itself.

[width="100%",cols="100%",]
|===
|public void processUpdates(FacesContext
context);
|===

Perform the component tree processing
required by the Update Model Values phase of the request processing
lifecycle for all facets of this component, all children of this
component, and this component itself.

[width="100%",cols="100%",]
|===
|public void processSaveState(FacesContext
context);
|===

Perform the component tree processing
required by the state saving portion of the _Render Response_ phase of
the request processing lifecycle for all facets of this component, all
children of this component, and this component itself.

=== [[a1075]]Utility Methods

[width="100%",cols="100%",]
|===
|protected FacesContext getFacesContext();
|===

Return the FacesContext instance for the
current request.

[width="100%",cols="100%",]
|===
|protected Renderer getRenderer(FacesContext
context);
|===

Return the _Renderer_ that is associated this
_UIComponent_ , if any, based on the values of the _family_ and
_rendererType_ properties currently stored as instance data on the
_UIComponent_ .

[width="100%",cols="100%",]
|===
a|
protected void addFacesListener(FacesListener
listener);



protected void
removeFacesListener(FacesListener listener);

|===

These methods are used to register and
deregister an event listener. They should be called only by a public
addXxxListener() method on the component implementation class, which
provides typesafe listener registration.

[width="100%",cols="100%",]
|===
|public Map<String, String>
getResourceBundleMap();
|===

Return a Map of the ResourceBundle for this
component. Please consult the Javadocs for more information.



=== 

image:SF-17.png[image]

[[a1088]]Component Behavioral Interfaces

In addition to extending _UIComponent_ ,
component classes may also implement one or more of the _behavioral
interfaces_ described below. Components that implement these interfaces
must provide the corresponding method signatures and implement the
described functionality.

=== [[a1090]]ActionSource

The _ActionSource_ interface defines a way
for a component to indicate that wishes to be a source of _ActionEvent_
events, including the ability invoke application actions (see
link:JSF.html#a3553[See Application Actions]) via the default
_ActionListener_ facility (see link:JSF.html#a3402[See
ActionListener Property]).

=== [[a1092]]Properties

The following render-independent properties
are added by the _ActionSource_ interface:

[width="100%",cols="25%,25%,25%,25%",options="header",]
|===
|Name |Access
|Type |Description
| _action_ |RW
| _MethodBinding_
|DEPRECATED A _MethodBinding_ (see
link:JSF.html#a3039[See MethodBinding]) that must (if non-
_null_ ) point at an action method (see link:JSF.html#a3553[See
Application Actions]). The specified method will be called during the
_Apply Request Values_ or _Invoke Application_ phase of the request
processing lifecycle, as described in link:JSF.html#a454[See
Invoke Application]. This method is replaced by the _actionExpression_
property on _ActionSource2._ See the javadocs for the backwards
compatibility implementation strategy.

|actionListener
|RW |MethodBinding
|DEPRECATED A _MethodBinding_ (see
link:JSF.html#a3039[See MethodBinding]) that (if non- _null_ )
must point at a method accepting an _ActionEvent_ , with a return type
of _void_ . Any _ActionEvent_ that is sent by this _ActionSource_ will
be passed to this method along with the _processAction()_ method of any
registered _ActionListener_ s, in either Apply Request Values or Invoke
Application phase, depending upon the state of the _immediate_ property.
See the javadocs for the backwards compatibility implementation
strategy.

|immediate |RW
|boolean |A flag
indicating that the default _ActionListener_ should execute immediately
(that is, during the _Apply Request Values_ phase of the request
processing lifecycle, instead of waiting for _Invoke Application_
phase). The default value of this property must be _false_ .
|===



=== Methods

 _ActionSource_ adds no new processing
methods.

=== Events

A component implementing _ActionSource_ is a
source of _ActionEvent_ events. There are three important moments in the
lifetime of an _ActionEvent_ :

when an the event is _created_

when the event is _queued_ for later
processing

when the listeners for the event are
_notified_

 _ActionEvent_ creation occurs when the
system detects that the component implementing _ActionSource_ has been
activated. For example, a button has been pressed. This happens when the
_decode()_ processing of the _Apply Request Values_ phase of the request
processing lifecycle detects that the corresponding user interface
control was activated.

 _ActionEvent_ queueing occurs immediately
after the event is created.

Event listeners that have registered an
interest in _ActionEvent_ s fired by this component (see below) are
notified at the end of the _Apply Request Values_ or _Invoke
Application_ phase, depending upon the immediate property of the
originating _UICommand_ .

 _ActionSource_ includes the following
methods to register and deregister _ActionListener_ instances interested
in these events. See link:JSF.html#a1300[See Event and Listener
Model] for more details on the event and listener model provided by JSF.

[width="100%",cols="100%",]
|===
a|
public void addActionListener(ActionListener
listener);



public void
removeActionListener(ActionListener listener);

|===

In addition to manually registered listeners,
the JSF implementation provides a default _ActionListener_ that will
process _ActionEvent_ events during the _Apply Request Values_ or
_Invoke Application_ phases of the request processing lifecycle. See
link:JSF.html#a454[See Invoke Application] for more
information.

=== [[a1120]]ActionSource2

The _ActionSource2_ interface extends
_ActionSource_ and provides a JavaBeans property analogous to the
_action_ property on _ActionSource_ . This allows the _ActionSource_
concept to leverage the new Unified EL API.

=== Properties

The following render-independent properties
are added by the _ActionSource_ interface:

[width="100%",cols="25%,25%,25%,25%",options="header",]
|===
|Name |Access
|Type |Description
| _actionExpression_
|RW |
_javax.el.MethodExpression_ |A
_MethodExpression_ (see link:JSF.html#a3039[See MethodBinding])
that must (if non- _null_ ) point at an action method (see
link:JSF.html#a3553[See Application Actions]). The specified
method will be called during the _Apply Request Values_ or _Invoke
Application_ phase of the request processing lifecycle, as described in
link:JSF.html#a454[See Invoke Application].
|===



=== Methods

 _ActionSource2_ adds no new processing
methods.

=== Events

 _ActionSource2_ adds no new events.

=== [[a1134]]NamingContainer

 _NamingContainer_ is a marker interface.
Components that implement _NamingContainer_ have the property that, for
all of their children that have non- _null_ component identifiers, all
of those identifiers are unique. This property is enforced by the
_renderView()_ method on _ViewHandler_ . In JSP based applications, it
is also enforced by the _UIComponentELTag_ . Since this is just a marker
interface, there are no properties, methods, or events. Among the
standard components, _UIForm_ and _UIData_ implement _NamingContainer_ .
See link:JSF.html#a1932[See UIForm] and _Section_
link:JSF.html#a1921[See Methods] “UIData” for details of how the
_NamingContainer_ concept is used in these two cases.

 _NamingContainer_ defines a public static
final character constant, _SEPARATOR_CHAR_ , that is used to separate
components of client identifiers, as well as the components of search
expressions used by the _findComponent()_ method see
(link:JSF.html#a946[See Component Tree Navigation]). The value
of this constant must be a colon character (“:”).

Use of this separator character in client
identifiers rendered by _Renderer_ s can cause problems with CSS
stylesheets that attach styles to a particular client identifier. For
the Standard HTML RenderKit, this issue can be worked around by using
the _style_ attribute to specify CSS style values directly, or the
_styleClass_ attribute to select CSS styles by class rather than by
identifier.

=== [[a1138]]StateHolder

The _StateHolder_ interface is implemented by
_UIComponent_ , _Converter_ , _FacesListener_ , and _Validator_ classes
that need to save their state between requests. _UIComponent_ implements
this interface to denote that components have state that must be saved
and restored between requests.

=== Properties

The following render-independent properties
are added by the _StateHolder_ interface:

[width="100%",cols="25%,25%,25%,25%",options="header",]
|===
|Name |Access
|Type |Description
| _transient_ |RW
| _boolean_ |A
flag indicating whether this instance has decided to opt out of having
its state information saved and restored. The default value for all
standard component, converter, and validator classes that implement
_StateHolder_ must be _false_ .
|===



=== Methods

Any class implementing _StateHolder_ must
implement both the _saveState()_ and _restoreState()_ methods, since
these two methods have a tightly coupled contract between themselves. In
other words, if there is an inheritance hierarchy, it is not permissible
to have the _saveState()_ and _restoreState()_ methods reside at
different levels of the hierarchy.

[width="100%",cols="100%",]
|===
a|
public Object saveState(FacesContext
context);

public void restoreState(FacesContext
context, Object state) throws IOException;

|===

Gets or restores the state of the instance as
a _Serializable_ _Object_ .

If the class that implements this interface
has references to Objects which also implement _StateHolder_ (such as a
_UIComponent_ with a converter, event listeners, and/or validators)
these methods must call the _saveState()_ or _restoreState()_ method on
all those instances as well.

Any class implementing _StateHolder_ must
have a public no-args constructor.

If the state saving method is server, these
methods may not be called.

If the class that implements this interface
has references to Objects which do not implement _StateHolder_ , these
methods must ensure that the references are preserved. For example,
consider class _MySpecialComponent_ , which implements _StateHolder_ ,
and keeps a reference to a helper class, _MySpecialComponentHelper_ ,
which does not implement _StateHolder_ .
_MySpecialComponent.saveState()_ must save enough information about
_MySpecialComponentHelper_ , so that when
_MySpecialComponent.restoreState()_ is called, the reference to
_MySpecialComponentHelper_ can be restored. The return from
_saveState()_ must be _Serializable_ .

Since all of the standard user interface
components listed in link:JSF.html#a1823[See Standard User
Interface Components]” extend from _UIComponent_ , they all implement
the _StateHolder_ interface. In addition, the standard _Converter_ and
_Validator_ classes that require state to be saved and restored also
implement _StateHolder._

=== Events

 _StateHolder_ does not originate any
standard events.

=== [[a1159]]PartialStateHolder

 _PartialStateHolder_ extends _StateHolder_
and adds a usage contract for components that wish to take part in the
partial state saving mechanism introduced in version 2.0.
Implementations of this interface should use the
_javax.faces.component.StateHelper_ instance returned from
_UIComponent.getStateHelper()_ to store stateful component information
that otherwise would have been stored as instance variables on the class
implementing _PartialStateHolder_ .

=== Properties

 _PartialStateHolder_ adds no properties to
the _StateHolder_ contract

=== [[a1215]]Methods

The following methods support the partial
state saving feature:

[width="100%",cols="100%",]
|===
a|
void clearInitialState();



boolean initialStateMarked();



void markInitialState();

|===

These methods allow the state saving feature
to determine if the component is in its initial state or not, and to set
the flag indicating this condition of existence. The Javadocs for these
methods specify the conditions under which these methods are invoked.

=== Events

 _PartialStateHolder_ does not originate any
standard events.

=== [[a1173]]ValueHolder

 _ValueHolder_ is an interface that may be
implemented by any concrete _UIComponent_ that wishes to support a local
value, as well as access data in the model tier via a _value expression_
, and support conversion between _String_ and the model tier data's
native data type.

=== [[a1175]]Properties

The following render-independent properties
are added by the _ValueHolder_ interface:

[width="100%",cols="25%,25%,25%,25%",options="header",]
|===
|Name |Access
|Type |Description
|converter |RW
|Converter |The
_Converter_ (if any) that is registered for this UIComponent.

| _value_ |RW
| _Object_ |First
consult the local value property of this component. If non- _null_
return it. If the local value property is _null_ , see if we have a
_ValueExpression_ for the value property. If so, return the result of
evaluating the property, otherwise return _null_ .

|localValue |RO
|Object |allows
any value set by calling _setValue()_ to be returned, without
potentially evaluating a _ValueExpression_ the way that _getValue()_
will do
|===

Like nearly all component properties, the
_value_ property may have a value binding expression (see
link:JSF.html#a911[See ValueExpression properties]) associated
with it. If present (and if there is no _value_ set directly on this
component), such an expression is utilized to retrieve a value
dynamically from a model tier object during _Render Response Phase_ of
the request processing lifecycle. In addition, for input components, the
value expression is used during _Update Model Values_ phase (on the
subsequent request) to push the possibly updated component value back to
the model tier object.

The _Converter_ property is used to allow the
component to know how to convert the model type from the _String_ format
provided by the Servlet API to the proper type in the model tier.

The _Converter_ property must be inspected
for the presence of _ResourceDependency_ and _ResourceDependencies_
annotations as described in the Javadocs for the _setConverter_ method.

=== Methods

ValueHolder adds no methods.

=== Events

 _ValueHolder_ does not originate any
standard events.

=== [[a1192]]EditableValueHolder

The _EditableValueHolder_ interface (extends
_ValueHolder_ , see link:JSF.html#a1173[See ValueHolder])
describes additional features supported by editable components,
including _ValueChangeEvents_ and _Validators_ .

=== Properties

The following render-independent properties
are added by the _EditableValueHolder_ interface:

[width="100%",cols="25%,25%,25%,25%",options="header",]
|===
|Name |Access
|Type |Description
|immediate |RW
|boolean |Flag
indicating that conversion and validation of this component’s value
should occur during _Apply Request Values_ phase instead of _Process
Validations_ phase.

|localValueSet |RW
|boolean |Flag
indicating whether the _value_ property has been set.

|required |RW
|boolean |Is the
user required to provide a non-empty value for this component? Default
value must be _false_ .

|submittedValue
|RW | _Object_
|The submitted, unconverted, value of this
component. This property should only be set by the decode() method of
this component, or its corresponding Renderer, or by the validate method
of this component. This property should only be read by the validate()
method of this component.

|valid |RW
|boolean |A flag
indicating whether the local value of this component is valid (that is,
no conversion error or validation error has occurred).

|validator |RW
|MethodBinding
|DEPRECATED A _MethodBinding_ that (if not
null) must point at a method accepting a _FacesContext_ and a _UIInput_
, with a return type of _void_ . This method will be called during
_Process Validations_ phase, after any validators that are externally
registered. See the javadocs for the backwards compatibility strategy.

|valueChangeListener
|RW |MethodBinding
|DEPRECATED A MethodBinding that (if not
null) must point at a method that accepts a _ValueChangeEvent_ , with a
return type of _void_ . The specified method will be called during the
_Process Validations_ phase of the request processing lifecycle, after
any externally registered _ValueChangeListener_ s. See the javadocs for
the backwards compatibility strategy.
|===

=== Methods

The following methods support the validation
functionality performed during the _Process Validations_ phase of the
request processing lifecycle:

[width="100%",cols="100%",]
|===
a|
public void addValidator(Validator
validator);



public void removeValidator(Validator
validator);

|===

The _addValidator()_ and _removeValidator()_
methods are used to register and deregister additional external
_Validator_ instances that will be used to perform correctness checks on
the local value of this component.

If the _validator_ property is not null, the
method it points at must be called by the _processValidations()_ method,
after the _validate()_ method of all registered _Validator_ s is called.

The addValidator’s Validator argument must be
inspected for the presense of the ResourceDependency and
ResourceDependencies annotations as described in the Javadocs for the
addValidator method.

=== [[a1223]]Events

 _EditableValueHolder_ is a source of
_ValueChangeEvent_ , _PreValidateEvent_ and _PostValidate_ events. These
are emitted during calls to _validate()_ , which happens during the
_Process Validations_ phase of the request processing lifecycle. The
_PreValidateEvent_ is published immediately before the component gets
validated. _PostValidate_ is published after validation has occurred,
regardless if the validation was successful or not. If the validation
for the component did pass successfully, and the previous value of this
component differs from the current value, the _ValueChangeEvent_ is
published. The following methods allow listeners to register and
deregister for _ValueChangeEvent_ s. __ See
link:JSF.html#a1300[See Event and Listener Model] for more
details on the event and listener model provided by JSF.

[width="100%",cols="100%",]
|===
a|
public void
addValueChangeListener(ValueChangeListener listener);



public void
removeValueChangeListener(ValueChangeListener listener);

|===

In addition to the above listener
registration methods, If the _valueChangeListener_ property is not
_null_ , the method it points at must be called by the _broadcast()_
method, after the _processValueChange()_ method of all registered
_ValueChangeListener_ s is called.

=== [[a1229]]SystemEventListenerHolder

Classes that implement this interface agree
to maintain a list of _SystemEventListener_ instances for each kind of
_SystemEvent_ they can generate. This interface enables arbitrary
Objects to act as the source for _SystemEvent_ instances.

=== Properties

This interface contains no JavaBeans
properties

=== Methods

The following method gives the JSF runtime
access to the list of listeners stored by this instance.:

[width="100%",cols="100%",]
|===
|public List<FacesLifecycleListener>
getListenersForEventClass(Class<? extends SystemEvent> facesEventClass);
|===

During the processing for
_Application.publishEvent()_ , if the _source_ argument to that method
implements _SystemEventListenerHolder_ , the
_getListenersForEventClass()_ method is invoked on it, and each listener
in the list is given an opportunity to process the event, as specified
in the javadocs for _Application.publishEvent()_ .

=== Events

While the class that implements
_SystemEventListenerHolder_ is indeed a source of events, it is a call
to _Application.publishEvent()_ that causes the event to actually be
emitted. In the interest of maximum flexibility, this interface does not
define how listeners are added, removed, or stored. See
link:JSF.html#a1300[See Event and Listener Model] for more
details on the event and listener model provided by JSF.

=== [[a1239]]ClientBehaviorHolder

[P1-start-addBehavior] Components must
implement the _ClientBehaviorHolder_ interface to add the ability for
attaching ClientBehavior instances (see
link:JSF.html#a1707[See Component
Behavior Model]). Components that extend UIComponentBase only need to
implement the getEventNames() method and specify "implements
ClientBehaviorHolder". UIComponentBase provides base implementations for
all other methods. [P1-end] The concrete HTML component classes that
come with JSF implement the _ClientBehaviorHolder_ interface.

[width="100%",cols="100%",]
|===
|public void addClientBehavior(String
eventName, ClientBehavior behavior);
|===

Attach a ClientBehavior to a component
implementing this _ClientBehaviorHolder_ interface for the specified
event. A default implementation of this method is provided in
UIComponentBase to make it easier for subclass implementations to add
behaviors.

[width="100%",cols="100%",]
|===
|public Collection<String> getEventNames();
|===

{empty}Return a Collection of logical event
names that are supported by the component implementing this
_ClientBehaviorHolder_ interface. [P1-start-getEventNames]The Collection
must be non null and unmodifiable.[P1-end]

[width="100%",cols="100%",]
|===
|public Map<String, List<ClientBehavior>>
getClientBehaviors();
|===

Return a Map containing the event-client
behavior association. Each event in the Map may contain one or more
ClientBehavior instances that were added via the addClientBehavior()
method.

{empty}[P1-start-getBehaviors]Each key value
in this Map must be one of the event names in the Collection returned
from getEventNames().[P1-end]

[width="100%",cols="100%",]
|===
|public String getDefaultEventName();
|===

Return the default event name for this
component behavior if the component defines a default event.

=== 

image:SF-17.png[image]

[[a1251]]Conversion Model

This section describes the facilities
provided by JavaServer Faces to support type conversion between
server-side Java objects and their (typically String-based)
representation in presentation markup.

=== Overview

A typical web application must constantly
deal with two fundamentally different viewpoints of the underlying data
being manipulated through the user interface:

The _model_ view—Data is typically
represented as Java programming language objects (often JavaBeans
components), with data represented in some native Java programming
language datatype. For example, date and time values might be
represented in the model view as instances of _java.util.Date_ .

The _presentation_ view—Data is typically
represented in some form that can be perceived or modified by the user
of the application. For example, a date or type value might be
represented as a text string, as three text strings (one each for
month/date/year or one each for hour/minute/second), as a calendar
control, associated with a spin control that lets you increment or
decrement individual elements of the date or time with a single mouse
click, or in a variety of other ways. Some presentation views may depend
on the preferred language or locale of the user (such as the commonly
used mm/dd/yy and dd/mm/yy date formats, or the variety of punctuation
characters in monetary amount presentations for various currencies).

To transform data formats between these
views, JavaServer Faces provides an ability to plug-in an optional
_Converter_ for each _ValueHolder_ , which has the responsibility of
converting the internal data representation between the two views. The
application developer attaches a particular _Converter_ to a particular
_ValueHolder_ by calling _setConverter_ , passing an instance of the
particular converter. A _Converter_ implementation may be acquired from
the _Application_ instance (see link:JSF.html#a3468[See Object
Factories]) for your application.

=== [[a1258]]Converter

JSF provides the
_javax.faces.convert.Converter_ interface to define the behavioral
characteristics of a _Converter_ . Instances of implementations of this
interface are either identified by a _converter identifier_ , or by a
class for which the _Converter_ class asserts that it can perform
successful conversions, which can be registered with, and later
retrieved from, an _Application_ , as described in
link:JSF.html#a3468[See Object Factories].

Often, a _Converter_ will be an object that
requires no extra configuration information to perform its
responsibilities. However, in some cases, it is useful to provide
configuration parameters to the _Converter_ (such as a
_java.text.DateFormat_ pattern for a _Converter_ that supports
_java.util.Date_ model objects). Such configuration information will
generally be provided via JavaBeans properties on the _Converter_
instance.

 _Converter_ implementations should be
programmed so that the conversions they perform are symmetric. In other
words, if a model data object is converted to a String (via a call to
the _getAsString_ method), it should be possible to call _getAsObject_
and pass it the converted String as the value parameter, and return a
model data object that is semantically equal to the original one. In
some cases, this is not possible. For example, a converter that uses the
formatting facilities provided by the _java.text.Format_ class might
create two adjacent integer numbers with no separator in between, and in
this case the _Converter_ could not tell which digits belong to which
number.

For _UIInput_ and _UIOutput_ components that
wish to explicitly select a _Converter_ to be used, a new _Converter_
instance of the appropriate type must be created, optionally configured,
and registered on the component by calling _setConverter()_
link:#a9086[4]. Otherwise, the JSF implementation will
automatically create new instances based on the data type being
converted, if such Converter classes have been registered. In either
case, Converter implementations need not be threadsafe, because they
will be used only in the context of a single request processing thread.

The following two method signatures are
defined by the _Converter_ interface:

[width="100%",cols="100%",]
|===
|public Object getAsObject(FacesContext
context, UIComponent component, String value) throws ConverterException;
|===

This method is used to convert the
presentation view of a component’s value (typically a String that was
received as a request parameter) into the corresponding model view. It
is called during the _Apply Request Values_ phase of the request
processing lifecycle.

[width="100%",cols="100%",]
|===
|public String getAsString(FacesContext
context, UIComponent component, Object value) throws ConverterException;
|===

This method is used to convert the model view
of a component’s value (typically some native Java programming language
class) into the presentation view (typically a String that will be
rendered in some markup language. It is called during the _Render
Response_ phase of the request processing lifecycle.

{empty}[P1-start-converter-resource]If the
class implementing Converter has a ResourceDependency annotation or a
ResourceDependencies annotation, the action described in the Javadocs
for the Converter interface must be followed when
ValueHolder.setConverter is called.[P1-end]

=== Standard Converter Implementations

JSF provides a set of standard _Converter_
implementations. A JSF implementation must register the _DateTime_ and
_Number_ converters by name with the _Application_ instance for this web
application, as described in the table below. This ensures that the
converters are available for subsequent calls to
_Application.createConverter()_ . Each concrete implementation class
must define a static final String constant _CONVERTER_ID_ whose value is
the standard converter id under which this Converter is registered.

[P1-start standard converters] The following
converter id values must be registered to create instances of the
specified Converter implementation classes:

 _javax.faces.BigDecimal_ -- An instance of
_javax.faces.convert.BigDecimalConverter_ (or a subclass of this class).

 _javax.faces.BigInteger_ -- An instance of
_javax.faces.convert.BigIntegerConverter_ (or a subclass of this class).

 _javax.faces.Boolean_ -- An instance of
_javax.faces.convert.BooleanConverter_ (or a subclass of this class).

 _javax.faces.Byte_ -- An instance of
_javax.faces.convert.ByteConverter_ (or a subclass of this class).

 _javax.faces.Character_ -- An instance of
_javax.faces.convert.CharacterConverter_ (or a subclass of this class).

 _javax.faces.DateTime_ -- An instance of
_javax.faces.convert.DateTimeConverter_ (or a subclass of this class).

 _javax.faces.Double_ -- An instance of
_javax.faces.convert.DoubleConverter_ (or a subclass of this class).

 _javax.faces.Float_ -- An instance of
_javax.faces.convert.FloatConverter_ (or a subclass of this class).

 _javax.faces.Integer_ -- An instance of
_javax.faces.convert.IntegerConverter_ (or a subclass of this class).

 _javax.faces.Long_ -- An instance of
_javax.faces.convert.LongConverter_ (or a subclass of this class).

 _javax.faces.Number_ -- An instance of
_javax.faces.convert.NumberConverter_ (or a subclass of this class).

 _javax.faces.Short_ -- An instance of
_javax.faces.convert.ShortConverter_ (or a subclass of this class).

[P1-end] See the Javadocs for these classes
for a detailed description of the conversion operations they perform,
and the configuration properties that they support.

[P1-start by-Class converters] A JSF
implementation must register converters for all of the following classes
using the by-type registration mechanism:

 _java.math.BigDecimal,_ and
_java.math.BigDecimal.TYPE_ -- An instance of
_javax.faces.convert.BigDecimalConverter_ (or a subclass of this class)
_._

 _java.math.BigInteger,_ and
_java.math.BigInteger.TYPE_ -- An instance of
_javax.faces.convert.BigIntegerConverter_ (or a subclass of this class)
_._

 _java.lang.Boolean_ , and
_java.lang.Boolean.TYPE_ -- An instance of
_javax.faces.convert.BooleanConverter_ (or a subclass of this class).

 _java.lang.Byte_ , and _java.lang.Byte.TYPE_
-- An instance of _javax.faces.convert.ByteConverter_ (or a subclass of
this class).

 _java.lang.Character_ , and
_java.lang.Character.TYPE_ -- An instance of
_javax.faces.convert.CharacterConverter_ (or a subclass of this class).

 _java.lang.Double_ , and
_java.lang.Double.TYPE_ -- An instance of
_javax.faces.convert.DoubleConverter_ (or a subclass of this class).

 _java.lang.Float_ , and
_java.lang.Float.TYPE_ -- An instance of
_javax.faces.convert.FloatConverter_ (or a subclass of this class).

 _java.lang.Integer_ , and
_java.lang.Integer.TYPE_ -- An instance of
_javax.faces.convert.IntegerConverter_ (or a subclass of this class).

 _java.lang.Long_ , and _java.lang.Long.TYPE_
-- An instance of _javax.faces.convert.LongConverter_ (or a subclass of
this class).

 _java.lang.Short_ , and
_java.lang.Short.TYPE_ -- An instance of
_javax.faces.convert.ShortConverter_ (or a subclass of this class).

 _java.lang.Enum_ , and _java.lang.Enum.TYPE_
-- An instance of _javax.faces.convert.EnumConverter_ (or a subclass of
this class).

[P1-end] See the Javadocs for these classes
for a detailed description of the conversion operations they perform,
and the configuration properties that they support.

{empty}[P1-start allowing string converters]
A compliant implementation must allow the registration of a converter
for class _java.lang.String_ and _java.lang.String.TYPE_ that will be
used to convert values for these types. [P1-end]

=== 

image:SF-17.png[image]

[[a1300]]Event and Listener Model

This section describes how JavaServer Faces
provides support for generating and handling user interface events and
system events.

=== [[a1302]]Overview

JSF implements a model for event notification
and listener registration based on the design patterns in the _JavaBeans
Specification_ , version 1.0.1. This is similar to the approach taken in
other user interface toolkits, such as the Swing Framework included in
the JDK.

A _UIComponent_ subclass may choose to emit
_events_ that signify significant state changes, and broadcast them to
_listeners_ that have registered an interest in receiving events of the
type indicated by the event’s implementation class. At the end of
several phases of the request processing lifecycle, the JSF
implementation will broadcast all of the events that have been queued to
interested listeners. As of JSF version 2, the specification also
defines _system events_ . System events are events that are not specific
to any particular application, but rather stem from specific points in
time of running a JSF application. The following UML class diagram
illustrates the key players in the event model. Boxes shaded in gray
indicate classes or interfaces defined outside of the
_javax.faces.event_ package.



image:SF-18.png[image]

=== [[a1306]]Application Events

Application events are events that are
specific to a particular application. Application events are the
standard events that have been in JSF from the beginning.

=== [[a1308]]Event Classes

All events that are broadcast by JSF user
interface components must extend the _javax.faces.event.FacesEvent_
abstract base class. The parameter list for the constructor(s) of this
event class must include a _UIComponent_ , which identifies the
component from which the event will be broadcast to interested
listeners. The source component can be retrieved from the event object
itself by calling _getComponent_ . Additional constructor parameters
and/or properties on the event class can be used to relay additional
information about the event.

In conformance to the naming patterns defined
in the _JavaBeans Specification_ , event classes typically have a class
name that ends with _Event_ . It is recommended that application event
classes follow this naming pattern as well.

The component that is the source of a
FacesEvent can be retrieved via this method:

[width="100%",cols="100%",]
|===
|public UIComponent getComponent();
|===

 _FacesEvent_ has a _phaseId_ property (of
type _PhaseId_ , see link:JSF.html#a1335[See Phase Identifiers])
used to identify the request processing lifecycle phase after which the
event will be delivered to interested listeners.

[width="100%",cols="100%",]
|===
a|
public PhaseId getPhaseId();



public void setPhaseId(PhaseId phaseId);

|===

If this property is set to PhaseId.ANY_PHASE
(which is the default), the event will be delivered at the end of the
phase in which it was enqueued.

To facilitate general management of event
listeners in JSF components, a _FacesEvent_ implementation class must
support the following methods:

[width="100%",cols="100%",]
|===
a|
public abstract boolean
isAppropriateListener(FacesListener listener);



public abstract void
processListener(FacesListener listener);

|===

The _isAppropriateListener()_ method returns
true if the specified _FacesListener_ is a relevant receiver of this
type of event. Typically, this will be implemented as a simple
“instanceof” check to ensure that the listener class implements the
_FacesListener_ subinterface that corresponds to this event class

The _processListener()_ method must call the
appropriate event processing method on the specified listener.
Typically, this will be implemented by casting the listener to the
corresponding _FacesListener_ subinterface and calling the appropriate
event processing method, passing this event instance as a parameter.

[width="100%",cols="100%",]
|===
|public void queue();
|===

The above convenience method calls the
_queueEvent()_ method of the source _UIComponent_ for this event,
passing this event as a parameter.

JSF includes two standard _FacesEvent_
subclasses, which are emitted by the corresponding standard
_UIComponent_ subclasses described in the following chapter.

 _ActionEvent—_ Emitted by a _UICommand_
component when the user activates the corresponding user interface
control (such as a clicking a button or a hyperlink).

 _ValueChangeEvent_ —Emitted by a _UIInput_
component (or appropriate subclass) when a new local value has been
created, and has passed all validations.

=== [[a1329]]Listener Classes

For each event type that may be emitted, a
corresponding listener interface must be created, which extends the
_javax.faces.event.FacesListener_ interface. The method signature(s)
defined by the listener interface must take a single parameter, an
instance of the event class for which this listener is being created. A
listener implementation class will implement one or more of these
listener interfaces, along with the event handling method(s) specified
by those interfaces. The event handling methods will be called during
event broadcast, one per event.

In conformance to the naming patterns defined
in the _JavaBeans Specification_ , listener interfaces have a class name
based on the class name of the event being listened to, but with the
word _Listener_ replacing the trailing _Event_ of the event class name
(thus, the listener for a _FooEvent_ would be a _FooListener_ ). It is
recommended that application event listener interfaces follow this
naming pattern as well.

Corresponding to the two standard event
classes described in the previous section, JSF defines two standard
event listener interfaces that may be implemented by application
classes:

 _ActionListener_ —a listener that is
interested in receiving _ActionEvent_ events.

 _ValueChangeListener_ —a listener that is
interested in receiving _ValueChangeEvent_ events.

=== [[a1335]]Phase Identifiers

As described in
link:JSF.html#a494[See Common Event Processing], event handling
occurs at the end of several phases of the request processing lifecycle.
In addition, a particular event must indicate, through the value it
returns from the _getPhaseId()_ method, the phase in which it wishes to
be delivered. This indication is done by returning an instance of
_javax.faces.event.PhaseId_ . The class defines a typesafe enumeration
of all the legal values that may be returned by _getPhaseId()_ . In
addition, a special value ( _PhaseId.ANY_PHASE_ ) may be returned to
indicate that this event wants to be delivered at the end of the phase
in which it was queued.

=== Listener Registration

A concrete _UIComponent_ subclass that emits
events of a particular type must include public methods to register and
deregister a listener implementation. [P1-start listener methods must
conform to javabeans naming] In order to be recognized by development
tools, these listener methods must follow the naming patterns defined in
the _JavaBeans Specification_ . [P1-end] For example, for a component
that emits _FooEvent_ events, to be received by listeners that implement
the _FooListener_ interface, the method signatures (on the component
class) must be:

[width="100%",cols="100%",]
|===
a|
public void addFooListener(FooListener
listener);



public FooListener[] getFooListeners();



public void removeFooListener(FooListener
listener);

|===

The application (or other components) may
register listener instances at any time, by calling the appropriate add
method. The set of listeners associated with a component is part of the
state information that JSF saves and restores. Therefore, listener
implementation classes must have a public zero-argument constructor, and
may implement _StateHolder_ (see link:JSF.html#a1138[See
StateHolder]) if they have internal state information that needs to be
saved and restored.

The _UICommand_ and _UIInput_ standard
component classes include listener registration and deregistration
methods for event listeners associated with the event types that they
emit. The _UIInput_ methods are also inherited by _UIInput_ subclasses,
including _UISelectBoolean_ , _UISelectMany_ , and _UISelectOne_ .

=== Event Queueing

During the processing being performed by any
phase of the request processing lifecycle, events may be created and
queued by calling the _queueEvent()_ method on the source _UIComponent_
instance, or by calling the _queue()_ method on the _FacesEvent_
instance itself. As described in link:JSF.html#a494[See Common
Event Processing], at the end of certain phases of the request
processing lifecycle, any queued events will be broadcast to interested
listeners in the order that the events were originally queued.

Deferring event broadcast until the end of a
request processing lifecycle phase ensures that the entire component
tree has been processed by that state, and that event listeners all see
the same consistent state of the entire tree, no matter when the event
was actually queued.

=== [[a1349]]Event Broadcasting

As described in
link:JSF.html#a494[See Common Event Processing], at the end of
each request processing lifecycle phase that may cause events to be
queued, the lifecycle management method of the _UIViewRoot_ component at
the root of the component tree will iterate over the queued events and
call the _broadcast()_ method on the source component instance to
actually notify the registered listeners. See the Javadocs of the
_broadcast()_ method for detailed functional requirements.

During event broadcasting, a listener
processing an event may:

Examine or modify the state of any component
in the component tree.

Add or remove components from the component
tree.

Add messages to be returned to the user, by
calling _addMessage_ on the _FacesContext_ instance for the current
request.

Queue one or more additional events, from the
same source component or a different one, for processing during the
current lifecycle phase.

Throw an _AbortProcessingException_ , to tell
the JSF implementation that no further broadcast of this event should
take place.

Call _renderResponse()_ on the _FacesContext_
instance for the current request. This tells the JSF implementation
that, when the current phase of the request processing lifecycle has
been completed, control should be transferred to the _Render Response_
phase.

Call _responseComplete()_ on the
_FacesContext_ instance for the current request. This tells the JSF
implementation that, when the current phase of the request processing
lifecycle has been completed, processing for this request should be
terminated (because the actual response content has been generated by
some other means).

=== [[a1359]]System Events

System Events are introduced in version 2 of
the specification and represent specific points in time for a JSF
application. _PhaseEvent_ s also represent specific points in time in a
JSF application, but the granularity they offer is not as precise as
System Events. For more on _PhaseEvent_ s, please see
link:JSF.html#a6626[See PhaseEvent].

=== [[a1361]]Event Classes

All system events extend from the base class
_SystemEvent_ . _SystemEvent_ has a similar API to _FacesEvent_ , but
the _source_ of the event is of type _Object_ (instead of _UIComponent_
), _SystemEvent_ has no _PhaseId_ property and _SystemEvent_ has no
_queue()_ method because _SystemEvent_ s are never queued. _SystemEvent_
shares _isAppropriateListener()_ _and processListener()_ with
_FacesEvent_ . __ For the specification of these methods see
_link:JSF.html#a1308[See Event Classes]_ .

System events that originate from or are
associated with specific component instances should extend from
_ComponentSystemEvent_ , which extends _SystemEvent_ and adds a
_getComponent()_ method, as specififed in
_link:JSF.html#a1308[See Event Classes]_ .

The specification defines the following
_SystemEvent_ subclasses, all in package _javax.faces.event_ . __

 _ExceptionQueuedEvent_ indicates a
non-expected _Exception_ has been thrown. Please see
link:JSF.html#a3253[See ExceptionHandler] for the normative
specification.

 _PostConstructApplicationEvent_ must be
published immediately after application startup. Please see
link:JSF.html#a6201[See Application Startup Behavior] for the
normative specification.

 _PreDestroyApplicationEvent_ must be
published as immediately before application shutdown. Please see
link:JSF.html#a6248[See Application Shutdown Behavior] for the
normative specification

 _PostKeepFlashEvent_ This event must be
published by a call to _Application.publishEvent()_ when a value is kept
in the flash.

 _PostPutFlashEvent_ This event must be
published by a call to _Application.publishEvent()_ when a value is
stored in the flash.

 _PreClearFlashEvent_ This event must be
published by a call to _Application.publishEvent()_ when a before the
flash is cleared.

 _PreRemoveFlashEvent_ This event must be
published by a call to _Application.publishEvent()_ when a value is
removed from the flash.

The specification defines the following
_ComponentSystemEvent_ classes, all in package _javax.faces.event_ .

 _InitialStateEvent_ must be published with a
direct call to _UIComponent.processEvent()_ , during the _apply()_
method of the class _javax.faces.webapp.vdl.ComponentHandler_ . Please
see the javadocs for the normative specification.

 _PostAddToViewEvent_ indicates that the
_source_ component has just been added to the view. Please see
link:JSF.html#a937[See Component Tree Manipulation] for a
reference to the normative specification.

 _PostConstructViewMapEvent_ indicates that
the _Map_ that is the view scope has just been created. Please see, the
UIViewRoot link:JSF.html#a2268[See Events] for a
reference to the normative specification.

PostRenderViewEvent indicates that the
UIViewRoot source component has just been rendered. Please see Section
2.2.6 “Render Response” for the normative specification.

PostRestoreStateEvent indicates that an
individual component instance has just had its state restored. Please
see the _UIViewRoot_ link:JSF.html#a2268[See Events]
for a reference to the normative specification.

PostValidateEvent indicates that an
individual component instance has just been validated. Please see the
_EditableValueHolder_ link:JSF.html#a1223[See Events] for the
normative specification.

 _PreDestroyViewMapEvent_ indicates that the
_Map_ that is the view scope is about to be destroyed. Please see, the
UIViewRoot link:JSF.html#a2230[See Properties] for the normative
specification.

 _PreRenderComponentEvent_ indicates that the
_source_ component is about to be rendered. Please see
link:JSF.html#a937[See Component Tree Manipulation] for a
reference to the normative specification.

 _PreRenderViewEvent_ indicates that the
_UIViewRoot_ source component is about to be rendered. Please see
link:JSF.html#a457[See Render Response] for the normative
specification.

PreValidateEvent indicates that an individual
component instance is about to be validated. Please see the
_EditableValueHolder_ link:JSF.html#a1223[See Events] for the
normative specification.

=== Listener Classes

Unlike application events, the creation of
new event types for system events does not require the creation of new
listener interfaces. All _SystemEvent_ types can be listened for by
listeners that implement _javax.faces.event.SystemEventListener_ .
Please see the javadocs for that class for the complete specification.

As a developer convenience, the listener
interface _ComponentSystemEventListener_ has been defined for those
cases when a _SystemEventListener_ is being attached to a specific
_UIComponent_ instance. _ComponentSystemEventListener_ lacks the
_isListenerForSource()_ method because it is implcictly defined by
virture of the listener being added to a specific component instance.

=== Programmatic Listener Registration

System events may be listened for at the
Application level, using _Application.subscribeToEvent()_ or at the
component level, by calling _subscribeToEvent()_ on a specific component
instance. The specification for _Application.subscribeToEvent()_ may be
found in _link:JSF.html#a3526[See System Event Methods]_ .

The following methods are defined on
_UIComponent_ to support per-component system events.

[width="100%",cols="100%",]
|===
a|
public void subscribeToEvent(Class<? extends
SystemEvent> eventClass, ComponentSystemEventListener
componentListener);

public void unsubscribeFromEvent(Class<?
extends SystemEvent> eventClass, ComponentSystemEventListener
componentListener);

|===

See the javadoc for _UIComponent_ for the
normative specification of these methods.

In addition to the above methods, the
_@ListenerFor_ and _@ListenersFor_ annotations allow components,
renderers, validators and converters to declare that they want to
register for system events. Please see the javadocs for those
annotations for the complete specification.

=== [[a1393]]Declarative Listener Registration

Page authors can subscribe to events using
the <f:event/> tag. This tag will allow the application developer to
specify the method to be called when the specifed event fires for the
component of which the tag is a child. The tag usage is as follows:

[width="100%",cols="100%",]
|===
a|
<h:inputText value="#\{myBean.text}">

 <f:event type="preRenderComponent"

 listener="#\{myBean.beforeTextRender}" />

</h:inputText>

|===

The _type_ attribute specifies the type of
event, and can be any of the specification-defined events or one of any
user-defined events, but must be a _ComponentSystemEvent_ , using either
the short-hand name for the event or the fully-qualified class name
(e.g., _com.foo.app.event.CustomEvent_ ). If the event can not be found,
a _FacesException_ listing the offending event type will be thrown.
Please see the VDLDocs for the _<f:event />_ tag for the normative
specification of the declarative event feature.

The method signature for the
_MethodExpression_ pointed to by the _listener_ attribute must match the
signature of
_javax.faces.event.ComponentSystemEventListener.processEvent()_ , which
is:

[width="100%",cols="100%",]
|===
|public void
processEvent(javax.faces.event.ComponentSystemEvent event) throws
AbortProcessingException.
|===



=== [[a1403]]Listener Registration By Annotation

The _ListenerFor_ and _ListenersFor_
annotations can be applied to components and rendererers. Classes tagged
with the _ListenerFor_ annotation are installed as listeners. The
_ListenersFor_ annotation is a container annotation tp specify multiple
_ListenerFor_ annotations for a single class. Please refer to the
Javadocs for the _ListenerFor_ and _ListenersFor classes for more
details._

=== Listener Registration By Application Configuration Resources

A _<system-event-listener>_ element, within
the _<application>_ element of an application configuration resource,
declares an application scoped listener and causes a call to
_Application.subscribeToEvent()_ .

=== Event Broadcasting

System events are broadcast immediately by
calls to _Application.publishEvent()_ Please see
link:JSF.html#a3526[See System Event Methods] for the normative
specification of _publishEvent()_ .

=== 

image:SF-17.png[image]

[[a1410]]Validation Model

This section describes the facilities
provided by JavaServer Faces for validating user input.

=== Overview

JSF supports a mechanism for registering zero
or more _validators_ on each _EditableValueHolder_ component in the
component tree. A validator’s purpose is to perform checks on the local
value of the component, during the _Process Validations_ phase of the
request processing lifecycle. In addition, a component may implement
internal checking in a _validate_ method that is part of the component
class.

=== [[a1414]]Validator Classes

A validator must implement the
_javax.faces.validator.Validator_ interface, which contains a
_validate()_ method signature.

[width="100%",cols="100%",]
|===
| _public void validate(FacesContext context,
UIComponent component, Object value);_
|===

General purpose validators may require
configuration values in order to define the precise check to be
performed. For example, a validator that enforces a maximum length might
wish to support a configurable length limit. Such configuration values
are typically implemented as JavaBeans component properties, and/or
constructor arguments, on the _Validator_ implementation class. In
addition, a validator may elect to use generic attributes of the
component being validated for configuration information.

JSF includes implementations of several
standard validators, as described in link:JSF.html#a1446[See
Standard Validator Implementations].

=== [[a1419]]Validation Registration

The _EditableValueHolder_ interface
(implemented by _UIInput_ ) includes an _addValidator_ method to
register an additional validator for this component, and a
_removeValidator_ method to remove an existing registration. In JSF 1.1
there was the ability to set a _MethodBinding_ that points to a method
that adheres to the _validate_ signature in the _Validator_ interface,
which will be called after the Validator instances added by calling
addValidator() have been invoked. In JSF 1.2, this has been replaced by
providing a new wrapper class that implements _Validator_ , and accepts
a _MethodExpression_ instance that points to the same method that the
_MethodBinding_ pointed to in JSF 1.1. Please see the javadocs for
_EditableValueHolder.setValidator()_ .

The application (or other components) may
register validator instances at any time, by calling the _addValidator_
method. The set of validators associated with a component is part of the
state information that JSF saves and restores. Validators that wish to
have configuration properties saved and restored must also implement
_StateHolder_ (see link:JSF.html#a1138[See StateHolder]).

In addition to validators which are
registered explicitly on the component, either through the Java API or
in the view markup, zero or more “default validators” can be declared in
the application configuration resources, which will be registered on all
_UIInput_ instances in the component tree unless explicitly disabled.
[P1-start-validator-reg]The default validators are appended after any
locally defined validators once the _EditableValueHolder_ is populated
and added to the component tree. A default validator must not be added
to a _UIInput_ if a validator having the same id is already present.

The typical way of registering a default
validator id is by declaring it in a configuration resource, as follows:

[width="100%",cols="100%",]
|===
a|
 _<faces-config>_

 < _application>_

 < _default-validators>_


_<validator-id>javax.faces.Bean</validator-id>_

</ _default-validators>_

 < _application/>_

 _</faces-config>_



|===

A default validator may also be registered
using the _isDefault_ attribute on the _@FacesValidator_ annotation on a
_Validator_ class, as specified in link:JSF.html#a6598[See
Requirements for scanning of classes for annotations].

The during application startup, the runtime
must cause any default validators declared either in the application
configuration resources, or via a _@FacesValidator_ annotation with
_isDefault_ set to _true_ to be added with a call to
_Application.addDefaultValidatorId()_ . This method is declared in
link:JSF.html#a3510[See Default Validator Ids].

Any configuration resource that declares a
list of default validators overrides any list provided in a previously
processed configuration resource. If an empty _<default-validators/>_
element is found in a configuration resource, the list of default
validators must be cleared.

In environments that include Bean Validation,
the following additional actions must be taken at startup time. If the
_javax.faces.validator.DISABLE_DEFAULT_BEAN_VALIDATOR_ _<context-param>_
exists and its value is _true_ , the following step must be skipped:

{empty}The runtime must guarantee that the
validator id _javax.faces.Bean_ is included in the result from a call to
_Application.getDefaultValidatorInfo()_ (see
link:JSF.html#a3510[See Default Validator Ids]), regardless of
any configuration found in the application configuration resources or
via the _@FacesValidator_ annotation.[P1-end]

=== Validation Processing

During the _Process Validations_ phase of the
request processing lifecycle (as described in
link:JSF.html#a438[See Process Validations]), the JSF
implementation will ensure that the _validate()_ method of each
registered _Validator_ , the method referenced by the _validator_
property (if any), and the _validate_ () method of the component itself,
is called for each _EditableValueHolder_ component in the component
tree, regardless of the validity state of any of the components in the
tree. The responsibilities of each _validate()_ method include:

Perform the check for which this validator
was registered.

If violation(s) of the correctness rules are
found, create a _FacesMessage_ instance describing the problem, and
create a _ValidatorException_ around it, and throw the
_ValidatorException_ . The _EditableValueHolder_ on which this
validation is being performed will catch this exception, set _valid_ to
_false_ for that instance, and cause the message to be added to the
_FacesContext_ .

In addition, a _validate()_ method may:

Examine or modify the state of any component
in the component tree.

Add or remove components from the component
tree.

Queue one or more events, from the same
component or a different one, for processing during the current
lifecycle phase.

The render-independent property _required_ is
a shorthand for the function of a “required” validator. If the value of
this property is true, there is an entry in the request payload
corresponding to this component, and the component has no value, the
component is marked invalid and a message is added to the _FacesContext_
instance. See link:JSF.html#a584[See Localized Application
Messages] for details on the message.

=== [[a1446]]Standard Validator Implementations

JavaServer Faces defines a standard suite of
_Validator_ implementations that perform a variety of commonly required
checks. In addition, component writers, application developers, and tool
providers will often define additional _Validator_ implementations that
may be used to support component-type-specific or application-specific
constraints. These implementations share the following common
characteristics:

Standard _Validators_ accept configuration
information as either parameters to the constructor that creates a new
instance of that _Validator_ , or as JavaBeans component properties on
the _Validator_ implementation class.

To support internationalization,
_FacesMessage_ instances should be created. The message identifiers for
such standard messages are also defined by manifest String constants in
the implementation classes. It is the user’s responsibility to ensure
the content of a _FacesMessage_ instance is properly localized, and
appropriate parameter substitution is performed, perhaps using
_java.text.MessageFormat_ .

See the javadocs for
_UIInput.validateValue()_ for further normative specification regarding
validation.

Concrete Validator implementations must
define a public static final String constant VALIDATOR_ID, whose value
is the standard identifier under which the JSF implementation must
register this instance (see below).

Please see link:JSF.html#a584[See
Localized Application Messages] for the list of message identifiers.

[P1-start standard validators] The following
standard _Validator_ implementations (in the _javax.faces.validator_
package) are provided:

 _DoubleRangeValidator_ —Checks the local
value of a component, which must be of any numeric type, against
specified maximum and/or minimum values. Standard identifier is
“javax.faces.DoubleRange”.

 _LengthValidator_ —Checks the length (i.e.
number of characters) of the local value of a component, which must be
of type _String_ , against maximum and/or minimum values. Standard
identifier is “javax.faces.Length”.

 _LongRangeValidator_ —Checks the local value
of a component, which must be of any numeric type convertible to _long_
, against maximum and/or minimum values. Standard identifier is
“javax.faces.LongRange”.

 _RegexValidator_ —Accepts a “pattern”
attribute that is interpreted as a regular expression from the
_java.util.regex_ package. The local value of the component is checked
fora match against this regular expression. Standard identifier is
“javax.faces.RegularExpression”

 _BeanValidator_ - The implementation must
ensure that this validator is only available when running in an
environment in which JSR-303 Beans Validation is available. Please see
the javadocs for _BeanValidator.validate()_ for the
specification.Standard identifier is “javax.faces.Bean”

RequiredValidator - Analogous to setting the
required attribute to true on the EditableValueHolder. Enforces that the
local value is not empty. Reuses the logic and error messages defined on
UIInput. The standard identifier for this validator is
"javax.faces.Required"

{empty} _MethodExpressionValidator_ —Wraps a
_MethodExpression_ and interprets it as pointing to a method that
performs validation. Any exception thrown when the expression is invoked
is wrapped in a _ValidatorException_ in similar fashion as the above
validators. [P1-end]

=== [[a1461]]Bean Validation Integration

If the implementation is running in a
container environment that requires Bean Validation, it must expose the
bean validation as described in this specification.

As stated in the specification goals of JSR
303, validation often gets spread out across the application, from user
interface components to persistent objects. Bean Validation strives to
avoid this duplication by defining a set of metadata that can be used to
express validation constraints that are sharable by any layer of the
application. Since its inception, JSF has supported a “field level
validation” approach. Rather than requiring the developer to define
validators for each input component (i.e., _EditableValueHolder_ ), the
BeanValidator can be automatically applied to all fields on a page so
that the work of enforcing the constraints can be delegated to the Bean
Validation provider.

=== [[a1464]]Bean Validator Activation

[P1-BeanValidationIntegration]If Bean
Validation is present in the runtime environment, the system must ensure
that the standard validator with validator-id _javax.faces.Bean_ is
added with a call to _Application.addDefaultValidatorId()_ .[P1-end] See
link:JSF.html#a1446[See Standard Validator Implementations] for
the description of the standard _BeanValidator_ , and
link:JSF.html#a5828[See <f:validateBean>] for the Facelet tag
that exposes this validator to the page author. This ensures Bean
Validation will be called for every field in the application.

If Bean Validation is present, and the
_javax.faces.VALIDATE_EMPTY_FIELDS_ _<context-param>_ is not explicitly
set to _false_ , JSF will validate _null_ and empty fields so that the
_@NotNull_ and _@NotEmpty_ constraints from Bean Validation can be
leveraged. The next section describes how the reference to the Bean
Validation ValidatorFactory is obtained by that validator.

=== [[a1467]]Obtaining a ValidatorFactory

The Bean Validation ValidatorFactory is the
main entry point into Bean Validation and is responsible for creating
Validator instances. [P1-start-validatoryfactory]A ValidatorFactory is
retrieved using the following algorithm:

If the servlet context contains a
ValidatorFactory instance under the attribute named
javax.faces.validator.beanValidator.ValidatorFactory, this instance is
used by JSF to acquire Validator instances (specifically in the
BeanValidator). This key should be defined in the constant named
VALIDATOR_FACTORY_KEY on BeanValidator.

If the servlet context does not contain such
an entry, JSF looks for a Bean Validation provider in the classpath. If
present, the standard Bean Validation bootstrap strategy is used. If not
present, Bean Validation integration is disabled. If the BeanValidator
is used an no ValidatorFactory can be retrieved, a FacesException is
raised. The standard Bean Validation bootstrap procedure is shown here:

[width="100%",cols="100%",]
|===
|ValidatorFactory validatorFactory =
Validation.buildDefaultValidatorFactory();
|===

{empty}Once instantiated, the result can be
stored in the servlet context attribute mentioned as a means of caching
the result. If JSF is running in an EE6 environment, Bean Validation
will be available, as defined by the EE6 specification, and thus
activated in JSF. The EE container will be responsible for making the
ValidatorFactory available as an attribute in the ServletContext as
mentioned above.[P1-end]

=== Class-Level Validation

JSF conversion and validation as described in
this chapter operates on the principle that all conversion and
validation is performed before values are pushed into the model. This
principle allows one to safely assume that if a value is pushed into the
model, it is of the proper type and has been validated. This validation
is done on a “field level” basis, as mentioned in
link:JSF.html#a1461[See Bean Validation Integration]. This
approach poses challenges for higher level validation that needs to take
the value of several fields together into account to decide if they are
valid or not. For example, consider the common case of a user account
creation page with two fields for the password. The page can only be
considered valid if both password fields are themselves individually
valid based on the specified password constraints and also are both the
same value. JSF provides for this case by providing a facility for
performing Class-Level Validation using Bean Validation. Please see the
VDLDoc for the _<f:validateWholeBean />_ tag for the normative
specification of this feature as well as a usage example showing the
password validation scenario.

=== Localization of Bean Validation Messages

To ensure proper localization of the
messages, JSF should provide a custom BeanValidation MessageInterpolator
resolving the Locale according to JSF defaults and delegating to the
default MessageInterpolator as defined in
ValidationFactory.getMessageInterpolator(). A possible implementation is
shown here:

[width="100%",cols="100%",]
|===
a|
public class JsfMessageInterpolator
implements MessageInterpolator \{



private final MessageInterpolator delegate;



public
JsfMessageInterpolator(MessageInterpolator delegate) \{

 this.delegate = delegate;

 }



 public String interpolate(String message,
ConstraintDescriptor constraintDescriptor,Object value) \{

 Locale locale =
FacesContext.getCurrentInstance().getViewRoot().

getLocale();

return this.delegate.interpolate(

message, constraintDescriptor, value, locale
);

 }



 public String interpolate(String message,
ConstraintDescriptor constraintDescriptor, Object value, Locale locale)
\{

 return this.delegate.interpolate(message,
constraintDescriptor, value, locale);

}

}



|===

Once a ValidatorFactory is obtained, as
described in link:JSF.html#a1467[See Obtaining a
ValidatorFactory], JSF receives a Validator instance by providing the
custom message interpolator to the validator state.

[width="100%",cols="100%",]
|===
a|
//could be cached

MessageInterpolator jsfMessageInterpolator =
new JsfMessageInterpolator(

validatorFactory.getMessageInterpolator() );



//...



Validator validator = validatorFactory

 .usingContext()

 .messageInterpolator(jsfMessageInterpolator)

 .getValidator();



|===

The local value is then passed to the
Validator.validateValue() method to check for constraint violations.
Since Bean Validation defines a strategy for localized message
reporting, the BeanValidator does not need to concern itself with
producing the validation message. Instead, the BeanValidator should
accept the interpolated message returned from Bean Validation API, which
is accessed via the method getInterpolatedMessage() on the
ContraintFailure class, and use it as the replacement value for the
first numbered placeholder for the key
javax.faces.validator.BeanValidator.MESSAGE (i.e., \{0}). To encourage
use of the Bean Validation message facility, the default message format
string for the BeanValidator message key must be a single placeholder,
as shown here:

[width="100%",cols="100%",]
|===
|javax.faces.validator.BeanValidator.MESSAGE=\{0}
|===

Putting the Bean Validation message
resolution in full control of producing the displayed message is the
recommended approach. However, to allow the developer to align the
messages generated by the BeanValidator with existing JSF 1.2
validators, the developer may choose to override this message key in an
application resource bundle and reference the component label, which
replaces the second numbered placeholder (i.e., \{1}).

[width="100%",cols="100%",]
|===
|javax.faces.validator.BeanValidator.MESSAGE=\{1}:
\{0}
|===

This approach is useful if you are already
using localized labels for your input components and are displaying the
messages above the form, rather than adjacent to the input.

=== 

image:SF-17.png[image]

[[a1515]]Composite User Interface Components

=== Non-normative Background

To aid implementors in providing a spec
compliant runtime for composite components, this section provides a
non-normative background to motivate the discussion of the composite
component feature. The composite component feature enables developers to
write real, reusable, JSF UI components without any Java code or
configuration XML.

=== [[a1518]]What does it mean to be a JSF User Interface component?

JSF is a component based framework, and JSF
UI components are the main point of JSF. But what is a JSF UI component,
really? Conceptually, a JSF UI Component is a software artifact that
represents a reusable, self contained piece of a user interface. A very
narrow definition for “JSF UI Component” is imposed at runtime. This
definition can be summarized as

A JSF UI Component is represented at runtime
by an instance of a Java class that includes
_javax.faces.component.UIComponent_ as an ancestor in its inheritance
hierarchy.

It is easy to write a class that adheres to
this definition, but in practice, component authors need to do more than
just this in order to get the most from JSF and to conform to user’s
expectations of what a JSF UI Component is. For example, users expect a
JSF UI Component can do some or all of the following:

be exposed to the page-author via a markup
tag with sensible attributes

emit events (such a _ValueChangeEvent_ or
_ActionEvent_ )

allow attaching listeners

allow attaching a _Converter_ and/or
_Validator_ (s)

render itself to the user-agent, with full
support for styles, localization and accessibility

support delegated rendering to allow for
client device independence

read values sent from the user-agent and
correctly adapt them to the faces lifecycle

correctly handle saving and restoring its
state across multiple requests from the user-agent

Another important dimension to consider
regarding UI components is the context in which the developer interacts
with the component. There are generally two such contexts.

In the context of a markup view, such as a
JSP or Facelet view. In this context the developer interacts with the UI
component using a markup element, setting attributes on that element,
and nesting child elements within that component markup element.

In the context of code, such as a listener, a
managed-bean, or other programming language context. In this context,
the developer is writing JavaCode that is either passed the UI component
as an argument, or obtains a reference to the UI component in some other
way.

=== How does one make a custom JSF User Interface component (JSF 1.2 and earlier)?

To satisfy a user’s expectations for a JSF UI
component, the component author must adhere to one of the following best
practices.

extend the custom component class from an
existing subclass of _UIComponent_ that most closely represents the
meaning and behavior of the piece of the UI you are encapsulating in the
component.

extend the custom component class directly
from _UIComponentBase_ and implement the appropriate “behavioral
interface”(s) that most closely represents the meaning and behavior of
the piece of the UI you are encapsulating in the component. See
link:JSF.html#a1088[See Component Behavioral Interfaces] for
more.

Note that the first best practice includes
the second one “for free” since the stock _UIComponent_ subclasses
already implement the appropriate behavioral interfaces.

When following either best practice, the JSF
UI component developer must follow several steps to make the component
available for use in markup pages or in code, including but not
necessarily limited to

Make entries in a _faces-config.xml_ file,
linking the component class to its _component-type_ , which enables the
_Application.createComponent()_ method to create instances of the
component.

Make entries in a _faces-config.xml_ file to
declare a _Renderer_ that provides client-device independence.

Provide a JSP or Facelet tag handler that
allows the page author to build UIs that include the component, and to
customize each instance of the component with listeners, properties and
model associations. This includes making the association between the
_Renderer_ and the _UIComponent_ .

Provide a _Renderer_ that provides client
device independency for the component

Make entries in a _faces-config.xml_ file
that links the _Renderer_ and its Java class.

These steps are complex, yet the components
one creates by following them can be very flexible and powerful. By
making some simplifying assumptions, it is possible to allow the
creation of components that are just as powerful but require far less
complexity to develop. This is the whole point of composite components:
to enable developers to write real, reusable, JSF UI components without
any Java code or configuration XML.

=== [[a1545]]How does one make a composite component?

The composite component feature builds on two
features introduced in JSF 2.0: resources
(link:JSF.html#a746[See Resource Handling]) and Facelets
(link:JSF.html#a5476[See Facelets and its use in Web
Applications]”). Briefly, a composite component is any Facelet markup
file that resides inside of a resource library. For example, if a
Facelet markup file named _loginPanel.xhtml_ resides inside of a
resource library called _ezcomp_ , then page authors can use this
component by declaring the xml namespace
_xmlns:ez="http://java.sun.com/jsf/composite/ezcomp"_ and including the
tag _<ez:loginPanel />_ in their pages. Naturally, it is possible for a
composite component author to declare an alternate XML namespace for
their composite components, but doing so is optional.

Any valid Facelet markup is valid for use
inside of a composite component, including the templating features
specified in
link:JSF.html#a6043[See Facelet
Templating Tag Library]. In addition, the tag library specified in
link:JSF.html#a6045[See Composite Component Tag Library] must be
used to declare the metadata for the composite component. Future
versions of the JSF specification may relax this requirement, but for
now at least the _<composite:interface>_ and
_<composite:implementation>_ sections are required when creating a
composite component.

=== [[a1548]]A simple composite component example

Create the page that uses the composite
component, _index.xhtml_ .

[width="100%",cols="100%",]
|===
a|
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0
Transitional//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml"

 xmlns:h="http://java.sun.com/jsf/html"

 xmlns:f="http://java.sun.com/jsf/core"


xmlns:ez="http://java.sun.com/jsf/composite/ezcomp">

<h:head>

<title>A simple example of EZComp</title>

</h:head>



<h:body>



<h:form>



 <ez:loginPanel id="loginPanel">



 <f:actionListener for="loginEvent"

 binding="#\{bean.loginEventListener}" />



 </ez:loginPanel>



</h:form>



</h:body>



</html>

|===

The only thing special about this page is the
_ez_ namespace declaration and the inclusion of the _<ez:loginPanel />_
tag on the page. The occurrence of the string
“http://java.sun.com/jsf/composite/” in a Facelet XML namespace
declaration means that whatever follows that last “ _/_ ” is taken to be
the name of a resource library. For any usage of this namespace in the
page, such as _<ez:loginPanel />_ , a Facelet markup file with the
corresponding name is loaded and taken to be the composite component, in
this case the file _loginPanel.xhtml_ . The implementation requirements
for this and other Facelet features related to composite components are
specified in link:JSF.html#a5661[See Requirements specific to
composite components].

Create the composite component markup page.
In this case, _loginPanel.xhtml_ resides in the _./resources/ezcomp_
directory relative to the _index.xhtml_ file.

[width="100%",cols="100%",]
|===
a|
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0
Transitional//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml"

 xmlns:h="http://java.sun.com/jsf/html"

 xmlns:f="http://java.sun.com/jsf/core"

 xmlns:ui="http://java.sun.com/jsf/facelets"


xmlns:composite="http://java.sun.com/jsf/composite">

<head>



<title>Not present in rendered output</title>



</head>



<body>



<composite:interface>



 <composite:actionSource name="loginEvent" />



</composite:interface>



<composite:implementation>



 <p>Username: <h:inputText id="usernameInput"
/></p>



 <p>Password: <h:inputSecret
id="passwordInput" /></p>



 <p><h:commandButton id="loginEvent"
value="login"/>



</composite:implementation>



</body>



</html>

|===

The _<composite:interface>_ section declares
the public interface that users of this component need to understand. In
this case, the component declares that it contains an implementation of
_ActionSource2_ (see link:JSF.html#a1120[See ActionSource2]),
and therefore anything one can do with an _ActionSource2_ in a Facelet
markup page you one do with the composite component. (See
link:JSF.html#a1088[See Component Behavioral Interfaces] for
more on _ActionSource2_ and other behavioral interfaces). The
_<composite:implementation>_ section defines the implementation of this
composite component.

=== Walk through of the run-time for the simple composite component example

This section gives a non-normative traversal
of the composite component feature using the previous example as a
guide. Please refer to the javadocs for the normative specification for
each method mentioned below. Any text in _italics_ is a term defined in
link:JSF.html#a1619[See Composite Component Terms].

The user-agent requests the _index.html_ from
link:JSF.html#a1548[See A simple composite component example].
This page contains the
‘xmlns:ez="http://java.sun.com/jsf/composite/ezcomp"‘ declaration and an
occurrence of the _<ez:loginPanel>_ tag. Because this page contains a
usage of a composite component, it is called a _using page_ for
discussion.

The runtime notices the use of an xml
namespace beginning with “http://java.sun.com/jsf/composite/”. Takes the
substring of the namespace after the last “/”, exclusive, and looks for
a resource library with the name “ _ezcomp_ ” by calling
_ResourceHandler.libraryExists()_ .

The runtime encounters the _<ez:loginPanel>_
component in the _using page_ . This causes
_Application.createComponent(FacesContext, Resource)_ to be called. This
method instantiates the _top level component_ but does not populate it
with children. Pay careful attention to the javadocs for this method.
Depending on the circumstances, the _top level component_ instance can
come from a developer supplied Java Class, a Script, or an
implementation specific java class. This method calls
_ViewDeclarationLanguage.getComponentMetadata(FacesContext, Resource)_ ,
which obtains the _composite component BeanInfo_ (and therefore also the
_composite component BeanDescriptor_ ) that exposes the _composite
component metadata_ . The _composite component metadata_ also includes
any _attached object targets_ exposed by the _composite component
author_ . One thing that _Application.createComponent(FacesContext,
Resource)_ does to the component before returning it is set the
component’s renderer type to be _javax.faces.Composite_ . This is
important during rendering.

Again,
_Application.createComponent(FacesContext, Resource)_ does not populate
the _top level component_ with children. Subsequent processing done as
the runtime traverses the rest of the page takes care of that. One very
important aspect of that subsequent processing is ensuring that all of
the _UIComponent_ children in the _defining page_ are placed in a facet
underneath the _top level component_ . The name of that facet is given
by the _UIComponent.COMPOSITE_FACET_NAME_ constant.

After the children of the _composite
component tag_ in the _using page_ have been processed by the VDL
implementation, the VDL implementation must call
_VDLUtils.retargetAttachedObjects()_ . This method examines the
_composite component metadata_ and retargets any attached objects from
the _using page_ to their approriate _inner component_ targets.

Because the renderer type of the composite
component was set to _javax.faces.Composite_ , the _composite component
renderer_ is invoked to render the composite component.

=== [[a1619]]Composite Component Terms

The following terms are commonly used to
describe the composite component feature.



Attached Object

Any artifact that can be attached to a
_UIComponent_ (composite or otherwise). Usually, this means a
_Converter_ , _Validator_ , _ActionListener_ , or _ValueChangeListener_
.

Attached Object Target

Part of the _composite component metadata_
that allows the _composite component author_ to expose the semantics of
an inner component to the _using page author_ without exposing the
rendering or implementation details of the inner component.

Composite Component

A tree of _UIComponent_ instances, rooted at
a _top level component_ , that can be thought of and used as a single
component in a view. The component hierarchy of this subtree is
described in the _composite component defining page_ .

Composite Component Author

The individual or role creating the
_composite component_ . This usually involves authoring the _composite
component defining page_ .

Composite Component _BeanDescriptor_

A constituent element of the _composite
component metadata_ . This version of the spec uses the JavaBeans API to
expose the component metadata for the composite component. Future
versions of the spec may use a different API to expose the component
metadata.

Composite Component _BeanInfo_

The main element of the _composite component_
_metadata_ .

Composite Component Declaration

The section of markup within the _composite
component defining page_ that includes the _<composite:interface>_
section and its children.

Composite Component Definition

The section of markup within the _composite
component defining page_ that includes the _<composite:implementation>_
section and its children.

Composite Component Library

A resource library that contains a _defining
page_ for each _composite component_ that the _composite component
author_ wishes to expose to the _using page author_ .

Composite Component Metadata

Any data about the _composite component_ .
The normative specification for what must be in the _composite component
metadata_ is in the javadocs for
_ViewDeclarationLanguage.getComponentMetadata()_ .

Composite Component Renderer

A new renderer in the _HTML_BASIC_ render kit
that knows how to render a _composite component_ .

Composite Component Tag

The tag in the _using page_ that references a
_composite component_ declared and defined in a _defining page_ .

Defining page

The markup page, usually Facelets markup,
that contains the _composite component declaration_ and _composite
component definition_ .

Inner Component

Any _UIComponent_ inside of the _defining
page_ or a page that is referenced from the _defining page_ .

Top level component

The _UIComponent_ instance in the tree that
is the parent of all _UIComponent_ instances within the _defining page_
and any pages used by that _defining page_ .

Using Page

The VDL page in which a _composite component
tag_ is used.

Using Page Author

The individual or role that creates pages
that use the _composite component_ .

=== Normative Requirements

This section contains the normative
requirements for the composite component runtime, or pointers to other
parts of the specification that articulate those requirements in the
appropriate context.

=== References to Composite Component Requirements in Context

Section

Feature

{empty}link:JSF.html#a2830[See
Implicit Object ELResolver for Facelets and Programmatic Access]

Ability for the _composite component author_
to refer to the _top level component_ from an EL expression, such as
_#\{cc.children[3]}_ .

{empty}link:JSF.html#a2908[See
Composite Component Attributes ELResolver]

Ability for the _composite component author_
to refer to attributes declared on the _composite component tag_ using
EL expressions such as _#\{cc.attrs.usernameLabel}_

{empty}link:JSF.html#a3468[See Object
Factories]

Methods called by the VDL page to create a
new instance of a _top level component_ for eventual inclusion in the
view

{empty}link:JSF.html#a5661[See
Requirements specific to composite components]

Requirements of the Facelet implementation
relating to Facelets.

{empty}link:JSF.html#a6045[See
Composite Component Tag Library]

Tag handlers for the _composite_ tag library
__

=== [[a1671]]Composite Component Metadata

In the current version of the specification,
only composite _UIComponent_ s must have component metadata. It is
possible that future versions of the specification will broaden this
requirement so that all _UIComponent_ s must have metadata.

This section describes the implementation of
the _composite component metadata_ that is returned from the method
_ViewDeclarationLanguage.getComponentMetadata()_ . This method is
formally declared in link:JSF.html#a4046[See
ViewDeclarationLanguage.getComponentMetadata()], but for reference its
signature is repeated here.

[width="100%",cols="100%",]
|===
|public BeanInfo
getComponentMetadata(FacesContext context, Resource componentResource)
|===

The specification requires that this method
is called from _Application.createComponent(FacesContext context,
Resource componentResource)_ . See the javadocs for that method for
actions that must be taken based on the composite component metadata
returned from _getComponentMetadata()_ .

The default implementation of this method
must support authoring the component metadata using tags placed inside
of a _<composite:interface />_ element found on a _defining page_ . This
element is specified in the Facelets taglibrary docs.

Composite component metadata currently
consists of the following information:

The _composite component BeanInfo_ , returned
from this method.

The _Resource_ from which the composite
component was created.

The _composite component BeanDescriptor_ .

This _BeanDescriptor_ must be returned when
_getBeanDescriptor()_ is called on the composite component _BeanInfo_ .

The composite component _BeanDescriptor_
exposes the following information.

The “name” attributes of the
_<composite:interface/ >_ element is exposed using the corresponding
method on the composite component _BeanDescriptor_ . If _ProjectStage_
is _Development_ , The “displayName”, “shortDescription”, “expert”,
“hidden”, and “preferred” attributes of the _<composite:interface/ >_
element are exposed using the corresponding methods on the composite
component _BeanDescriptor_ . Any additional attributes on
_<composite:interface/ >_ are exposed as attributes accessible from the
_getValue()_ and _attributeNames()_ methods on _BeanDescriptor_
(inherited from _FeatureDescriptor_ ). The return type from _getValue()_
must be a _javax.el.ValueExpression_ for such attributes.

The list of exposed _AttachedObjectTarget_ s
to which the _page author_ can attach things such as listeners,
converters, or validators.

The VDL implementation must populate the
composite component metadata with a _List<AttachedObjectTarget>_ that
includes all of the inner components exposed by the composite component
author for use by the page author.

This List must be exposed in the value set of
the composite component _BeanDescriptor_ under the key
_AttachedObjectTarget.ATTACHED_OBJECT_TARGETS_KEY_ .

For example, if the defining page has

[width="100%",cols="100%",]
|===
a|
<composite:interface>

 <composite:editableValueHolder
name=”username” />

 <composite:actionSource name=”loginEvent” />

 <composite:actionSource name=”allEvents”

 targets=”loginEvent cancelEvent” />

<composite:interface>

|===

The list of attached object targets would
consist of instances of implementations of the following interfaces from
the package _javax.faces.webapp.vdl_ .

=== EditableValueHolderAttachedObjectTarget

ActionSource2AttachedObjectTarget

ActionSource2AttachedObjectTarget

BehaviorHolderAttachedObjectTarget

A _ValueExpression_ that evaluates to the
component type of the composite component. By default this is "
_javax.faces.NamingContainer_ " but the composite component page author
can change this, or provide a Java or script-based _UIComponent_
implementation that is required to implement _NamingContainer_ .

This _ValueExpression_ must be exposed in the
value set of the composite component _BeanDescriptor_ under the key
_UIComponent.COMPOSITE_COMPONENT_TYPE_KEY_ .

A _Map<String, PropertyDescriptor>_
representing the facets declared by the composite component author for
use by the page author.

This _Map_ must be exposed in the value set
of the composite component BeanDescriptor under the key
_UIComponent.FACETS_KEY_ .

Any attributes declared by the composite
component author using _<composite:attribute/ >_ elements must be
exposed in the array of _PropertyDescriptor_ s returned from
_getPropertyDescriptors()_ on the composite component _BeanInfo_ .

For each such attribute, for any _String_ or
_boolean_ valued _JavaBeans_ properties on the interface
_PropertyDescriptor_ (and its superinterfaces) that are also given as
attributes on a _<composite:attribute/ >_ element, those properties must
be exposed as properties on the _PropertyDescriptor_ for that markup
element. Any additional attributes on _<composite:attribute/ >_ are
exposed as attributes accessible from the _getValue()_ and
_attributeNames()_ methods on _PropertyDescriptor_ . The return type
from getValue() must be a _ValueExpression_ with the exception of the
_getValue(“type”)_ . The return type from _getValue(“type”)_ must be
_Class_ . If the value specified for the _type_ attribute of
_<cc:attribute/>_ cannot be converted to an actual _Class_ , a
_TagAttributeException_ must be thrown, including the _Tag_ and
_TagAttribute_ instances in the constructor.

The _composite component BeanDescriptor_ must
return a _Collection<String>_ when its _getValue()_ method is called
with an argument equal to the value of the symbolic constant
_UIComponent.ATTRS_WITH_DECLARED_DEFAULT_VALUES_ . The
_Collection<String>_ must contain the names of any
_<composite:attribute>_ elements for which the _default_ attribute was
specified, or _null_ if none of the attributes have been given a default
value.

=== 

image:SF-17.png[image]

[[a1707]]Component Behavior Model

This section describes the facilities for
adding Behavior attached objects to JavaServer Faces components.

=== Overview

JSF supports a mechanism for enhancing
components with additional behaviors that are not explicitly defined by
the component author.

At the root of the behavior model is he
Behavior interface. This interface serves as a supertype for additional
behavior contracts. The ClientBehavior interface extends the Behavior
interface by providing a contract for defining reusable scripts that can
be attached to any component that implements the ClientBehaviorHolder
interface. The ClientBehaviorHolder interface defines the set of attach
points, or "events", to which a ClientBehavior may be attached. For
example, an "AlertBehavior" implementation might display a JavaScript
alert when attached to a component and activated by the end user.

While client behaviors typically add
client-side capabilities, they are not limited to client. Client
behaviors can also participate in the JSF request processing lifecycle.
JSF's AjaxBehavior is a good example of such a cross-tier behavior. The
AjaxBehavior both triggers an Ajax request from the client and also
delivers AjaxBehaviorEvents to listeners on the server.

The standard HTML components provided by JSF
are all client behavior-ready. That is, all of the standard HTML
components implement the ClientBehaviorHolder interface and allow client
behaviors to be attached to well defined events. .

=== Behavior Interface

The Behavior interface is the root of the
component behavior model. It defines a single method to enable generic
behavior event delivery.

[width="100%",cols="100%",]
|===
a|
public void broadcast(BehaviorEvent event)

 throws AbortProcessingException

|===

This method is called by UIComponent
implementations to re-broadcast behavior events that were queued by by
calling UIComponent.queueEvent.

=== BehaviorBase

The BehaviorBase abstract class implements
the broadcast method from the Behavior interface. BehaviorBase also
implements the PartialStateHolder interface (see
link:JSF.html#a1159[See PartialStateHolder]). It
also provides behavior event listener registration methods.

[width="100%",cols="100%",]
|===
a|
public void broadcast(BehaviorEvent event)

 throws AbortProcessingException

|===

This method delivers the BehaviorEvent to
listeners that were registered via addBehaviorListener.

The following methods are provided for add
and removing BehaviorListeners..

[width="100%",cols="100%",]
|===
|protected void
addBehaviorListener(BehaviorListener listener)
|===

[width="100%",cols="100%",]
|===
|protected void
removeBehaviorListener(BehaviorListener listener);
|===

=== The Client Behavior Contract

The _ClientBehavior_ interface extends the
_Behavior_ interface and lays the foundation on which behavior authors
can define custom script producing behaviors. The logic for producing
these scripts is defined in the _getScript_ () method. __

[width="100%",cols="100%",]
|===
|public String getScript(BehaviorContext
behaviorContext)
|===

This method returns a String that is an
executable script that can be attached to a client side event handler.
The BehaviorContext argument contains information that may be useful for
getScript implementations.

In addition to client side functionality,
client behaviors can also post back to the server and participate in the
request processing lifecycle. ..

[width="100%",cols="100%",]
|===
|public void decode(FacesContext
context,UIComponent component)
|===

This method can perform request decoding and
queue server side events..].

[width="100%",cols="100%",]
|===
|public Set<ClientBehaviorHint> getHints()
|===

This method provides information about the
client behavior implementation that may be useful to components and
renderers that interact with the client behavior.

Refer to the javadocs for these methods for
more details.

=== ClientBehaviorHolder

Components that support client behaviors must
implement the ClientBehaviorHolder interface. Refer to
link:JSF.html#a1239[See ClientBehaviorHolder] for
more details.

=== ClientBehaviorRenderer

Client behaviors may implement script
generation and decoding in a client behavior class or delegate to a
ClientBehaviorRenderer. Refer to
link:JSF.html#a4264[See ClientBehaviorRenderer]
for more specifics.

=== ClientBehaviorContext

The specification provides a
ClientBehaviorContext that contains information that may be used at
script rendering time. Specifically it includes:

FacesContext

UIComponent that the current behavior is
attached to

The name of the event that the behavior is
associated with

The identifier of the source - this may
correspond to the identifier of the source of the behavior

A collection of parameters that submitting
behaviors should include when posting back to the server

The ClientBehaviorContext is created with the
use of this static method:

[width="100%",cols="100%",]
|===
|public static ClientBehaviorContext
createClientBehaviorContext(FacesContext context,UIComponent
component,String eventName,tring
sourceId,Collection<ClientBehaviorContext.Parameter> parameters)
|===

This method must throw a NullPointerException
if context, component or eventName is null.

=== ClientBehaviorHint

The ClientBehaviorHint enum is used to convey
information about the client behavior implementation. Currently, only
one hint is provided.

[width="100%",cols="100%",]
|===
|SUBMITTING
|===

This hint indicates that a client behavior
implementation posts back to the server.

=== ClientBehaviorBase

 _ClientBehaviorBase_ is an extension of
_BehaviorBase_ that implements the _ClientBehavior_ interface. It It is
a convenience class that contains default implementations for the
methods in _ClientBehavior_ plus additional methods::

[width="100%",cols="100%",]
|===
|public String getScript(BehaviorContext
behaviorContext)
|===

The default implementation calls getRenderer
to retrieve the _ClientBehaviorRenderer_ . If a _ClientBehaviorRenderer_
is found, it is used to obtain the script. If no
_ClientBehaviorRenderer_ is found, this method returns null.

[width="100%",cols="100%",]
|===
|public void decode(FacesContext
context,UIComponent component)
|===

The default implementation calls getRenderer
to retrieve the _ClientBehaviorRenderer_ . If a _ClientBehaviorRenderer_
is found, it is used to perform decoding. If no _ClientBehaviorRenderer_
is found, no decoding is performed.

[width="100%",cols="100%",]
|===
|public Set<ClientBehaviorHint> getHints()
|===

The default implementation returns an empty
set

[width="100%",cols="100%",]
|===
|public String getRendererType();
|===

This method identifies the
_ClientBehaviorRenderer_ type. By default, no _ClientBehaviorRenderer_
type is provided. Subclasses should either override this method to
return a valid type or override the getScript and decode methods if a
_ClientBehaviorRenderer_ is not available..

[width="100%",cols="100%",]
|===
|protected ClientBehaviorRenderer
getRenderer(FacesContext context);
|===

This method returns the
_ClientBehaviorRenderer_ instance that is associated with this
ClientBehavior. It uses the renderer type returned from get
_RendererType()_ to look up the renderer on the RenderKit using
_RenderKit.getClientBehaviorRenderer._

=== Behavior Event / Listener Model

The behavior event / listener model is an
extension of the JSF event / listener model as described in
link:JSF.html#a1300[See Event and Listener Model].
BehaviorHolder components are responsible for broadcasting
BehaviorEvents to behaviors.

=== Event Classes

Behaviors can broadcast events in the same
way that UIComponents can broadcast events. At the root of the behavior
event hierarchy is BehaviorEvent that extends
_javax.faces.event.FacesEvent_ . All events that are broadcast by JSF
behaviors must extend the _javax.faces.event.BehaviorEvent_ abstract
base class. The parameter list for the constructor(s) of this event
class must include a _UIComponent_ , which identifies the component from
which the event will be broadcast to interested listeners, and a
_Behavior_ which identifies the behavior associated with the component.
The source component can be retrieved from the event object itself by
calling _getComponent_ and the behavior can be retrieved by calling
_getBehavior_ . Additional constructor parameters and/or properties on
the event class can be used to relay additional information about the
event.

In conformance to the naming patterns defined
in the _JavaBeans Specification_ , event classes typically have a class
name that ends with _Event_ . The following method is available to
determine the Behavior for the event (in addition to the other methods
inherited from _javax.faces.event.FacesEvent:_

[width="100%",cols="100%",]
|===
|public Behavior getBehavior()
|===

=== Listener Classes

For each event type that may be emitted, a
corresponding listener interface must be created, which extends the
_javax.faces.event.BehaviorListener_ interface. _BehaviorListener_
extends from _javax.faces.event.FacesListener._ The method signature(s)
defined by the listener interface must take a single parameter, an
instance of the event class for which this listener is being created. A
listener implementation class will implement one or more of these
listener interfaces, along with the event handling method(s) specified
by those interfaces. The event handling methods will be called during
event broadcast, one per event.

In conformance to the naming patterns defined
in the _JavaBeans Specification_ , listener interfaces have a class name
based on the class name of the event being listened to, but with the
word _Listener_ replacing the trailing _Event_ of the event class name
(thus, the listener for a _FooEvent_ would be a _FooListener_ ). It is
recommended that application event listener interfaces follow this
naming pattern as well.

=== [[a1776]]Listener Registration

 _BehaviorListener_ registration follows the
same conventions as outlined in link:JSF.html#a1776[See Listener
Registration].

=== Ajax Behavior

=== AjaxBehavior

{empty}The specification defines a single
concrete _ClientBehavior_ implementation:
_javax.faces.component.behavior.AjaxBehavior_ . This class extends
_javax.faces.component.behavior.ClientBehaviorBase_ . The presence of
this behavior on a component causes the rendering of JavaScript that
will produce an Ajax request to the server using the JavaScript API
outlined in Section “JavaScript API”. This behavior may also broadcast
_javax.faces.event.AjaxBehaviorEvents_ to registered
_javax.faces.event.AjaxBehaviorListener_ implementations. Refer to the
javadocs for more details about _AjaxBehavior._
[P1-start-ajaxbehavior]This behavior must define the behavior id
“javax.faces.behavior.Ajax”. The renderer type must also be
“javax.faces.behavior.Ajax”.[P1-end]

=== Ajax Behavior Event / Listener Model

Corresponding to the standard behavior event
classes described in the previous section the specification supports an
event listener model for broadcasting and handling _AjaxBehavior_
events.

=== javax.faces.event.AjaxBehaviorEvent

This event type extends from
_javax.faces.event.BehaviorEvent_ and it is broadcast from an
AjaxBehavior. This class follows the standard JSF event / listener
model, incorporating the usual methods as outlined in
link:JSF.html#a1300[See Event and Listener Model]. This class is
responsible for invoking the method implementation of
_javax.faces.event.AjaxBehaviorListener.processAjaxBehavior._ Refer to
the javadocs for more complete details about this class.

=== javax.faces.event.AjaxBehaviorListener

This listener type extends from
_javax.faces.event.BehaviorListener_ and it is invoked in response to
_AjaxBehaviorEvents._

[width="100%",cols="100%",]
|===
|public void
processAjaxBehavior(AjaxBehaviorEvent event)
|===

 _AjaxBehaviorListener_ implementations
implement this method to provide server side functionality in response
to _AjaxBehavior_ Events. See the javadocs for more details about this
class.



=== Adding Behavior To Components

Using the ClientBehaviorHolder interface
(link:JSF.html#a1239[See ClientBehaviorHolder])
_ClientBehavior_ instances can be added to components. For
_ClientBehavior_ implementations that extend _UIComponentBase_ , the
minimal requirement is to override _getEventNames()_ to return a
non-empty collection of the event names exposed by the
_ClientBehaviorHolder_ . A optional default event name may be specified
as well. For example:

Here’s an example code snippet from one of
the Html components:

[width="100%",cols="100%",]
|===
a|
public class HtmlCommandButton extends
javax.faces.component.UICommand implements ClientBehaviorHolder \{

...

private static final Collection<String>
EVENT_NAMES =
Collections.unmodifiableCollection(Arrays.asList("blur","change","click","action",...));



 public Collection<String> getEventNames() \{

 return EVENT_NAMES; }



 public String getDefaultEventName() \{

 return "action"; }

...



|===

Users of the component will be able to attach
_ClientBehavior_ instances to any of the event names specified by the
_getEventNames()_ implementation by calling
_ClientBehaviorHolder.addBehavior(eventName, clientBehavior)_ .

=== Behavior Registration

JSF provides methods for registering
_Behavior_ implementations and these methods are similar to the methods
used to register converters and validators. Refer to
link:JSF.html#a3468[See Object Factories] for the specifics
about these methods.

=== XML Registration

JSF provides the usual faces-config.xml
registration of custom component behavior implementations.

[width="100%",cols="100%",]
|===
a|
<behavior>

<behavior-id>custom.behavior.Greet</behavior-id>

<behavior-class>greet.GreetBehavior</behavior-class>

</behavior>



|===

=== Registration By Annotation

JSF provides the @FacesBehavior annotation
for registering custom behavior implementations.

[width="100%",cols="100%",]
|===
a|
@FacesBehavior(value="custom.behavior.Greet")

public class GreetBehavior extends
BehaviorBase implements Serializable \{

...

}

|===





=== 

image:SF-19.png[image]

[[a1823]]Standard User Interface Components

image:SF-20.png[image]

In addition to the abstract base class
_UIComponent_ and the abstract base class _UIComponentBase_ , described
in the previous chapter, JSF provides a number of concrete user
interface component implementation classes that cover the most common
requirements. In addition, component writers will typically create new
components by subclassing one of the standard component classes (or the
_UIComponentBase_ class). It is anticipated that the number of standard
component classes will grow in future versions of the JavaServer Faces
specification.

Each of these classes defines the
render-independent characteristics of the corresponding component as
JavaBeans component properties. Some of these properties may be _value
expressions_ that indirectly point to values related to the current
request, or to the properties of model data objects that are accessible
through request-scope, session-scope, or application-scope attributes.
In addition, the _rendererType_ property of each concrete implementation
class is set to a defined value, indicating that decoding and encoding
for this component will (by default) be delegated to the corresponding
_Renderer_ .

=== 

image:SF-21.png[image]

Standard User Interface Components

This section documents the features and
functionality of the standard _UIComponent_ classes and implementations
that are included in JavaServer Faces.

[P1-start-componentConstant]The
implementation for each standard _UIComponent_ class must specify two
public static final String constant values:

 _COMPONENT_TYPE_ -- The standard component
type identifier under which the corresponding component class is
registered with the _Application_ object for this application. This
value may be used as a parameter to the _createComponent()_ method.

{empty} _COMPONENT_FAMILY_ -- The standard
component family identifier used to select an appropriate Renderer for
this component.[P1-end]

For all render-independent properties in the
following sections (except for _id_ , _scope_ , and _var_ ) the value
may either be a literal, or it may come from a value expression. Please
see link:JSF.html#a2349[See Value Expressions] for more
information.

The following UML class diagram shows the
classes and interfaces in the package _javax.faces.component._

=== [[a1834]]The _javax.faces.component_ package

image:SF-22.png[image]

=== UIColumn

 _UIColumn_ (extends _UIComponentBase_ ) is a
component that represents a single column of data with a parent _UIData_
component. The child components of a _UIColumn_ will be processed once
for each row in the data managed by the parent _UIData_ .

=== Component Type

The standard component type for _UIColumn_
components is “javax.faces.Column”.

=== Properties

 _UIColumn_ adds the following
render-independent properties:

[width="100%",cols="25%,25%,25%,25%",options="header",]
|===
|Name |Access
|Type |Description
| _footer_ |RW
| _UIComponent_
|Convenience methods to get and set the
“footer” facet for this component.

| _header_ |RW
|UIComponent
|Convenience methods to get and set the
“header” facet for this component.
|===

 _[P1-start-uicolumn]UIColumn_ specializes
the behavior of render-independent properties inherited from the parent
class as follows:

The default value of the _family_ property
must be set to “javax.faces.Column”.

{empty}The default value of the
_rendererType_ property must be set to _null_ .[P1-end]

=== [[a1852]]Methods

 _UIColumn_ adds no new processing methods.

=== Events

 _UIColumn_ adds no new event handling
methods.

=== UICommand

 _UICommand_ (extends _UIComponentBase;_
implements _ActionSource_ ) is a control which, when activated by the
user, triggers an application-specific “command” or “action.” Such a
component is typically rendered as a push button, a menu item, or a
hyperlink.

=== Component Type

The standard component type for _UICommand_
components is “javax.faces. _Command_ ”.

=== Properties

 _UICommand_ adds the following
render-independent properties.

[width="100%",cols="25%,25%,25%,25%",options="header",]
|===
|Name |Access
|Type |Description
| _value_ |RW
| _Object_ |The
value of this component, normally used as a label.
|===

See link:JSF.html#a1090[See
ActionSource] for information about properties introduced by the
implemented classes.

 _[P1-start-uicommand]UICommand_ components
specialize the behavior of render-independent properties inherited from
the parent class as follows:

The default value of the _family_ property
must be set to “javax.faces.Command”.

{empty}The default value of the
_rendererType_ property must be set to “javax.faces.Button”.[P1-end]

=== Methods

 _UICommand_ adds no new processing methods.
See link:JSF.html#a1090[See ActionSource] for information about
methods introduced by the implemented classes.

=== Events

 _UICommand_ adds no new event processing
methods. See link:JSF.html#a1090[See ActionSource] for
information about event handling introduced by the implemented classes.

=== UIData

 _UIData_ (extends _UIComponentBase;_
implements _NamingContainer_ ) is a component that represents a data
binding to a collection of data objects represented by a DataModel
instance (see link:JSF.html#a2281[See DataModel]). Only children
of type _UIColumn_ should be processed by renderers associated with this
component.

=== Component Type

The standard component type for _UIData_
components is “javax.faces.Data”

=== [[a1878]]Properties

 _UIData_ adds the following
render-independent properties.

[width="100%",cols="25%,25%,25%,25%",options="header",]
|===
|Name |Access
|Type |Description
| _dataModel_
|protected RW |
_DataModel_ |The internal value
representation of the _UIData_ instance. Subclasses might write to this
property if they want to restore the internal model during the _Restore
View Phase_ or if they want to explicitly refresh the model for the
_Render Response_ phase. __

| _first_ |RW
| _int_
|Zero-relative row number of the first row in
the underlying data model to be displayed, or zero to start at the
beginning of the data model.

| _footer_ |RW
| _UIComponent_
|Convenience methods to get and set the
“footer” facet for this component.

| _header_ |RW
|UIComponent
|Convenience methods to get and set the
“header” facet for this component.

|rowCount |RO
|int |The number
of rows in the underlying _DataModel_ , which can be -1 if the number of
rows is unknown.

|rowAvailable |RO
|boolean |Return
_true_ if there is row data available for the currently specified
_rowIndex_ ; else return _false_ .

|rowData |RO
|Object |The data
object representing the data for the currently selected _rowIndex_
value.

|rowIndex |RW
|int
|Zero-relative index of the row currently
being accessed in the underlying _DataModel_ , or -1 for no current row.
See below for further information.

|rows |RW
|int |The number
of rows (starting with the one identified by the _first_ property) to be
displayed, or zero to display the entire set of available rows.

|value |RW
|Object |The
_DataModel_ instance representing the data to which this component is
bound, or a collection of data for which a _DataModel_ instance is
synthesized. See below for more information.

|var |RW
|String |The
request-scope attribute (if any) under which the data object for the
current row will be exposed when iterating.
|===

See link:JSF.html#a1134[See
NamingContainer] for information about properties introduced by the
implemented classes.

 _[P1-start-uidata]UIData_ specializes the
behavior of render-independent properties inherited from the parent
component as follows:

The default value of the _family_ property
must be set to “javax.faces.Data”.

{empty}The default value of the
_rendererType_ property must be set to “ _javax.faces.Table_ ”.[P1-end]

The current value identified by the _value_
property is normally of type _DataModel_ .
[P1-start-uidataModel]However, a _DataModel_ wrapper instance must
automatically be provided by the JSF implementation if the current value
is of one of the following types:

 _java.util.List_

Array of _java.util.Object_

 _java.sql.ResultSet_ (which therefore also
supports _javax.sql.RowSet_ )

 _javax.servlet.jsp.jstl.sql.Result_

java.util.Map (uses the wrapper for
java.lang.Iterable by providing access to java.util.Map#entrySet())

{empty}Any other Java object is wrapped by a
_DataModel_ instance with a single row.[P1-end]

Convenience implementations of _DataModel_
are provided in the _javax.faces.model_ package for each of the above
(see link:JSF.html#a2302[See Concrete Implementations]), and
must be used by the _UIData_ component to create the required
_DataModel_ wrapper.

=== [[a1921]]Methods

 _UIData_ adds no new processing methods.
However, the getDataModel() method is now protected, so implementations
have access to the underlying data model. See
link:JSF.html#a1134[See NamingContainer] for information about
methods introduced by the implemented classes.

UIData specializes the behavior of the
_getClientId()_ method inherited from its parent, in order to create a
client identifier that includes the current rowIndex value (if it is not
-1). Because _UIData_ is a _NamingContainer_ , this makes it possible
for rendered client identifiers of child components to be row-specific.

 _UIData_ specializes the behavior of the
_queueEvent()_ method inherited from its parent, to wrap the specified
event (bubbled up from a child component) in a private wrapper
containing the current rowIndex value, so that this rowIndex can be
reset when the event is later broadcast.

 _UIData_ specializes the behavior of the
_broadcast()_ method to unwrap the private wrapper (if this event was
wrapped), and call _setRowIndex()_ to re-establish the context in which
the event was queued, followed by delivery of the event.

 _[P1-start-uidataDecode]UIData_ specializes
the behavior of the _processDecodes()_ , _processValidators()_ , and
_processUpdates()_ methods inherited from its parent as follows:

For each of these methods, the _UIData_
implementation must iterate over each row in the underlying data model,
starting with the row identified by the _first_ property, for the number
of rows indicated by the _rows_ property, by calling the _setRowIndex()_
method.

{empty}When iteration is complete, set the
_rowIndex_ property of this component, and of the underlying _DataModel_
, to zero, and remove any request attribute exposed via the _var_
property.[P1-end]

 _UIData_ specializes the behavior of
_invokeOnComponent()_ inherited from _UIComponentBase_ to examine the
argument _clientId_ and extract the _rowIndex_ , if any, and position
the data properly before proceeding to locate the component and invoke
the callback. Upon normal or exception return from the callback the data
must be repositioned to match how it was before invoking the callback.
Please see the javadocs for _UIData.invokeOnComponent()_ for more
details.

=== Events

 _UIData_ adds no new event handling methods.
Seelink:JSF.html#a1134[See NamingContainer] for information
about event handling introduced by the implemented classes.

=== [[a1932]]UIForm

 _UIForm_ (extends _UIComponentBase;_
implements _NamingContainer_ ) is a component that represents an input
form to be presented to the user, and whose child components (among
other things) represent the input fields to be included when the form is
submitted.

[P1-start-uiformEncodeEnd]The _encodeEnd()_
method of the renderer for _UIForm_ must call _ViewHandler.writeState()_
_before_ writing out the markup for the closing tag of the
form.[P1-end]This allows the state for multiple forms to be saved.

=== Component Type

The standard component type for _UIForm_
components is “javax.faces. _Form_ ”.

=== Properties

 _UIForm_ adds the following
render-independent properties.

[width="100%",cols="25%,25%,25%,25%",options="header",]
|===
|Name |Access
|Type |Description
| _prependId_ |RW
| _boolean_ |If
true, this _UIForm_ instance does allow its id to be pre-pendend to its
descendent’s id during the generation of clientIds for the descendents.
The default value of this property is _true_ . __
|===

 _[P1-start-uiform]UIForm_ specializes the
behavior of render-independent properties inherited from the parent
component as follows:

The default value of the _family_ property
must be set to “ _javax.faces.Form_ ”.

{empty}The default value of the
_rendererType_ property must be set to “ _javax.faces.Form_ ”.[P1-end]

=== Methods.

[width="100%",cols="100%",]
|===
a|
public boolean isSubmitted();

public void setSubmitted(boolean submitted)

|===

[P1-start-uiform-setSubmitted]The
_setSubmitted()_ method of each _UIForm_ instance in the view must be
called during the _Apply Request Values_ phase of the request processing
lifecycle, during the processing performed by the _UIComponent.decode()_
method. If this _UIForm_ instance represents the form actually being
submitted on this request, the parameter must be set to _true_ ;
otherwise, it must be set to _false_ .[P1-end] The standard
implementation of _UIForm_ delegates the responsibility for calling this
method to the _Renderer_ associated with this instance..

{empty}[P1-start-uiform-submitted]The value
of a _UIForm'_ s _submitted_ property must not be saved as part of its
state.[P1-end]

[width="100%",cols="100%",]
|===
|public void processDecodes(FacesContext
context);
|===

Override _UIComponent.processDecodes()_ to
ensure that the _submitted_ property is set for this component. If the
_submitted_ property decodes to false, do not process the children and
return immediately.

[width="100%",cols="100%",]
|===
a|
public void processValidators(FacesContext
context);

public void processUpdates(FacesContext
context);

|===

Override _processValidators()_ and
_processUpdates()_ to ensure that the children of this _UIForm_ instance
are only processed if _isSubmitted()_ returns true.

[width="100%",cols="100%",]
|===
|public void saveState(FacesContext context);
|===

[P1-start-uiformSaveState]The _saveState()_
method of UIForm must call _setSubmitted(false)_ before calling
_super.saveState()_ as an extra precaution to ensure the submitted state
is not persisted across requests.[P1-end].

[width="100%",cols="100%",]
|===
|protected String
getContainerClientId(FacesContext context);
|===

{empty}[P1-start-uiformPrependId]Override the
parent method to ensure that children of this _UIForm_ instance in the
view have the form’s _clientId_ prepended to their _clientId_ s if and
only if the form’s _prependId_ property is _true_ .[P1-end]

=== Events

 _UIForm_ adds no new event handling methods.

=== UIGraphic

 _UIGraphic_ (extends _UIComponentBase_ ) is
a component that displays a graphical image to the user. The user cannot
manipulate this component; it is for display purposes only.

=== Component Type

The standard component type for _UIGraphic_
components is “javax.faces. _Graphic_ ”.

=== Properties

The following render-independent properties
are added by the UIGraphic component:

[width="100%",cols="25%,25%,25%,25%",options="header",]
|===
|Name |Access
|Type |Description
| _url_ |RW
| _String_ |The
URL of the image to be displayed. If this URL begins with a _/_
character, it is assumed to be relative to the context path of the
current web application. This property is a typesafe alias for the
_value_ property, so that the actual URL to be used can be acquired via
a value expression.

| _value_ |RW
| _Object_ |The
value of this component, normally used as a URL.
|===

 _[P1-start-uigraphic]UIGraphic_ specializes
the behavior of render-independent properties inherited from the parent
component as follows:

The default value of the _family_ property
must be set to “javax.faces.Graphic”.

{empty}The default value of the
_rendererType_ property must be set to “ _javax.faces.Image_ ”.[P1-end]

=== Methods

 _UIGraphic_ adds no new processing methods.

=== Events

 _UIGraphic_ does not originate any standard
events.

=== [[a1981]]UIInput

 _UIInput_ (extends _UIOutput_ , implements
_EditableValueHolder_ ) is a component that both displays the current
value of the component to the user (as _UIOutput_ components do), and
processes request parameters on the subsequent request that need to be
decoded.

=== Component Type

The standard component type for _UIInput_
components is “ _javax.faces.Input_ ”.

=== Properties

 _UIInput_ adds the following renderer
independent properties.:

[width="100%",cols="25%,25%,25%,25%",options="header",]
|===
|Name |Access
|Type |Description
| _requiredMessage_
|RW | _String_
|ValueExpression enabled property. If
non-null, this property is used as the _summary_ and _detail_ strings of
the _FacesMessage_ that is queued on the _FacesContext_ instead of the
default message for the required validaiton failure. Note that the
message is fully internationalizable via either the _f:loadBundle_ tag
or via _ResourceBundle_ access from the EL.

| _converterMessage_
|RW | _String_
|ValueExpression enabled property. If
non-null, this property is used as the _summary_ and _detail_ strings of
the _FacesMessage_ that is queued on the _FacesContext_ instead of the
default message for conversion failure. Note that the message is fully
internationalizable via either the _f:loadBundle_ tag or via
_ResourceBundle_ access from the EL.

| _validatorMessage_
|RW | _String_
|ValueExpression enabled property. If
non-null, this property is used as the _summary_ and _detail_ strings of
the _FacesMessage_ that is queued on the _FacesContext_ instead of the
default message for validation failure. Note that the message is fully
internationalizable via either the _f:loadBundle_ tag or via
_ResourceBundle_ access from the EL.
|===



See link:JSF.html#a1192[See
EditableValueHolder] for information about properties introduced by the
implemented interfaces.

[P1-start-uiinput]UIInput specializes the
behavior of render-independent properties inherited from the parent
component as follows:

The default value of the _family_ property
must be set to “ _javax.faces.Input_ ”.

The default value of the _rendererType_
property must be set to “ _javax.faces.Text_ ”.

{empty}The _Converter_ specified by the
_converter_ property (if any) must also be used to perform
String->Object conversions during decoding.[P1-end]

If the _value_ property has an associated
_ValueExpression_ , the _setValue()_ method of that _ValueExpression_
will be called during the _Update Model Values_ phase of the request
processing lifecycle to push the local value of the component back to
the corresponding model bean property.

=== [[a2005]]Methods

The following method is used during the
_Update Model Values_ phase of the request processing lifecycle, to push
the converted (if necessary) and validated (if necessary) local value of
this component back to the corresponding model bean property.

[width="100%",cols="100%",]
|===
|public void updateModel(FacesContext
context);
|===

The following method is over-ridden from
_UIComponent:_

[width="100%",cols="100%",]
|===
|public void broadcast(FacesEvent event);
|===

In addition to the default
_UIComponent.broadcast(javax.faces.event.FacesEvent)_ processing, pass
the _ValueChangeEvent_ being broadcast to the method referenced by the
_valueChangeListener_ property (if any).

[width="100%",cols="100%",]
|===
|public void validate(FacesContext context);
|===

Perform the algorithm described in the
javadoc to validate the local value of this _UIInput_ ..

[width="100%",cols="100%",]
|===
|public void resetValue();
|===

Perform the algorithm described in the
javadoc to reset this _UIInput_ to the state where it has no local
value. This method does not touch the value expresson associated with
the “ _value_ ” property.

=== Events

All events are described in
link:JSF.html#a1192[See EditableValueHolder].

=== UIMessage

 _UIMessage_ (extends _UIComponentBase_ )
encapsulates the rendering of error message(s) related to a specified
input component.

=== Component Type

The standard component type for _UIMessage_
components is “ _javax.faces.Message_ ”.

=== Properties

The following render-independent properties
are added by the UIMessage component:

[width="100%",cols="25%,25%,25%,25%",options="header",]
|===
|Name |Access
|Type |Description
| _for_ |RW
| _String_
|Identifier of the component for which to
render error messages. If this component is within the same
NamingContainer as the target component, this must be the component
identifier. Otherwise, it must be an absolute component identifier
(starting with “:”). See the UIComponent.findComponent() Javadocs for
more information.

|showDetail |RW
|boolean |Flag
indicating whether the “detail” property of messages for the specified
component should be rendered. Default value is “true”.

|showSummary |RW
|boolean |Flag
indicating whether the “summary” property of messages for the specified
component should be rendered. Default value is “false”.
|===

 _[P1-start-uimessage]UIMessage_ specializes
the behavior of render-independent properties inherited from the parent
component as follows:

The default value of the _family_ property
must be set to “ _javax.faces.Message_ ”.

{empty}The default value of the
_rendererType_ property must be set to “ _javax.faces.Message_
”.[P1-end]

=== Methods.

 _UIMessage_ adds no new processing methods.

=== Events

 _UIMessage_ adds no new event handling
methods.

=== UIMessages

 _UIMessage_ (extends _UIComponentBase_ )
encapsulates the rendering of error message(s) not related to a
specified input component, or all enqueued messages.

=== Component Type

The standard component type for _UIMessage_
components is “ _javax.faces.Message_ s”.

=== Properties

The following render-independent properties
are added by the UIMessages component:

[width="100%",cols="25%,25%,25%,25%",options="header",]
|===
|Name |Access
|Type |Description
| _globalOnly_ |RW
| _boolean_ |Flag
indicating whether only messages not associated with any specific
component should be rendered. If not set, all messages will be rendered.
Default value is “false”.

|showDetail |RW
|boolean |Flag
indicating whether the “detail” property of messages for the specified
component should be rendered. Default value is “false”.

|showSummary |RW
|boolean |Flag
indicating whether the “summary” property of messages for the specified
component should be rendered. Default value is “true”.
|===

 _[P1-stat-uimessages]UIMessages_ specializes
the behavior of render-independent properties inherited from the parent
component as follows:

The default value of the _family_ property
must be set to “ _javax.faces.Messages_ ”.

{empty}The default value of the
_rendererType_ property must be set to “ _javax.faces.Messages_
”.[P1-end]

=== Methods.

 _UIMessages_ adds no new processing methods.

=== Events

 _UIMessages_ adds no new event handling
methods.

=== [[a2060]]UIOutcomeTarget

UIOutcomeTarget ( _UIOutput_ ) is a component
that has a value and an outcome, either which may optionally be
retrieved from a model tier bean via a value expression (see
link:JSF.html#a2349[See Value Expressions]), and is displayed to
the user as a hyperlink, appearing in the form of a link or a button.
The user cannot modify the value of the hyperlink, as it's for display
purposes only. The target URL of the hyperlink is derived by passing the
outcome to the _ConfigurationNavigationHandler_ to retrieve the matching
_NavigationCase_ and then using the _ViewHandler_ to translate the
_NavigationCase_ into an action URL. When the client activates the
hyperlink, typically by clicking it, the target URL is retrieved using a
non-faces request and the response is rendered.

This component introduces a scenario known as
"preemptive navigation". The navigation case is resolved during the
Render Response phase, before the client activates the link (and may
never activate the link). The predetermined navigation is pursued after
the client activates the link. In contrast, the UICommand components
resolve and execute the navigation at once, after the Invoke Application
phase.

The _UIOutcomeTarget_ component allows the
developer to leverage the navigation model while at the same time being
able to generate bookmarkable, non-faces requests to be included in the
response.

=== Component Type

The standard component type for
UIOutcomeTarget is "javax.faces.OutcomeTarget".

=== Properties

The following render-independent properties
are added by thec component:

[width="100%",cols="25%,25%,25%,25%",options="header",]
|===
|Name |Access
|Type |
|Outcome |RW
|String |The
logical outcome that is used to resolve a NavigationCase which in turn
is used to build the target URL of this component. Default value is the
current view ID.

|includePageParams
|RW |boolean
|Flag indicating whether the page parameters
should be appended to the query string of the target URL. Default value
is "false".
|===

 _[P1-start-uioutcometarget]_ UIOutcomeTarget
specializes the behavior of render-independent properties inherited from
the parent component as follows:

The default value of the family property must
be set to "javax.faces.UIOutcomeTarget"

The default value of the rendererType
property must be set to "javax.faces.Link" _[P1-end]_

=== Methods

The UIOutcomeTarget adds no event handling
methods.

=== Events

The UIOutcomeTarget adds no event handling
methods.

=== UIOutput

 _UIOutput_ (extends _UIComponentBase;_
implements _ValueHolder_ ) is a component that has a value, optionally
retrieved from a model tier bean via a value expression (see
link:JSF.html#a2349[See Value Expressions]), that is displayed
to the user. The user cannot directly modify the rendered value; it is
for display purposes only:

=== Component Type

The standard component type for _UIOutput_
components is “javax.faces. _Output_ ”.

=== Properties

 _UIOutput_ adds no new render-independent
properties. See link:JSF.html#a1173[See ValueHolder] for
information about properties introduced by the implemented classes.

 _[P1-start-uioutput]UIOutput_ specializes
the behavior of render-independent properties inherited from the parent
component as follows:

The default value of the _family_ property
must be set to “javax.faces.Output”.

{empty}The default value of the
_rendererType_ property must be set to “javax.faces.Text”.[P1-end]

=== Methods

 _UIOutput_ adds no new processing methods.
See link:JSF.html#a1173[See ValueHolder] for information about
methods introduced by the implemented interfaces.

=== Events

UIOutput does not originate any standard
events. See link:JSF.html#a1173[See ValueHolder] for information
about events introduced by the implemented interfaces.

=== UIPanel

 _UIPanel_ (extends _UIComponentBase_ ) is a
component that manages the layout of its child components.

=== Component Type

The standard component type for _UIPanel_
components is “ _javax.faces.Panel_ ”.

=== Properties

 _UIPanel_ adds no new render-independent
properties.

 _[P1-start-uipanel]UIPanel_ specializes the
behavior of render-independent properties inherited from the parent
component as follows:

The default value of the _family_ property
must be set to “ _javax.faces.Panel_ ”.

{empty}The default value of the
_rendererType_ property must be set to _null_ .[P1-end]

=== Methods

 _UIPanel_ adds no new processing methods.

=== Events

 _UIPanel_ does not originate any standard
events

=== UIParameter

 _UIParameter_ (extends _UIComponentBase_ is
a component that represents an optionally named configuration parameter
that affects the rendering of its parent component. _UIParameter_
components do not generally have rendering behavior of their own.

=== Component Type

The standard component type for _UIParameter_
components is “ _javax.faces.Parameter_ ”.

=== Properties

The following render-independent properties
are added by the _UIParameter_ component:

[width="100%",cols="25%,25%,25%,25%",options="header",]
|===
|Name |Access
|Type |Description
|name |RW
|String |The
optional name for this parameter.

|value |RW
|Object |The value
for this parameter.
|===

 _[P1-start-uiparameter]UIParameter_
specializes the behavior of render-independent properties inherited from
the parent component as follows:

The default value of the _family_ property
must be set to “javax.faces.Parameter”.

{empty}The default value of the
_rendererType_ property must be set to _null_ .[P1-end]

=== Methods

 _UIParameter_ adds no new processing
methods.

=== Events

 _UIParameter_ does not originate any
standard events

=== UISelectBoolean

 _UISelectBoolean_ (extends _UIInput_ ) is a
component that represents a single boolean ( _true_ or _false_ ) value.
It is most commonly rendered as a checkbox.

=== Component Type

The standard component type for
_UISelectBoolean_ components is “javax.faces. _SelectBoolean_ ”.

=== Properties

The following render-independent properties
are added by the _UISelectBoolean_ component:

[width="100%",cols="25%,25%,25%,25%",options="header",]
|===
|Name |Access
|Type |Description
| _selected_ |RW
| _boolean_ |The
selected state of this component. This property is a typesafe alias for
the _value_ property, so that the actual state to be used can be
acquired via a value expression.
|===

 _[P1-start-uiselectboolean]UISelectBoolean_
specializes the behavior of render-independent properties inherited from
the parent component as follows:

The default value of the _family_ property
must be set to “ _javax.faces.SelectBoolean_ ”.

{empty}The default value of the
_rendererType_ property must be set to “ _javax.faces.Checkbox_
”.[P1-end]

=== Methods

 _UISelectBoolean_ adds no new processing
methods.

=== Events

 _UISelectBoolean_ inherits the ability to
send _ValueChangeEvent_ events from its parent _UIInput_ component.

=== UISelectItem

 _UISelectItem_ (extends _UIComponentBase_ )
is a component that may be nested inside a _UISelectMany_ or
_UISelectOne_ component, and represents exactly one _SelectItem_
instance in the list of available options for that parent component.

=== Component Type

The standard component type for
_UISelectItem_ components is “ _javax.faces.SelectItem_ ”.

=== Properties

The following render-independent properties
are added by the _UISelectItem_ component:

[width="100%",cols="25%,25%,25%,25%",options="header",]
|===
|Name |Access
|Type |Description
| _itemDescription_
|RW | _String_
|The optional description of this available
selection item. This may be useful for tools.

|itemDisabled |RW
|boolean |Flag
indicating that any synthesized _SelectItem_ object should have its
_disabled_ property set to _true_ .

|itemLabel |RW
|String |The
localized label that will be presented to the user for this selection
item.

|itemValue |RW
|Object |The
server-side value of this item, of the same basic data type as the
parent component’s value. If the parent component type’s value is a
value expression that points at a primitive, this value must be of the
corresponding wrapper type.

|value |RW
|javax.faces.model.SelectItem
|The _SelectItem_ instance associated with
this component.
|===

 _[P1-start-uiselectitem]UISelectItem_
specializes the behavior of render-independent properties inherited

The default value of the _family_ property
must be set to “javax.faces.SelectItem”.

The default value of the _rendererType_
property must be set to _null_ .

If the _value_ property is non- _null_ , it
must contain a _SelectItem_ instance used to configure the selection
item specified by this component.

If the _value_ property is a value
expression, it must point at a _SelectItem_ instance used to configure
the selection item specified by this component.

{empty}If the _value_ property is _null_ ,
and there is no corresponding value expression, the _itemDescription_ ,
_itemDisabled_ , _itemLabel_ and _itemValue_ properties must be used to
construct a new _SelectItem_ representing the selection item specified
by this component.[P1-end]

=== Methods

 _UISelectItem_ adds no new processing
methods.

=== Events

 _UISelectItem_ does not originate any
standard events.

=== UISelectItems

 _UISelectItems_ (extends _UIComponentBase_ )
is a component that may be nested inside a _UISelectMany_ or
_UISelectOne_ component, and represents zero or more _SelectItem_
instances for adding selection items to the list of available options
for that parent component.

=== Component Type

The standard component type for
_UISelectItems_ components is “javax.faces. _SelectItems_ ”.

=== Properties

The following render-independent properties
are added by the _UISelectItems_ component:

[width="100%",cols="25%,25%,25%,25%",options="header",]
|===
|Name |Access
|Type |Description
|value |RW
|See below |The
_SelectItem_ instances associated with this component.
|===

 _[P1-start-uiselectitems]UISelectItems_
specializes the behavior of render-independent properties inherited

The default value of the _family_ property
must be set to “ _javax.faces.SelectItems_ ”.

The default value of the _rendererType_
property must be set to _null_ .

{empty}If the _value_ property (or the value
returned by a value expression associated with the _value_ property) is
non-null, it must contain a _SelectItem_ bean, an array of _SelectItem_
beans, a _Collection_ of _SelectItem_ beans, or a _Map_ , where each map
entry is used to construct a _SelectItem_ bean with the key as the
_label_ property of the bean, and the value as the _value_ property of
the bean (which must be of the same basic type as the value of the
parent component’s value).[P1-end]

=== Methods

 _UISelectItems_ adds no new processing
methods.

=== Events

 _UISelectItems_ does not originate any
standard events.

=== UISelectMany

 _UISelectMany_ (extends _UIInput_ ) is a
component that represents one or more selections from a list of
available options. It is most commonly rendered as a combobox or a
series of checkboxes.

=== Component Type

The standard component type for
_UISelectMany_ components is “ _javax.faces.SelectMany_ ”.

=== Properties

The following render-independent properties
are added by the _UISelectMany_ component:

[width="100%",cols="25%,25%,25%,25%",options="header",]
|===
|Name |Access
|Type |Description
| _selectedValues_
|RW | _Object[] or
array of primitives_ |The selected item
values of this component. This property is a typesafe alias for the
_value_ property, so that the actual state to be used can be acquired
via a value expression.
|===

 _[P1-start-uiselectmany]UISelectMany_
specializes the behavior of render-independent properties inherited from
the parent component as follows:

The default value of the _family_ property
must be set to “ _javax.faces.SelectMany_ ”.

{empty}The default value of the
_rendererType_ property must be set to “ _javax.faces.Listbox_
”.[P1-end]

See the class Javadocs for _UISelectMany_ for
additional requirements related to implicit conversions for the _value_
property.

=== Methods

{empty}
_[P1-start-uselectmany-validate]UISelectMany_ must provide a specialized
_validate()_ method which ensures that any decoded values are valid
options (from the nested _UISelectItem_ and _UISelectItems_
children).[P1-end]

=== Events

 _UISelectMany_ inherits the ability to send
_ValueChangeEvent_ events from its parent _UIInput_ component.

=== UISelectOne

 _UISelectOne_ (extends _UIInput_ ) is a
component that represents zero or one selection from a list of available
options. It is most commonly rendered as a combobox or a series of radio
buttons.

=== Component Type

The standard component type for _UISelectOne_
components is “ _javax.faces.SelectOne_ ”.

=== Properties

 _UISelectOne_ adds no new render-independent
properties.

 _[P1-start-uiselectone]UISelectOne_
specializes the behavior of render-independent properties inherited from
the parent component as follows:

The default value of the _family_ property
must be set to “ _javax.faces.SelectOne_ ”.

{empty}The default value of the
_rendererType_ property must be set to “ _javax.faces.Menu_ ”.[P1-end]

=== Methods

{empty}
_[P1-start-uiselectone-validate]UISelectOne_ must provide a specialized
_validate()_ method which ensures that any decoded value is a valid
option (from the nested _UISelectItem_ and _UISelectItems_
children).[P1-end]

=== Events

 _UISelectOne_ inherits the ability to send
_ValueChangeEvent_ events from its parent _UIInput_ component.

=== UIViewParameter

 _UIViewParameter_ (extends _UIInput_ ) is a
component that allows the query parameters included in the request by
_UIOutcomTarget_ renderers to participate in the lifecycle. Please see
the javadocs for the normative speficication of this component.Events.

=== [[a2226]]UIViewRoot

 _UIViewRoot_ (extends _UIComponentBase;_ )
represents the root of the component tree.

=== Component Type

The standard component type for _UIViewRoot_
components is “ _javax.faces.ViewRoot_ ”

=== [[a2230]]Properties

The following render-independent properties
are added by the _UIViewRoot_ component:

[width="100%",cols="25%,25%,25%,25%",options="header",]
|===
|Name |Access
|Type |Description
|locale |RW
|java.util.Locale
|The Locale to be used in localizing the
response for this view.

|renderKitId |RW
|String |The id of
the _RenderKit_ used to render this page.

| _viewId_ |RW
| _String_ |The
view identifier for this view.

| _beforePhaseListener_
|RW
|MethodExpression
| _MethodExpression_ that will be invoked
before all lifecycle phases except for _Restore View._

| _afterPhaseListener_
|RW
|MethodExpression
|MethodExpression that will be invoked after
all lifecycle phases except for _Restore View_ .

|viewMap |RW
|java.util.Map
|The _Map_ that acts as the interface to the
data store that is the "view scope".
|===

For an existing view, the _locale_ property
may be modified only from the event handling portion of _Process
Validations_ phase through _Invoke Application_ phase, unless it is
modified by an _Apply Request Values_ event handler for an
_ActionSource_ or _EditableValueHolder_ component that has its
_immediate_ property set to true (which therefore causes _Process
Validations_ , _Update Model Values_ , and _Invoke Application_ phases
to be skipped).

{empty} _[P1-start-viewmap]_ The viewMap
property is lazily created the first time it is accessed, and it is
destroyed when a different _UIViewRoot_ instance is installed from a
call to _FacesContext.setViewRoot()_ . After the Map is created a
_PostConstructViewMapEvent_ must be published using _UIViewRoot_ as the
event source. Immediately before the Map is destroyed, a
_PreDestroyViewMapEvent_ must be published using _UIViewRoot_ as the
event source. [P1-end]

 _[P1-start-uiviewroot]UIViewRoot_
specializes the behavior of render-independent properties inherited from
the parent component as follows:

The default value of the _family_ property
must be set to “ _javax.faces.ViewRoot_ ”.

{empty}The default value of the
_rendererType_ property must be set to _null_ .[P1-end]

=== [[a2257]]Methods

The following methods are used for adding
UIComponent resources to a target area in the view, and they are also
used for retrieving UIComponent resources from a target area in the
view.

[width="100%",cols="100%",]
|===
a|
public void addComponentResource(FacesContext
context,

UIComponent componentResource);

|===

Add c _omponentResource,_ that is assumed to
represent a resource instance, to the current view. A resource instance
is rendered by a resource Renderer (such as ScriptRenderer,
StylesheetRenderer) as described in the Standard HTML RenderKit. This
method will cause the resource to be rendered in the “head” element of
the view. __

[width="100%",cols="100%",]
|===
a|
public void addComponentResource(FacesContext
context,

UIComponent componentResource, String
target);

|===

{empty}Add c _omponentResource,_ that is
assumed to represent a resource instance, to the current view at the
specified target location. [P1-start-addComponentResource] The resource
must be added using the algorithm outlined in this method’s
Javadocs.[P1-end]

[width="100%",cols="100%",]
|===
|public List<UIComponent>
getComponentResources(String target);
|===

{empty}Return a List of _UIComponent_
instances residing under the facet identified by target. Each
_UIComponent_ instance in the List represents a resource.
[P1-start-getCompRes] The List must be formulated in accordance with
this method’s Javadocs. [P1-end]

 _UIViewRoot_ specializes the behavior of the
_UIComponent.queueEvent()_ method to maintain a list of queued events
that can be transmitted later. It also specializes the behavior of the
_processDecodes()_ , _processValidators()_ , _processUpdates()_ , and
_processApplication()_ methods to broadcast queued events to registered
listeners. _UIViewRoot_ clears any remaining events from the event queue
in these methods if _responseComplete()_ or _renderResponse()_ has been
set on the _FacesContext._ Please see link:JSF.html#a427[See
Apply Request Values], link:JSF.html#a438[See Process
Validations], link:JSF.html#a446[See Update Model Values] and
link:JSF.html#a454[See Invoke Application] for more details.

=== [[a2268]]Events

 _UIViewRoot_ is a source of _PhaseEvent_
events, which are emitted when the instance moves through all phases of
the request processing lifecycle except _Restore View_ . This phase
cannot emit events from _UIViewRoot_ because the _UIViewRoot_ instance
isn’t created when this phase starts. See
link:JSF.html#a6626[See PhaseEvent] and
link:JSF.html#a6635[See PhaseListener]for more details on the
event and listener class.

[width="100%",cols="100%",]
|===
a|
public void addPhaseListener(PhaseListener
listener);



public void
removePhaseListener(VPhaseListener listener);



public List<PhaseListener>
getPhaseListeners();

|===

{empty}[P1-start-events] _UIViewRoot_ must
listen for the top level _PostAddToViewEvent_ event sent by the _Restore
View_ phase. Refer to _link:JSF.html#a404[See Restore View]_
for more details about the publishing of this event. Upon receiving this
event, _UIViewRoot_ must cause any “after” _Restore View_ phase
listeners to be called.[P1-end]

 _UIViewRoot_ is also the source for several
kinds of system events. The system must publish a _PostAddToViewEvent_ ,
with the _UIViewRoot_ as the source, during the _Restore View_ phase,
immediately after the new _UIViewRoot_ is set into the _FacesContext_
for the request. The system must publish a _PreRenderView_ event, with
_UIViewRoot_ as the source, during the _Render Response_ phase,
immediately before _ViewHandler.renderView()_ is called.

=== [[a2277]]Partial Processing

{empty} _UIViewRoot_ adds special behavior to
_processDecodes, processValidators, processUpdates, getRendersChildren
and encodeChildren_ to facilitate partial processing - namely the
ability to have one or more components processed through the _execute_
and/or _render_ phases of the request processing lifecycle. Refer to
link:JSF.html#a6825[See Partial View
Traversal], link:JSF.html#a6831[See Partial
View Processing], link:JSF.html#a6833[See
Partial View Rendering] for an overview of partial processing.
[P1-start-viewroot-partial] _UIViewRoot_ must perform partial processing
as outlined in the Javadocs for the “processXXX” and “encodeXXX” methods
if the current request is a partial request.[P1-end]

=== 

image:SF-21.png[image]

Standard UIComponent Model Beans

Several of the standard _UIComponent_
subclasses described in the previous section reference JavaBean
components to represent the underlying model data that is rendered by
those components. The following subsections define the standard
_UIComponent_ model bean classes.

=== [[a2281]]DataModel

 _DataModel_ is an abstract base class for
creating wrappers around arbitrary data binding technologies. It can be
used to adapt a wide variety of data sources for use by JavaServer Faces
components that want to support access to an underlying data set that
can be modelled as multiple rows. The data underlying a DataModel
instance is modelled as a collection of row objects that can be accessed
randomly via a zero-relative index

=== Properties

An instance of _DataModel_ supports the
following properties:

[width="100%",cols="25%,25%,25%,25%",options="header",]
|===
|Name |Access
|Type |Description
|rowAvailable |RO
|boolean |Flag
indicating whether the current _rowIndex_ value points at an actual row
in the underlying data.

| _rowCount_ |RO
|int |The number
of rows of data objects represented by this DataModel instance, or -1 if
the number of rows is unknown.

| _rowData_ |RO
| _Object_ |An
object representing the data for the currently selected row. _DataModel_
implementations must return an object that be successfully processed as
the “base” parameter for the _PropertyResolver_ in use by this
application. If the current rowIndex value is -1, _null_ is returned.

| _rowIndex_ |RW
| _int_
|Zero-relative index of the currently
selected row, or -1 if no row is currently selected. When first created,
a _DataModel_ instance must return -1 for this property.

|wrappedData |RW
|Object |Opaque
property representing the data object wrapped by this DataModel. Each
individual implementation will restrict the types of Object(s) that it
supports.
|===

=== [[a2298]]Methods

 _DataModel_ must provide an _iterator()_ to
iterate over the row data for this model. __

=== Events

No events are generated for this component.

=== [[a2302]]Concrete Implementations

[P1-start-datamodel]The JSF implementation
must provide concrete implementations of DataModel (in the
javax.faces.model package) for the following data wrapping scenarios:

 _ArrayDataModel_ -- Wrap an array of Java
objects.

 _ListDataModel_ -- Wrap a _java.util.List_
of Java objects.

 _ResultDataModel_ -- Wrap an object of type
_javax.servlet.jsp.jstl.sql.Result_ (the query results from JSTL’s SQL
tag library)

 _ResultSetDataModel_ -- Wrap an object of
type _java.sql.ResultSet_ (which therefore means that _javax.sql.RowSet_
instances are also supported).

 _ScalarDataModel_ -- Wrap a single Java
object in what appears to be a one-row data set.

Each concrete _DataModel_ implementation must
extend the _DataModel_ abstract base class, and must provide a
constructor that accepts a single parameter of the object type being
wrapped by that implementation (in addition to a zero-args
constructor).[P1-end] See the JavaDocs for specific implementation
requirements on _DataModel_ defined methods, for each of the concrete
implementation classes.

=== SelectItem

 _SelectItem_ is a utility class representing
a single choice, from among those made available to the user, for a
_UISelectMany_ or _UISelectOne_ component. It is not itself a
_UIComponent_ subclass.

=== Properties

An instance of _SelectItem_ supports the
following properties:

[width="100%",cols="25%,25%,25%,25%",options="header",]
|===
|Name |Access
|Type |Description
|description |RW
|String |A
description of this selection item, for use in development tools.

| _disabled_ |RW
|boolean |Flag
indicating that this option should be rendered in a fashion that
disables selection by the user. Default value is _false_ .

| _label_ |RW
| _String_ |Label
of this selection item that should be rendered to the user.

| _value_ |RW
| _Object_ |The
server-side value of this item, of the same basic data type as the
parent component’s value. If the parent component type’s value is a
value expression that points at a primitive, this value must be of the
corresponding wrapper type.
|===

=== Methods

An instance of _SelectItem_ supports no
additional public processing methods.

=== Events

An instance of SelectItem supports no events.

=== SelectItemGroup

 _SelectItemGroup_ is a utility class
extending _SelectItem_ , that represents a group of subordinate
_SelectItem_ instances that can be rendered as a “sub-menu” or “option
group”. _Renderer_ s will typically ignore the _value_ property of this
instance, but will use the _label_ property to render a heading for the
sub-menu.

=== Properties

An instance of _SelectItemGroup_ supports the
following additional properties:

[width="100%",cols="25%,25%,25%,25%",options="header",]
|===
|Name |Access
|Type |Description
|selectItems |RW
|SelectItem[]
|Array of SelectItem instances representing
the subordinate selection items that are members of the group
represented by this SelectItemGroup instance.
|===

Note that, since _SelectItemGroup_ is a
subclass of _SelectItem_ , _SelectItemGroup_ instances can be included
in the _selectItems_ property in order to create hierarchies of
subordinate menus. However, some rendering environments may limit the
depth to which such nesting is supported; for example, HTML/4.01 does
not allow an _<optgroup>_ to be nested inside another _<optgroup>_
within a _<select>_ control.

=== Methods

An instance of _SelectItemGroup_ supports no
additional public processing methods.

=== Events

An instance of _SelectItemGroup_ supports no
events.

-

=== 

image:SF-23.png[image]

[[a2344]]Expression Language and Managed Bean Facility

image:SF-24.png[image]

In the descriptions of the standard user
interface component model, it was noted that all attributes, and nearly
all properties can have a _value expression_ associated with them (see
link:JSF.html#a911[See ValueExpression properties]). In
addition, many properties, such as _action_ , _actionListener_ ,
_validator_ , and _valueChangeListener_ can be defined by a _method
expression_ pointing at a public method in some class to be executed.
This chapter describes the mechanisms and APIs that JavaServer Faces
utilizes in order to evaluate value expressions and method expressions.

JavaServer Faces relies on the Unified
Expression Language (Unified EL, or just EL) provided by version 2.1 of
the JavaServer Pages specification (JSR-245). The EL is described in a
separate specification document delivered as part of the JSP 2.1 spec.
Please consult that document for complete details about the EL.

Versions 1.0 and 1.1 of JavaServer Faces
included a built in expression language and required an implementation
of it. The API for this old JSF EL is still preserved as deprecated
classes and methods, and implementations must still support that API.
Please consult the link:JSF.html#a8777[See Guide to Deprecated
Methods Relating to the Unified EL and their Corresponding Replacements]
for details. This chapter will focus exclusively on how Faces leverages
and integrates with the Unified EL. It does not describe how the Unified
EL operates.

=== 

image:SF-25.png[image]

[[a2349]]Value Expressions

=== Overview

To support binding of attribute and property
of values to dynamically calculated results, the name of the attribute
or property can be associated with a value expression using the
_setValueExpression()_ method. Whenever the dynamically calculated
result of evaluating the expression is required, the _getValue()_ method
of the _ValueExpression_ is called, which returns the evaluated result.
Such expressions can be used, for example, to dynamically calculate a
component value to be displayed:

[width="100%",cols="100%",]
|===
|<h:outputText value=”#\{customer.name}”/>
|===

which, when this page is rendered, will
retrieve the bean stored under the “customer” key, then acquire the name
property from that bean and render it.

Besides the component value itself, value
expressions can be used to dynamically compute attributes and
properties. The following example checks a _boolean_ property _manager_
on the current _user_ bean (presumably representing the logged-in user)
to determine whether the _salary_ property of an employee should be
displayed or not:

[width="100%",cols="100%",]
|===
|<h:outputText rendered=”#\{user.manager}”
value=”#\{employee.salary}”/>
|===

which sets the _rendered_ property of the
component to _false_ if the user is not a manager, and therefore causes
this component to render nothing.

The Unified Expression Language has a
powerful set of coercion rules that automatically convert the type of
the value to the appropriate type. These rules occasionally rely on the
JavaBeans _PropertyEditor_ facility to perform this conversion. Note
that this conversion is entirely separate from normal JSF Conversion.

Value expressions can also be used to set a
value from the user into the item obtained by evaluating the expression.
For example:

[width="100%",cols="100%",]
|===
|<h:inputText value=”#\{employee.number}”/>
|===

When the page is rendered, the expression is
evaluated as an r-value and the result is displayed as the default value
in the text field. When the page is submitted, the expression is
evaluated as an l-value, and the value entered by the user (subject to
conversion and validation as usual) is pushed into the expression.

=== Value Expression Syntax and Semantics

Please see Section 1.2 of the Expression
Language Specification, Version 2.1 for the complete specification of
ValueExpression syntax and semantics.

=== 

image:SF-25.png[image]

MethodExpressions

 _Method expressions_ are a very similar to
value expressions, but rather than supporting the dynamic retrieval and
setting of properties, method expressions support the invocation (i.e.
execution) of an arbitrary public method of an arbitrary object, passing
a specified set of parameters, and returning the result from the called
method (if any). They may be used in any phase of the request processing
lifecycle; the standard JSF components and framework employ them
(encapsulated in a _MethodExpression_ object) at the following times:

During _Apply Request Values_ or _Invoke
Application_ phase (depending upon the state of the _immediate_
property), components that implement the _ActionSource2_ behavioral
interface (see link:JSF.html#a1120[See ActionSource2]) utilize
_MethodExpressions_ as follows:

If the _actionExpression_ property is
specified, it must be a _MethodExpression_ expression that identifies an
Application Action method (see link:JSF.html#a3553[See
Application Actions]) that takes no parameters and returns a String.

It’s possible to have a method expression act
as an _ActionListener_ by using the classs
_MethodExpressionActionListener_ to wrap a method expression and calling
the _addActionListener()_ method on the _ActionSource_ . The method
expression wrapped inside the _MethodExpressionActionListener must_
identify a public method that accepts an _ActionEvent_ (see
link:JSF.html#a1308[See Event Classes]) instance, and has a
return type of _void_ . The called method has exactly the same
responsibilities as the _processAction()_ method of an _ActionListener_
instance (see link:JSF.html#a1329[See Listener Classes]) that
was built in to a separate Java class.

During the _Apply Request Values_ or _Process
Validations_ phase (depending upon the state of the _immediate_
property), components that implement _EditableValueHolder_ (such as
_UIInput_ and its subclasses) components (see
link:JSF.html#a1192[See EditableValueHolder]) utilize method
expressions as follows:

The user can use the
_MethodExpressionValidator_ class to wrap a method expression that
identifies a public method that accepts a _FacesContext_ instance and a
_UIComponent_ instance, and an _Object_ containing the value to be
validated, and has a return type of _void_ . This
_MethodExpressionValidator_ instance can then be added as a normal
_Validator_ using the _EditableValueHolder.addValidator()_ method. The
called method has exactly the same responsibilities as the _validate()_
method of a _Validator_ instance (see link:JSF.html#a1414[See
Validator Classes]) that was built in to a separate Java class.

The user can use the
_MethodExpressionValueChangeListener_ class to wrap a method expression
that identifies a public method that accepts a _ValueChangeEvent_ (see
link:JSF.html#a1308[See Event Classes]) instance, and has a
return type of _void_ . This _MethodExpressionValueChangeListener_
instance can then be added as a normal _ValueChangeListener_ using
EditableValueHolder.addValueChangeListener(). The called method has
exactly the same responsibilities as the _processValueChange()_ method
of a _ValueChangeListener_ instance (see link:JSF.html#a1329[See
Listener Classes]) that was built in to a separate Java class.

Here is the set of component properties that
currently support _MethodBinding_ , and the method signatures to which
they must point:

=== component properties whose type is DEPRECATED MethodBinding

component property

method signature

 _DEPRECATED_

 _action_

 _public String <methodName>();_

 _DEPRECATED_

 _actionListener_

 _public void
<methodName>(javax.faces.event.ActionEvent);_

 _DEPRECATED_

 _validator_

 _public void
<methodName>(javax.faces.context.FacesContext,
javax.faces.component.UIComponent, java.lang.Object);_

 _DEPRECATED_

 _valueChangeListener_

 _public void
<methodName>(javax.faces.event.ValueChangeEvent);_

Note that for any of the parameters for the
above methods may also be a subclass of what is listed above. For the
above properties that are marked as DEPRECATED, wrapper classes have
been added that wrap a MethodExpression and implement the appropriate
listener interface, allowing the wrapped expression to be added as a
strongly typed listener, using the normal _add*()_ pattern Here is the
list of such wrapper classes:

=== MethodExpression wrappers to take the place of DEPRECATED MethodBinding properties

component listener property

Wrapper class

method signature

 _actionListener_

javax. _faces_
.event.MethodExpressionActionListener

 _public void
<methodName>(javax.faces.event.ActionEvent);_

 _validator_

javax.faces.validator.MethodExpressionValidator

 _public void
<methodName>(javax.faces.context.FacesContext,
javax.faces.component.UIComponent, java.lang.Object);_

 _valueChangeListener_

javax.faces.event.MethodExpressionValueChangeListener

 _public void
<methodName>(javax.faces.event.ValueChangeEvent);_

The _MethodBinding_ typed _action_ property
of _ActionSource_ is deprecated and has been replaced by the
_MethodExpression_ typed _actionExpression_ property of _ActionSource2._

=== [[a2403]]MethodExpression Syntax and Semantics

The exact syntax and semantics of
MethodExpression are now the domain of the Unified EL. Please see
Section 1.2.1.2 of the Expression Language Specification, Version 2.1.

=== 

image:SF-25.png[image]

[[a2406]]The Managed Bean Facility

As of version 2.3 of this specification, use
of the managed bean facility as specified in this section is strongly
discouraged. A better and more cohesively integrated solution for
solving the same problem is to use Contexts and Dependency Injection
(CDI), as specified in JSR-365. (See link:JSF.html#a173[See
Other Java™ Platform Specifications]).

Perhaps the biggest value-add of bringing EL
concepts to Faces happens when the EL is combined with the managed bean
facility. This feature allows the user to configure an entire complex
tree of POJO beans, including how they should be scoped and populated
with initial values, and expose them to EL expressions. Please see
_link:JSF.html#a2477[See Managed Bean Configuration Example]_ .

The Managed Bean Creation facility is
configured by the existence of _<managed-bean>_ elements in one or more
application configuration resources (see link:JSF.html#a6195[See
Application Configuration Resources]). Note that a special provision has
been made for application configuration resource files residing within
_META-INF/managed-beans.xml_ entries on the application classpath.
Please see link:JSF.html#a6254[See Application Configuration
Resource Format] for the normative spec requirement. Such elements
describe the characteristics of a bean to be created, and properties to
be initialized, with the following nested elements:

 _<managed-bean-name>_ -- The key under which
the created bean can be retrieved; also the key in the scope under which
the created bean will be stored, unless the value of
_<managed-bean-scope>_ is set to _none_ .

 _<managed-bean-class>_ -- The fully
qualified class name of the application class used to instantiate a new
instance. This class must conform to JavaBeans design patterns -- in
particular, it must have a public zero-args constructor, and must have
public property setters for any properties referenced with nested
_<managed-property>_ elements -- or it must be a class that implements
_java.util.Map_ or _java.util.List_ .

 _<managed-bean-scope>_ -- The scope (
_request_ , _view_ , _session_ , or _application_ ) under which the
newly instantiated bean will be stored after creation (under the key
specified by the _<managed-bean-name>_ element), or _none_ for a bean
that should be instantiated and returned, but not stored in any scope.
The latter option is useful when dynamically constructing trees of
related objects, as illustrated in the following example. +
The runtime must must allow the value of this element to be an EL
_ValueExpression_ . If so, and the expression evaluates to _null_ , an
informative error message including the expression string and the name
of the bean must be logged. If the expression evaluates to a _Map_ ,
that _Map_ is used as the scope into which the bean will be stored. If
storing the bean into the _Map_ causes an _Exception_ , the exception is
allowed to flow up to the _ExceptionHandler_ . If the _ValueExpression_
does not evaluate to a _Map_ , a _FacesException_ must be thrown with a
message that includes the expression string, the _toString()_ of the
value, and the type of the value.

 _<list-entries_ > or _<map-entries>_ -- Used
to configure managed beans that are themselves instances of
_java.util.List_ or _java.util.Map,_ respectively. See below for details
on the contents of these elements.

 _<managed-property>_ -- Zero or more
elements used to initialize the properties of the newly instantiated
bean (see below).

After the new managed bean instance is
instantiated, but before it is placed into the specified scope (if any),
each nested _<managed-property>_ element must be processed and a call to
the corresponding property setter must be made to initialize the value
of the corresponding property. If the managed bean has properties not
referenced by _<managed-property>_ elements, the values of such
properties will not be affected by the creation of this managed bean;
they will retain whatever default values are established by the
constructor.

Each _<managed-property>_ element contains
the following elements used to configure the execution of the
corresponding property setter call:

 _<property-name>_ -- The property name of
the property to be configured. The actual property setter method to be
called will be determined as described in the JavaBeans Specification.

Exactly one of the following sub-elements
that can be used to initialize the property value in a number of
different ways:

 _<map-entries>_ -- A set of key/value pairs
used to initialize the contents of a property of type _java.util.Map_
(see below for more details).

 _<null-value/>_ -- An empty element
indicating that this property must be explicitly initialized to _null_ .
This element is not allowed if the underlying property is of a Java
primitive type.

 _<value>_ -- A String value that will have
any leading and trailing spaces stripped, and then be converted
(according to the rules described in the JSP Specification for the
<jsp:setProperty> action) to the corresponding data type of the
property, prior to setting it to this value.

 _<list-entries>_ -- A set of values used to
initialize the contents of a property of type array or _java.util.List_
. See below for more information.

As described above, the _<map-entries>_
element is used to initialize the key-value pairs of a property of type
_java.util.Map_ . This element may contain the following nested
elements:

 _<key-class>_ -- Optional element specifying
the fully qualified class name for keys in the map to be created. If not
specified, _java.lang.String_ is used.

 _<value-class>_ -- Optional element
specifying the fully qualified class name for values in the map to be
created. If not specified, _java.lang.String_ is used.

 _<map-entry>_ -- Zero or more elements that
define the actual key-value pairs for a single entry in the map. Nested
inside is a _<key>_ element to define the key, and then exactly one of
_<null-value>_ , _<value>_ to define the value. These elements have the
same meaning as when nested in a _<managed-property>_ element, except
that they refer to an individual map entry’s value instead of the entire
property value.

As described above, the _<list-entries>_
element is used to initialize a set of values for a property of type
array or _java.util.List_ . This element may contain the following
nested elements:

 _<value-class>_ -- Optional element
specifying the fully qualified class name for values in the map to be
created. If not specified, _java.lang.String_ is used.

Zero or more elements of type _<null-value>_
, _<value>_ to define the individual values to be initialized. These
elements have the same meaning as when nested in a _<managed-property>_
element, except that they refer to an individual list element instead of
the entire property value.

The following general rules apply to the
operation of the Managed Bean Creation facility:

Properties are assigned in the order that
their _<managed-property>_ elements are listed in the application
configuration resource.

If a managed bean has writeable properties
that are not mentioned in _<managed-property>_ elements, the values of
those properties are not assigned any values.

The bean instantiation and population with
properties must be done lazily, when an EL expression causes the bean to
be referenced. For example, this is the case when a _ValueExpression_ or
_MethodExpression_ has its _getValue()_ or _setValue()_ method called.

Due to the above mentioned laziness
constraint, any error conditions that occur below are only required to
be manifested at runtime. However, it is conceivable that tools may want
to detect these errors earlier; this is perfectly acceptable. The
presense of any of the errors described below, until the end of this
section, must not prevent the application from deploying and being made
available to service requests.

[P1-start managed bean config error
conditions] It is an error to specify a managed bean class that does not
exist, or that cannot be instantiated with a public, zero-args
constructor.

It is an error to specify a _<property-name>_
for a property that does not exist, or does not have a public setter
method, on the specified managed bean class.

{empty}It is an error to specify a _<value>_
element that cannot be converted to the type required by a managed
property, or that, when evaluated, results in a value that cannot be
converted to the type required by a managed property. [P1-end]

If the type of the property referenced by the
_<managed-property>_ element is a Java enum, the contents of the
_<value>_ element must be a String that yields a valid return from
_java.lang.Enum.valueOf(PROPERTY_CLASS, VALUE)_ where _PROPERTY_CLASS_
is the _java.lang.Class_ for the property and _VALUE_ is the contents of
the _<value>_ element in the application configuration resource. If any
exception is thrown from _Enum.valueOf()_ it is an error.

[P1-start managed bean scope errors] It is an
error for a managed bean created through this facility to have a
property that points at an object stored in a scope with a (potentially)
shorter life span. Specifically, this means, for an object created with
the specified _<managed-bean-scope>_ , then _<value>_ evaluations can
only point at created objects with the specified managed bean scope:

none -- none

application -- none, application

session -- none, application, session

view -- none, application, session, view

{empty}request -- none, application, session,
view, request [P1-end]

If a bean points to a property whose value is
a mixed expression containing literal strings and expressions, the net
scope of the mixed expression is considered to be the scope of the
narrowest sub-expression, excluding expressions in the none scope.

[P1-start implicit objects in request scope]
Data accessed via an implicit object is also defined to be in a scope.
The following implicit objects are considered to be in request scope:

 _cookie_

 _facesContext_

 _header_

 _headerValues_

 _param_

 _paramValues_

request

 _requestScope_

{empty} _view_ [P1-end]

{empty}[P1-start implicit objects in session
scope] The only implicit objects in session scope are _session_ and
_sessionScope_ [P1-end]

[P1-start implicit objects in application
scope] The following implicit objects are considered to be in
application scope:

 _application_

 _applicationScope_

{empty} _initParam_ [P1-end]

{empty}[P1-start cyclic references error] It
is an error to configure cyclic references between managed beans.
[P1-end]

{empty}[P1-start managed bean names
correctness] Managed bean names must conform to the syntax of a Java
language identifier. [P1-end]

The initialization of bean properties from
_<map-entries>_ and _<list-entries>_ elements must adhere to the
following algorithm, though any confirming implementation may be used.

For _<map-entries>_ :

Call the property getter, if it exists.

If the getter returns _null_ or doesn't
exist, create a _java.util.HashMap_ , otherwise use the returned
_java.util.Map_ .

Add all entries defined by nested
_<map-entry>_ elements in the order they are listed, converting key
values defined by nested _<key>_ elements to the type defined by
_<key-class>_ and entry values defined by nested _<value>_ elements to
the type defined by _<value-class>_ . If a value is given as a value
expression, evaluate the reference and store the result, converting to
_<value-class_ > if necessary. If _<key-class>_ and/or _<value-class>_
are not defined, use _java.lang.String_ . Add _null_ for each
_<null-value>_ element.

If a new _java.util.Map_ was created in step
2), set the property by calling the setter method, or log an error if
there is no setter method.

For _<list-entries>_ :

Call the property getter, if it exists.

If the getter returns _null_ or doesn't
exist, create a _java.util.ArrayList_ , otherwise use the returned
_Object_ (an array or a _java.util.List_ ).

If a _List_ was returned or created in step
2), add all elements defined by nested _<value>_ elements in the order
they are listed, converting values defined by nested _<value>_ elements
to the type defined by _<value-class>_ . If a value is given as a value
expression, evaluate the reference and store the result, converting to
_<value-class_ > if necessary. If a _<value-class>_ is not defined, use
the value as-is (i.e., as a _java.lang.String_ ). Add null for each
_<null-value>_ element.

If an array was returned in step 2), create a
_java.util.ArrayList_ and copy all elements from the returned array to
the new _List_ , wrapping elements of a primitive type. Add all elements
defined by nested _<value>_ elements as described in step 3).

If a new _java.util.List_ was created in step
2) and the property is of type _List_ , set the property by calling the
setter method, or log an error if there is no setter method.

If a new _java.util.List_ was created in step
2) and the property is a java array, convert the _List_ into an array of
the property type, and set it by calling the setter method, or log an
error if there is no setter method.

If a new _java.util.List_ was created in step
4), convert the _List_ to an array of the proper type for the property
and set the property by calling the setter method, or log an error if
there is no setter method.

=== [[a2477]]Managed Bean Configuration Example

The following <managed-bean> elements might
appear in one or more application configuration resources (see
link:JSF.html#a6195[See Application Configuration Resources]) to
configure the behavior of the Managed Bean Creation facility.

Assume that your application includes
_CustomerBean_ with properties _mailingAddress_ and _shippingAddress_ of
type _Address_ (along with additional properties that are not shown),
and _AddressBean_ implementation classes with String properties of type
_street_ , _city_ , _state_ , _country_ , and _postalCode_ .

[width="100%",cols="100%",]
|===
a|
<managed-bean>

 <description>

 A customer bean will be created as needed,
and stored in

 request scope. Its “mailingAddress” and
“streetAddress”

 properties will be initialized by virtue of
the fact that the

 “value” expressions will not encounter any
object under

 key “addressBean” in any scope.

 </description>


<managed-bean-name>customer</managed-bean-name>

 <managed-bean-class>

 com.mycompany.mybeans.CustomerBean

 </managed-bean-class>

 <managed-bean-scope> request
</managed-bean-scope>

 <managed-property>


<property-name>mailingAddress</property-name>

 <value>#\{addressBean}</value>

 </managed-property>

 <managed-property>


<property-name>shippingAddress</property-name>

 <value>#\{addressBean}</value>

 </managed-property>

 <managed-property>

 <property-name>customerType</property-name>

 <value>New</value> <!-- Set to literal value
-->

 </managed-property>

</managed-bean>



|===



[width="100%",cols="100%",]
|===
a|
<managed-bean>

 <description>

 A new AddressBean will not be added to any
scope, because we

 only want to create instances when a
CustomerBean creation asks

 for them. Therefore, we set the scope to
“none”.

 </description>


<managed-bean-name>addressBean</managed-bean-name>

 <managed-bean-class>

 com.mycompany.mybeans.AddressBean

 </managed-bean-class>

 <managed-bean-scope> none
</managed-bean-scope>

</managed-bean>

|===

If a value expression “
_#\{customer.mailingAddress.city}_ ” were to be evaluated by the JSF
implementation, and there was no object stored under key “ _customer_ ”
in request, view, session, or application scope, a new _CustomerBean_
instance will be created and stored in request scope, with its
_mailingAddress_ and _shippingAddress_ properties being initialized to
instances of _AddressBean_ as defined by the configuration elements
shown above. Then, the evaluation of the remainder of the expression can
proceed as usual.

Although not used by the JSF implementation
at application runtime, it is also convenient to be able to indicate to
JSF tools (at design time) that objects of particular types will be
created and made available (at runtime) by some other means. For
example, an application configuration resource could include the
following information to declare that a JDBC data source instance will
have been created, and stored in application scope, as part of the
application’s own startup processing.

[width="100%",cols="100%",]
|===
a|
<referenced-bean>

 <description>

 A JDBC data source will be initialized and
made available in

 some scope (presumably application) for use
by the JSF based

 application when it is actually run. This
information is not

 used by the JSF implementation itself; only
by tools.

 </description>

 <referenced-bean-name> dataSource
</referenced-bean-name>

 <referenced-bean-class>

 javax.sql.DataSource

 </referenced-bean-class>

</referenced-bean>

|===

This information can be utilized by the tool
to construct user interfaces based on the properties of the referenced
beans.

=== 

image:SF-25.png[image]

Managed Bean Annotations[[a2536]]

JSF 2.0 introduced several annotations, in
the package _javax.faces.bean_ , that act as analogs to the managed bean
configuration syntax in the application configuration resources
described earlier in this chapter. JSF 2.0 is a component specification
of Java EE 6, which also includes a much more powerful and complete set
of annotations, from several other component specifications, most
notably Contexts and Dependency Injection (CDI). These annotations are
also usable with JSF. The annotations in the package _javax.faces.bean_
will be deprecated in a version of the JSF specification after 2.2.
Therefore, developers are strongly recommended avoid using those
annotations and instead use the ones from Java EE 6.

=== JSF Managed Classes and Java EE Annotations

JSF Implementations that are running as a
part of Java EE 5 (or later) must allow managed bean implementations to
use the annotations specified in section 14.5 of the Servlet 2.5
Specification to allow the container to inject references to container
managed resources into a managed bean instance before it is made
accessible to the JSF application. Only beans declared to be in
_request_ , _session_ , or _application_ scope are eligible for resource
injection.

In addition to managed beans being injectable
in this manner, the following JSF artifacts are also injectable.

=== [[a2541]]JSF Artifacts Eligible for Injection

Artifact Type

javax.el.ELResolver

javax.faces.application.ApplicationFactory

 _javax.faces.application.NavigationHandler_

 _javax.faces.application.ResourceHandler_

 _javax.faces.application.StateManager_

javax.faces.component.visit.VisitContextFactory

javax.faces.context.ExceptionHandlerFactory

javax.faces.context.ExternalContextFactory

javax.faces.context.FacesContextFactory

javax.faces.context.PartialViewContextFactory

 _javax.faces.event.ActionListener_

 _javax.faces.event.SystemEventListener_

javax.faces.lifecycle.ClientWindowFactory

javax.faces.lifecycle.LifecycleFactory

javax.faces.event.PhaseListener

javax.faces.render.RenderKitFactory

javax.faces.view.ViewDeclarationLanguageFactory

javax.faces.view.facelets.FaceletCacheFactory

javax.faces.view.facelets. +
TagHandlerDelegateFactory

{empty}Please consult the Java 2 Platform
Enterprise Edition Specification 6.0 for complete details of this
feature. Here is a summary of the Java EE annotations one may use in a
managed bean or other artifact from the preceding table. [P1-start valid
annotations in a managed bean]

 _@javax.inject.Inject_

@javax.inject.Named

@javax.inject.Qualifier

@javax.inject.Scope

@javax.inject.Singleton

@javax.enterprise.context.ApplicationScoped

@javax.enterprise.context.ConversationScoped

@javax.enterprise.context.Dependent

@javax.enterprise.context.RequestScoped

@javax.enterprise.context.SessionScoped

 _@javax.annotation.Resource_

 _@javax.annotation.Resources_

 _@javax.ejb.EJB_

 _@javax.ejb.EJBs_

 _@javax.xml.ws.WebServiceRef_

 _@javax.xml.ws.WebServiceRefs_

 _@javax.persistence.PersistenceContext_

 _@javax.persistence.PersistenceContexts_

 _@javax.persistence.PersistenceUnit_

{empty} _@javax.persistence.PersistenceUnits_
[P1-end]

Following is an example of valid usages of
this feature in a managed bean or other artifact in the preceding table.

public class User extends Object \{

 private @EJB ShoppingCart cart;

 private @Resource Inventory inventory;

 private DataSource customerData;



 @Resource(name=”customerData”)

 private void setCustomerData(DataSource
data) \{

 customerData = data;

 }



 public String getOrderSummary() \{

 // Do something with the injected resources

 // And generate a textual summary of the
order

 }



}

This example illustrates that the above
annotations can be attached to instance variables or to JavaBeans
setters. The JSF implementation running in a Java EE 5 container must
guarantee that the injections are performed before the bean is handed
back to the user. Generally, this is done by performing the injection
immediately after the lazy instantiation of the managed bean.

=== [[a2601]]Managed Bean Lifecycle Annotations

JSF implementations running in a Java EE 5
compliant container must support attaching the _@PostConstruct_ and
_@PreDestroy_ annotations to aid in awareness of the managed-bean
lifecycle.

Methods on managed beans declared to be in
_none_ , _request_ , _view_ , _session_ , or _application_ scope,
annotated with _@PostConstruct_ , must be called by the JSF
implementation after resource injection is performed (if any) but before
the bean is placed into scope.

{empty}[P1-start rules governing invocation
of @PostConstruct annotated methods]If the method throws an unchecked
exception, the JSF implementation must not put the managed-bean into
service, a message must be logged, and further methods on that managed
bean instance must not be called. [P1-end]

Methods on managed beans declared to be in
_request_ , _session_ , or _application_ scope, annotated with
_@PreDestroy_ , must be called by the JSF implementation before the bean
is removed from its scope or before the scope itself is destroyed,
whichever comes first. In the case of a managed bean placed in _view_
scope, methods annotated with _@PreDestroy_ must only be called when the
view scope is destroyed. See the javadoc for
_FacesContext.setViewRoot()_ . This annotation must be supported in all
cases where the above _@PostConstruct_ annotation is supported.

[P1-start rules governing invocation of
@PreDestroy annotated methods] If the method throws an unchecked
exception, the JSF implementation may log it, but the exception must not
otherwise alter the execution.

{empty}Refer to the Java EE specification
section 2.5 and the Common Annotations for the JavaTM PlatformTM
specification section 2.5 for more details.[P1-end]

=== 

image:SF-25.png[image]

How Faces Leverages the Unified EL

This section is non-normative and covers the
major players in the Unified EL and how they relate to JavaServer Faces.
The number one goal in this version of the JavaServer Faces
specification is to export the concepts behind the JSF EL into the
Unified EL, which is part of the the JavaServer Pages version 2.1
specification, and then rely on those facilities to get the work done.
Readers interested in how to implement the Unified EL itself must
consult the Unified EL Spec document.

=== ELContext

The ELContext is a handy little “holder”
object that gets passed all around the Unified EL API. It has two
purposes.

To allow technologies that use the Unified
EL, such as JavaServer Faces, the JSF View Declaration Language (JSF
VDL), and JSP, to store any context information specific to that
technology so it can be leveraged during expression evaluation. For
example the expression “ _$\{view.viewId}_ ” is specific to Faces. It
means, “find the _UIViewRoot_ instance for the current view, and return
its _viewId_ ”. The Unified EL doesn’t know about the “view” implicit
object or what a UIViewRoot is, but JavaServer Faces does. The Unified
EL has plugin points that will get called to resolve “view”, but to do
so, JavaServer Faces needs access to the _FacesContext_ from within the
callstack of EL evaluation. Therefore, the _ELContext_ comes to the
rescue, having been populated with the _FacesContext_ earlier in the
request processing lifecycle.

To allow the pluggable resolver to tell the
Unified EL that it did, in fact, resolve a property and that further
resolvers must not be consulted. This is done by setting the “
_propertyResolved_ ” property to _true_ .

The complete specification for ELResolver may
be found in Chapter 2 of the Expression Language Specification, Version
2.1.

=== Lifetime, Ownership and Cardinality

An ELContext instance is created the first
time _getELContext_ () is called on the _FacesContext_ for this request.
Please see _link:JSF.html#a3099[See ELContext]_ for details. Its
lifetime ends the same time the _FacesContext’s_ lifetime ends. The
_FacesContext_ maintains the owning reference to the _ELContext_ . There
is at most one _ELContext_ per _FacesContext_ .

=== Properties

[width="100%",cols="25%,25%,25%,25%",options="header",]
|===
|Name |Access
|Type |Description
| _ELResolver_ |RO
| _javax.el.ELResolver_
|Return the ELResolver instance described in
_link:JSF.html#a2667[See Faces ELResolver for JSP Pages]_

| _propertyResolved_
|RW |boolean
|Set by an ELResolver implementation if it
successfully resolved a property. See _link:JSF.html#a2634[See
ELResolver]_ for how this property is used.
|===

=== Methods

Here is a subset of the methods that are
relevant to Faces.

[width="100%",cols="100%",]
|===
a|
public Object getContext(Class key);

void putContext(Class key, Object
contextInstance);

...

|===

As mentioned in
_link:JSF.html#a3099[See ELContext]_ , the _putContext()_ method
is called, passing the current _FacesContext_ instance the first time
the system asks the _FacesContext_ for its _ELContext_ . The
_getContext()_ method will be called by any _ELResolver_ instances that
need to access the _FacesContext_ to perform their resolution.

=== Events

The creation of an ELContext instance
precipitates the emission of an _ELContextEvent_ from the _FacesContext_
that created it. Please see _link:JSF.html#a3099[See ELContext]_
for details.

=== [[a2634]]ELResolver

Faces 1.1 used the _VariableResolver_ and
_PropertyResolver_ classes as the workhorses of expression evaluation.
The Unified API has the _ELResolver_ instead. The ELResolver concept is
the heart of the Unified EL. When an expression is evaluated, the
ELResolver is responsible for resolving each segment in the expression.
For example, in rendering the component behind the tag “ _<h:outputText
value=”#\{user.address.street}”_ />” the ELResolver is called three
times. Once to resolve “user”, again to resolve the “address” property
of user, and finally, to resolve the “street” property of “address”. The
complete specification for ELResolver may be found in Chapter 2 of the
Expression Language Specification, Version 2.1.

[N/T-start two ELResolver impls] As described
in more detail in _link:JSF.html#a2667[See Faces ELResolver for
JSP Pages],_ Faces must provide two implementations of _ELResolver_ .
[P1-end]Which of these two implementations is actually used to resolve
an expression depends on where the expresison is evaluated. If the
expression is evaluated in a markup page, the ELResolver for markup
pages is used. If the expression is evaluated in java VM hosted code
from Faces, another ELResolver is used that is tailored for use inside
of Faces java VM hosted code. During the course of evaluation of an
expression, a variety of sources must be considered to help resolve each
segment of the expression. These sources are linked in a chain-like
fashion. Each link in the chain has the opportunity to resolve the
current segment. If it does so, it must set the “ _propertyResolved_ ”
property on the _ELContext_ , to _true_ . If not, it must not modify the
value of the “ _propertyResolved_ ” property. If the “
_propertyResolved_ ” property is not set to _true_ the return value from
the _ELResolver_ method is ignored by the system.

=== Lifetime, Ownership, and Cardinality

ELResolver instances have application
lifetime and scope. The JSP container maintains one top level ELResolver
(into which a Faces specific ELResolver is added) accessible from
_JspContext.getELContext().getELResolver()._ This ELResolver instance is
also used from the JSF VDL, even though JSF VDL pages do not themselves
use JSP. Faces maintains one _ELResolver_ (separate from the one handed
to the JSP container) accessible from
_FacesContext.getELContext().getELResolver() and
Application.getELResolver()_ .

=== Properties

ELResolver has no proper JavaBeans properties

=== Methods

Here is a subset of the methods that are
relevant to Faces.

[width="100%",cols="100%",]
|===
a|
public Object getValue(ELContext context,
Object base, Object property);

void setValue(ELContext context, Object base,
Object property, Object value);

...

|===

 _getValue()_ looks at the argument _base_
and tries to return the value of the property named by the argument
_property_ . For example, if base is a JavaBean, _property_ would be the
name of the JavaBeans property, and the resolver would end up calling
the _getter_ for that property.

 _setValue()_ looks at the argument _base_
and tries to set the argument _value_ into the property named by the
argument _property_ . For example, if base is a JavaBean, _property_
would be the name of the JavaBeans property, and the resolver would end
up calling the _setter_ for that property.

There are other methods, such as
_isReadOnly()_ that are beyond the scope of this document, but described
completely in the Unified EL Specification.

=== Events

 _ELResolver_ precipitates no events.

=== [[a2651]]ExpressionFactory

Faces 1.1 used the Application class as a
factory for _ValueBinding_ and _MethodBinding_ instances. The Unified EL
has the _ExpressionFactory_ class instead. It is a factory for
_ValueExpression_ and _MethodExpression_ instances.

=== Lifetime, Ownership, and Cardinality

 _ExpressionFactory_ instances are
application scoped. The _Application_ object maintains the
_ExpressionFactory_ instance used by Faces (See
_link:JSF.html#a3459[See Acquiring ExpressionFactory Instance])_
. The _JspApplicationContext_ object maintains the _ExpressionFactory_
used by the JSP container (and therefore by the JSF VDL). It is
permissible for both of these access methods to yield the same java
object instance.

=== Properties

 _ExpressionFactory_ has no properties.

=== Methods

[width="100%",cols="100%",]
|===
a|
public MethodExpression
createMethodExpression(ELContext context, String expression,
FunctionMapper fnMapper, Class[] paramTypes);

public ValueExpression
createValueExpression(ELContext context, String expression, Class
expectedType, FunctionMapper fnMapper);

|===

These methods take the human readable
expression string, such as _”#\{user.address.street}”_ and return an
object oriented representation of the expression. Which method one calls
depends on what kind of expression you need. The Faces _Application_
class has convenience methods specific to Faces needs for these
concepts, please see link:JSF.html#a3463[See Programmatically
Evaluating Expressions] _._

=== Events

 _ExpressionFactory_ precipitates no events.

=== 

image:SF-25.png[image]

[[a2664]]ELResolver Instances Provided by Faces

This section provides details on what an
implementation of the JavaServer Faces specification must do to support
the Unified EL for usage in a Faces application.

 _link:JSF.html#a2634[See
ELResolver]_ mentions that a Faces implementation must provide two
implementations of ELResolver. One ELResolver, let’s call it the _Faces
ELResolver For Markup Pages_ , is plugged in to the top level resolver
chain returned from _JspContext.getELContext().getELResolver()_ . This
top level resolver chain is used by the view declaration language
container (JSP or JSF View Declaration Language), and possibly by tag
handlers, to resolve expressions. The other _ELResolver_ , let’s call it
the _ELResolver for Facelets and Programmatic Access_ , is used by
Facelets markup pages, and is returned from
_FacesContext.getELContext().getELResolver()_ and
_Application.getELResolver()_ , and is used to resolve expressions that
appear programmatically. See the javadocs for _javax.el.ELResolver_ for
the specification and method semantics for each method in _ELResolver_ .
The remainder of this section lists the implementation requirements for
these two resolvers.

=== [[a2667]]Faces ELResolver for JSP Pages

As mentioned in
_link:JSF.html#a2634[See ELResolver]_ , during the course of
evaluation of an expression, a variety of sources must be considered to
help resolve each segment of the expression. These sources are linked in
a chain-like fashion. Each link in the chain has the opportunity to
resolve the current segment. The Unified EL provides a container class
to support this multi-source variable resolution:
_javax.el.CompositeELResolver_ . The implementation for the _Faces
ELResolver for JSP Pages_ is described as a set of _ELResolvers_ inside
of a _CompositeELResolver_ instance, but any implementation strategy is
permissible as long as the semantics are preserved.

{empty}This diagram shows the set of
_ELResolver_ instances that must be added to the _Faces ELResolver for
JSP Pages_ . This instance must be handed to the JSP container via a
call to
_JspFactory.getDefaultFactory().getJspApplicationContext().addELResolver()_
at application startup time. Even though we are making a JSP API call to
install this _ELResolver_ , we do not require using JSP to develop JSF
applications. It also shows the order in which they must be added.
[P2-start there are 18 methods in the below tables, each can
corresponding to a method on a particular ELResolver. With clever
testing, it is possible to write assertions for these. Testing the
legacy VariableResolver and PropertyResolvers is not included in this 18
methods number. These classes may be tested simply by noting that the
methods do indeed get called on a user-provided VariableResolver or
PropertyResolver.] [P1-end]

=== [[a2670]]Faces ELResolver for JSP Pages



image:SF-26.png[image]

The semantics of each ELResolver are given
below, either in tables that describe what must be done to implement
each particular method on _ELResolver_ , or in prose when such a table
is inappropriate.

=== [[a2673]]Faces Implicit Object ELResolver For JSP

This resolver relies on the presence of
another, JSP specific, implicit object ELResolver in the chain by only
resolving the “facesContext” and “view” implicit objects.

=== Faces ImplicitObjectELResolver for JSP

[width="100%",cols="50%,50%",options="header",]
|===
|ELResolver method
|implementation requirements
| _getValue_ a|
If base is non-null, return null.

If base is null and property is null, throw
PropertyNotFoundException.

link:JSF.html#a2832[See
ImplicitObjectELResolver for Programmatic Access]If base is null and
property is a String equal to

“facesContext”, call
setPropertyResolved(true) on

the argument ELContext and return the
FacesContext

for this request.

If base is null and property is a String
equal to

“view”, call setPropertyResolved(true) on the

argument ELContext and return the UIViewRoot
for

this request by calling

facesContext.getUIViewRoot().

{empty}This ELResolver must also support the
implicit object “resource” as specified in
link:JSF.html#a2830[See Implicit Object ELResolver for Facelets
and Programmatic Access]

| _getType_ a|
If base is non-null, return null.

If base is null and property is null, throw
PropertyNotFoundException.

If base is null and property is a String
equal to “facesContext” or “view”, call setPropertyResolved(true) and
return null;

{empty}Otherwise, just return null;This
ELResolver must also support the implicit object “resuorce” as specified
in link:JSF.html#a2830[See Implicit Object ELResolver for
Facelets and Programmatic Access]

| _setValue_ a|
If base is null and property is null, throw
PropertyNotFoundException.

{empty}If base is null and property is a
String equal to “facesContext” or “view”, _throw
javax.el.PropertyNotWriteable, since “view” and “facesContext” are
read-only_ .This ELResolver must also support the implicit object
“resuorce” as specified in link:JSF.html#a2830[See Implicit
Object ELResolver for Facelets and Programmatic Access]

| _isReadOnly_ a|
If base is non-null, return false.

If base is null and property is null, throw
PropertyNotFoundException.

If base is null and property is a String
equal to “facesContext” or “view”, _call setPropertyResolved(true) on
the argument ELContext and return true._

{empty}Otherwise return false;This ELResolver
must also support the implicit object “resuorce” as specified in
link:JSF.html#a2830[See Implicit Object ELResolver for Facelets
and Programmatic Access]

| _getFeatureDescriptors_ a|
If base is non-null, return null.

If base is null, return an Iterator
containing three java.beans.FeatureDescriptor instances, one for the
“view” property, one for the “facesContext” property and one for the
“resource” property. It is required that all of the FeatureDescriptor
instances in the Iterator set Boolean.TRUE as the value of the
ELResolver.RESOLVABLE_AT_DESIGN_TIME attribute. The name and displayName
of the FeatureDescriptor must be “view”, “facesContext”, “ or “resource”
as appropriate. FacesContext.class, UIViewRoot.class, or
ResourceHandler.class must be stored as the value of the ELResolver.TYPE
attribute, as approriate. The shortDescription must be a suitable
description depending on the implementation. The expert and hidden
properties must be false. The preferred property must be true.

| _getCommonPropertyType_ a|
If base is non-null, return null.

If base is null and return String.class.

|===



=== [[a2711]]ManagedBean ELResolver

This is the means by which the managed bean
creation facility described in _link:JSF.html#a2406[See The
Managed Bean Facility]_ is called into play during EL resolution.

=== ManagedBeanELResolver

[width="100%",cols="50%,50%",options="header",]
|===
|ELResorver method
|implementation requirements
| _getValue_ a|
If base is non-null, return null.

If base is null and property is null, throw
PropertyNotFoundException.

If property matches the name of an entry in
the request, session, or application scopes, in that order, return null.

If base is null, and property matches one of
the managed-bean-name declarations in the application configuration
resources, instantiate the bean, populate it with properties as
described in _link:JSF.html#a2406[See The Managed Bean
Facility]_ , store it in the scope specified by the managed-bean-scope
declaration for this this managed-bean, call setPropertyResolved(true)
on the argument ELContext, and return the freshly instantiated
managed-bean.

Otherwise, return null.

| _getType_ a|
If base is null and property is null, throw
PropertyNotFoundException.

Otherwise return null;

| _setValue_ a|
If base is null and property is null, throw
PropertyNotFoundException.

Otherwise, if base is null, and property
matches one of the managed-bean-name declarations in the application
configuration resources, and a managed bean with that managed-bean-name
does not yet exist in the specified scope, instantiate the bean,
populate it with properties as described in
_link:JSF.html#a2406[See The Managed Bean Facility]_ , store it
in the scope specified by the managed-bean-scope declaration for this
this managed-bean and return. If the managed bean does exist, take no
action and return. In either case (the bean exists or does not exist),
the actual setting will happen by virtue of the BeanELResolver.

Otherwise take no action and return.

| _isReadOnly_ a|
If base is non-null, return false.

If base is null and property is null, throw
PropertyNotFoundException.

If base is null return false. We never set
the propertyResloved property in this method because the set
responsibility is taken care of by the ScopedAttributeELResolver.

| _getFeatureDescriptors_ a|
If base is non-null, return null.

If base is null, return an Iterator
containing java.beans.FeatureDescriptor instances for each managed-bean
in the application-configuration resources. It is required that all of
the FeatureDescriptor instances in the Iterator set Boolean.TRUE as the
value of the ELResolver.RESOLVABLE_AT_DESIGN_TIME attribute. The name
and displayName of the FeatureDescriptor must be the managed-bean-name.
The actual java Class instance for the managed-bean-class must be stored
as the value of the ELResolver.TYPE attribute. The shortDescription of
the FeatureDescriptor must be the description of the managaged-bean
element, if present, null otherwise. The expert and hidden properties
must be false. The preferred property must be true.

| _getCommonPropertyType_ a|
If base is non-null, return null.

If base is null, return Object.class.

|===

=== Resource ELResolver

Please see link:JSF.html#a2940[See
Resource ELResolver] for the specification of this ELResolver.

=== [[a2741]]ResourceBundle ELResolver for JSP Pages

This is the means by which resource bundles
defined in the application configuration resources are called into play
during EL resolution.

=== ResourceBundleELResolver

[width="100%",cols="50%,50%",options="header",]
|===
|ELResorver method
|implementation requirements
| _getValue_ a|
If base is non-null, return null.

If base is null and property is null, throw
PropertyNotFoundException.

If base is null and property is a String
equal to the value of the <var> element of one of the
<resource-bundle>'s in the application configuration resources, use the
Locale of the current UIViewRoot and the base-name of the
resource-bundle to load the ResourceBundle. Call
setPropertyResolved(true). Return the ResourceBundle. Otherwise, return
null.



| _getType_ a|
If base is non-null, return null.

If base is null and property is null, throw
PropertyNotFoundException.

If base is null and property is a String
equal to the value of the <var> element of one of the
<resource-bundle>'s in the application configuration resources, call
setPropertyResolved(true) and return ResourceBundle.class.



| _setValue_ a|
If base is null and property is null, throw
PropertyNotFoundException. If base is null and property is a String
equal to the value of the <var> element of one of the
<resource-bundle>'s in the application configuration resources throw
javax.el.PropertyNotWriteable, since ResourceBundles are read-only.



| _isReadOnly_ a|
If base is non-null, return null. If base is
false and property is null, throw PropertyNotFoundException. If base is
null and property is a String equal to the value of the <var> element of
one of the <resource-bundle>'s in the application configuration
resources, call setPropertyResolved(true) on the argument ELContext and
return true. Otherwise return false;



| _getFeatureDescriptors_ a|
If base is non-null, return null.

If base is null, return an Iterator
containing java.beans.FeatureDescriptor instances, one for each
<resource-bundle> in the <application> element. It is required that all
of these FeatureDescriptor instances set Boolean.TRUE as the value of
the ELResolver.RESOLVABLE_AT_DESIGN_TIME attribute. The name of the
FeatureDescriptor must be the var element of the <resource-bundle>. The
displayName of the FeatureDescriptor must be the display-name of the
<resource-bundle>. ResourceBundle.class must be stored as the value of
the ELResolver.TYPE attribute. The shortDescription must be a suitable
description depending on the implementation. The expert and hidden
properties must be false. The preferred property must be true.



| _getCommonPropertyType_ a|
If base is non-null, return null.

If base is null, return string.Class.



|===



=== [[a2771]]ELResolvers in the application configuration resources

The _<el-resolver>_ element in the
application configuration resources will contain the fully qualified
classname to a class with a public no-arg constructor that implements
_javax.el.ELResolver_ . These are added to the _Faces ELResolver for JSP
Pages_ and the Faces ELResolver for Facelets and Programmatic Access in
the order in which they occur in the application configuration
resources.

=== [[a2773]]VariableResolver Chain Wrapper

This is the means by which _VariableResolver_
instances that have been specified in _<variable-resolver>_ elements
inside the application configuration resources are allowed to affect the
EL resolution process. If there are one or more _<variable-resolver>_
elements in the application configuration resources, an instance of
ELResolver with the following semantics must be created and added to the
_Faces ELResolver for JSP Pages_ as indicated in the
_link:JSF.html#a2670[See Faces ELResolver for JSP Pages]_ .

By virtue of the decorator pattern described
in _link:JSF.html#a6336[See Delegating Implementation Support]_
, the default _VariableResolver_ will be at the end of the
_VariableResolver_ chain (See _link:JSF.html#a3020[See
VariableResolver and the Default VariableResolver]_ ), if each custom
_VariableResolver_ chose to honor the full decorator pattern. If the
custom _VariableResolver_ chose not to honor the decorator pattern, the
user is stating that they want to take over complete control of the
variable resolution system. Note that the head of the _VariableResolver_
chain is no longer accessible by calling
_Application.getVariableResolver()_ (Please see
_link:JSF.html#a4171[See VariableResolver Property]_ for what it
returns). The head of the _VariableResolver_ chain is kept in an
implementation specific manner.

The semantics of the ELResolver that
functions as the VariableResolver chain wrapper are described in the
following table.

=== ELResolver that is the VariableResolver Chain Wrapper

[width="100%",cols="50%,50%",options="header",]
|===
|ELResorver method
|implementation requirements
| _getValue_ a|
If base is non-null, return null.

If base is null and property is null, throw
PropertyNotFoundException.

Otherwise, call setPropertyResolved(true) on
the argument ELContext.

Get the ELContext from the FacesContext.

Get the head of the VariableResolver chain
and call resolveVariable(facesContext, property) and return the result.

Catch any exceptions that may be thrown by
resolveVariable(), call setPropertyResolved(false) on the argument
ELContext, and rethrow the exception wrapped in an javax.el.ELException.

| _getType_ a|
If base is null and property is null, throw
PropertyNotFoundException.

return null;

| _setValue_ |If
base is null and property is null throw PropertyNotFoundException.

| _isReadOnly_ a|
If base is null and property is null throw
PropertyNotFoundException.

return false;

| _getFeatureDescriptors_
|return null;

| _getCommonPropertyType_
|If base is null, we return String.class. If
base is non-null, return null;
|===

=== [[a2798]]PropertyResolver Chain Wrapper

This is the means by which _propertyResolver_
instances that have been specified in _<property-resolver>_ elements
inside the application configuration resources are allowed to affect the
EL resolution process. If there are one or more _<property-resolver>_
elements in the application configuration resources, an instance of
_ELResolver_ with the following semantics must be created and added to
the _Faces ELResolver for JSP Pages_ as indicated in the
_link:JSF.html#a2670[See Faces ELResolver for JSP Pages]_ .

By virtue of the decorator pattern described
in _link:JSF.html#a6336[See Delegating Implementation Support]_
, the default _propertyResolver_ will be at the end of the
_propertyResolver_ chain (See, _link:JSF.html#a3025[See
PropertyResolver and the Default PropertyResolver]_ ), if each custom
_propertyResolver_ chose to honor the full decorator pattern. If the
custom _propertyResolver_ chose not to honor the decorator pattern, then
the user is stating that they want to take over complete control of the
_propertyResolution_ system. Note that the head of the
_propertyResolver_ chain is no longer accessible by calling
_Application.getPropertyResolver()_ (Please see
_link:JSF.html#a4163[See PropertyResolver Property]_ for what it
returns). The head of the property resolver chain is kept in an
implementation specific manner.

The semantics of the ELResolver that
functions as the property resolver chain wrapper are described in the
following table.

=== ELResolver that is the PropertyResolver Chain Wrapper

[width="100%",cols="50%,50%",options="header",]
|===
|ELResorver method
|implementation requirements
a|
 _getValue_ ,

getType,

isReadOnly,

setValue

a|
If base or property are null, return null (or
false if the method returns boolean).

Call setPropertyResolved(true) on the
argument ELContext.

Get the ELContext from the FacesContext.

Get the head of the propertyResolver chain.

If base is a List or java language array,
coerce the property to an int and call the corresponding method on the
head of the property resolver chain that takes an int for property,
returning the result (except in the case of setValue()).

Otherwise, call the corresponding method on
the head of the property resolver chain that takes an Object for
property, returning the result (except in the case of setValue()).

If an Exception is thrown by calling the
above methods on the PropertyResolver chain, catch it, call
setPropertyResolved(false) on the argument ELContext, and rethrow the
Exception wrapped (snuggly) in a javax.el.ELException.

| _getFeatureDescriptors_
|return null;

| _getCommonPropertyType_
|If base is null, return null. If base is
non-null, return Object.class.
|===

=== [[a2820]]ELResolvers from Application.addELResolver()

Any such resolvers are considered at this
point in the _Faces ELResolver for JSP Pages_ in the order in which they
were added.

=== [[a2822]]ELResolver for Facelets and Programmatic Access

This section documents the requirements for
the second _ELResolver_ mentioned in _link:JSF.html#a2664[See
ELResolver Instances Provided by Faces]_ , the one that is used for
Facelets and for programmatic expression evaluation from Faces java
code.

The implementation for the _ELResolver for
Programmatic Access_ is described as a set of _ELResolvers_ inside of a
_CompositeELResolver_ instance, but any implementation strategy is
permissible as long as the semantics are preserved. .

{empty}This diagram shows the set of
_ELResolver_ instances that must be added to the _ELResolver for
Programmatic Access_ . This instance must be returned from
_Application.getELResolver()_ and
_FacesContext.getELContext().getELResolver()_ _._ It also shows the
order in which they must be added. [P1-state there are 12 methods in the
below tables that can be tested for assertion. The remainder of the
section is covered by the tests in 5.6.1][P1-end]



=== [[a2827]] _ELResolver_ for Facelets and Programmatic Access



image:SF-27.png[image]

The semantics of each _ELResolver_ are given
below, either in tables that describe what must be done to implement
each particular method on _ELResolver_ , in prose when such a table is
inappropriate, or as a reference to another section where the semantics
are exactly the same.

=== [[a2830]]Implicit Object ELResolver for Facelets and Programmatic Access

This resolver differs from the one in the
link:JSF.html#a2673[See Faces Implicit Object ELResolver For
JSP] in that it must resolve all of the implicit objects, not just
_facesContext_ and _view_

=== [[a2832]]ImplicitObjectELResolver for Programmatic Access

[width="100%",cols="50%,50%",options="header",]
|===
|ELResolver method
|implementation requirements
| _getValue_ a|
If base is non-null, return null.

If base is null and property is null, throw
PropertyNotFoundException.

If base is null and property is a String
equal to _implicitObject_ , call setPropertyResolved(true) on the
argument ELContext and return _result_ , where _implicitObject_ and
_result_ are as follows:



 _implicitObject_ -> _result_

application -> externalContext.getContext()

applicationScope ->
externalContext.getApplicationMap()

cookie ->
externalContext.getRequestCookieMap()

facesContext -> the FacesContext for this
request

{empty}component -> the top of the stack of
UIComponent instances, as pushed via calls to
UIComponent.pushComponentToEL(). See link:JSF.html#a1059[See
Lifecycle Management Methods]

flowScope -> +
facesContext.getApplication().getFlowHandler(). +
getCurrentFlowScope().

cc -> the current composite component
relative to the declaring page in which the expression appears.

flash -> externalContext.getFlash()

header ->
externalContext.getRequestHeaderMap()

headerValues ->
externalContext.getRequestHeaderValuesMap()

initParam ->
externalContext.getInitParameterMap()

param ->
externalContext.getRequestParameterMap()

paramValues ->
externalContext.getRequestParameterValuesMap()

request -> externalContext.getRequest()

requestScope ->
externalContext.getRequestMap()

resource ->
facesContext.getApplication().getResourceHandler()

session -> externalContext.getSession()

sessionScope ->
externalContext.getSessionMap()

view -> facesContext.getViewRoot()

viewScope ->
facesContext.getViewRoot().getViewMap()

resource ->
facesContext.getApplication().getResourceHandler()



If base is null, and property doesn’t match
one of the above _implicitObjects,_ return null.

| _getType_ a|
If base is non-null, return null.

If base is null and property is null, throw
PropertyNotFoundException.

If base is null and property is a String
equal to “application”, “component”, “cc”, “cookie”, “facesContext”,
“header”, “headerValues”, “initParam”, “param”, “paramValues”,
“request”, “resource”, “session”, or “view”, _call
setPropertyResolved(true) on the argument ELContext and return null to
indicate that no types are accepted to setValue() for these attributes_
.

If base is null and property is a String
equal to “requestScope”, “sessionScope”, or “applicationScope”, _call
setPropertyResolved(true) on the argument ELContext and return null._

Otherwise, null;

| _setValue_ a|
If base is non-null, return null.

If base is null and property is null, throw
PropertyNotFoundException.

If base is null and property is a String
equal to

“applicationScope”, “requestScope”,
“sessionScope”, “application”, “component”, “cc”, “cookie”,
“facesContext”, “header”, “headerValues”, “initParam”, “param”,
“paramValues”, “request”, “resource”, “session”, or “view”, _throw
javax.el.PropertyNotWriteableException, since these implicit objects are
read-only_ .

Otherwise return null.

| _isReadOnly_ a|
If base is non-null, return (or false if the
method returns boolean).

If base is null and property is null, throw
PropertyNotFoundException.

If base is null and property is a String
equal to “applicationScope”, “component”, “cc”, “requestScope”,
“sessionScope”, “application”, “cookie”, “facesContext”, “header”,
“headerValues”, “initParam”, “param”, “paramValues”, “request”,
“resource”, “session”, or “view”, _call setPropertyResolved(true) on the
argument ELContext and return true._

Otherwise return null.

| _getFeatureDescriptors_ a|
If base is non-null, return null.

If base is null, return an Iterator
containing 17 java.beans.FeatureDescriptor instances, one for eath of
the following properties: application, component, cc, cookie,
facesContext, header, headerValues, initParam, param, paramValues,
request, resource, session, view, applicationScope, sessionScope, and
requestScope. It is required that all of these FeatureDescriptor
instances set Boolean.TRUE as the value of the
ELResolver.RESOLVABLE_AT_DESIGN_TIME attribute. For the name and short
of FeatureDescriptor, return the implicit object name. The appropriate
Class must be stored as the value of the ELResolver.TYPE attribute as
follows:



implicitObject -> ELResolver.TYPE value

application -> Object.class

applicationScope -> Map.class

component -> UIComponent.class

cc -> UIComponent.class

cookie -> Map.class

facesContext -> FacesContext.class

header -> Map.class

headerValues -> Map.class

initParam -> Map.class

param -> Map.class

paramValues -> Map.class

request -> Object.class

resource -> Object.class

requestScope -> Map.class

session -> Object.class

sessionScope -> Map.class

view -> UIViewRoot.class



The shortDescription must be a suitable
description depending on the implementation. The expert and hidden
properties must be false. The preferred property must be true.

| _getCommonPropertyType_ a|
If base is non-null, return null.

If base is null and return String.class

|===

=== [[a2908]]Composite Component Attributes ELResolver

This ELResolver makes it so expressions that
refer to the attributes of a composite component get correctly
evaluated. For example, the expression _#\{cc.attrs.usernameLabel}_
says, “find the current composite component, call its _getAttributes()_
method, within the returned _Map_ look up the value under the key
“usernameLable”. If the value is a _ValueExpression_ , call _getValue()_
on it and the result is returned as the evaluation of the expression.
Otherwise, if the value is _not_ a _ValueExpression_ the value itself is
returned as the evaluation of the expression.”

=== Composite Component Attributes ELResolver

[width="100%",cols="50%,50%",options="header",]
|===
|ELResolver method
|implementation requirements
| _getValue_ a|
If base is non-null, is an instance of
UIComponent, is a composite component, and property is non-null and is
equal to the string “attrs”, return a Map implementation with the
following characteristics.

Wrap the attributes map of the composite
component and delegate all calls to the composite component attributes
map with the following exceptions:

get(), put(), and containsKey() are required
to be supported.

get(): if the result of calling get() on the
component attributes map is null, and a default value was declared in
the composite component metadata, the value will be a ValueExpression.
Evaluate it and return it. Otherwise, simply return the value from the
component attributes map.

put(): Call getValueExpression() on the
component. If this returns non-null, call setValue() on it, passing the
value argument as the last argument. Otherwise, simply call through to
put on the component attributes map.

containsKey(): If the attributes map contains
the key, return true. Otherwise, if a default value has been declared
for the attribute, return true. Otherwise, return false.

The Map implementation must also implement
the interface

javax.faces.el.CompositeComponentExpressionHolder.

Otherwise, take no action.

| _getType_ |If
the base argument to getType() is not an instance of the composite
component attributes map or the property argument to getType() is not an
instance of java.lang.String, return null. Otherwise, check the top
level component's ValueExpression collection for an expression under the
name given by the property argument to getType(). If the expression
exists, call getType() on the expression. If the property argument to
getType() is not empty, search the composite component's metadata for a
declared type on a <composite:attribute> whose name matches the property
argument to getType(). If the expression and the metadata both yield
results, the metadata takes precedence ONLY if it provides a narrower
result than does the expression, i.e. expression type is assignable from
metadata type. If the metadata result does take precedence, call
ELContext.setPropertyResolved(true). Otherwise, return whichever result
was available, or null.

| _setValue_ |Take
no action.

| _isReadOnly_
|Take no action and return true.

| _getFeatureDescriptors_
|Take no action.

| _getCommonPropertyType_
|Return String.class
|===



=== The CompositeELResolver

As indicated in
_link:JSF.html#a2827[See ELResolver for Facelets and
Programmatic Access]_ , following the ImplicitObjectELResolver, the
semantics obtained by adding a _CompositeELResolver_ must be inserted
here. This _ELResolver_ contains the following _ELResolvers_ , described
in the referenced sections.

 _link:JSF.html#a2771[See ELResolvers
in the application configuration resources]_

 _link:JSF.html#a2773[See
VariableResolver Chain Wrapper]_

 _link:JSF.html#a2798[See
PropertyResolver Chain Wrapper]_

 _link:JSF.html#a2820[See ELResolvers
from Application.addELResolver()]_

=== ManagedBean ELResolver

This resolver has the same semantics as the
one in _link:JSF.html#a2711[See ManagedBean ELResolver]_ .

=== [[a2940]]Resource ELResolver

This resolver is a means by which Resource
instances are encoded into a faces request such that a subsequent faces
resource request from the browser can be satisfied using the
ResourceHandler as described in _link:JSF.html#a746[See
Resource Handling]_ .

=== ResourceELResolver

[width="100%",cols="50%,50%",options="header",]
|===
|ELResorver method
|implementation requirements
| _getValue_ a|
If base and property are not null, and base
is an instance of ResourceHandler (as will be the case with an
expression such as #\{resource[‘ajax.js’]}, perform the following.
(Note: This is possible due to the ImplicitObjectELResolver returning
the ResourceHandler, see link:JSF.html#a2830[See Implicit Object
ELResolver for Facelets and Programmatic Access])

If _property_ does not contain a colon
character ‘:’, treat _property_ as the _resourceName_ and pass
_property_ to _ResourceHandler.createResource(_ _resourceName_ _)_ .

If _property_ contains a single colon
character ‘:’, treat the content before the ‘:’ as the _libraryName_ and
the content after the ‘:’ as the _resourceName_ and pass both to
_ResourceHandler.createResource(_ _resourceName, libraryName)_ . If the
value of _libraryName_ is the literal string “this” (without the
quotes), discover the library name of the current resource (or the
contract name of the current resource, the two are mutually exclusive)
and replace “this” with that library name (or contract name) before
calling _ResourceHandler.createResource()_ . In the case of resource
library contracts, _libraryName_ will actually be the contract name.

If _property_ contains more than one colon
character ‘:’, throw a localized _ELException_ , including _property_ .
__

If one of the above steps results in the
creation of a non-null Resource instance, call
ELContext.setPropertyResolved(true). Call the getRequestPath() method on
the Resource instance, pass the result through
ExternalContext.encodeResourceUrl() and return the result.

| _getType_
|Return null. This resolver only performs
lookups.

| _setValue_ |Take
no action.

| _isReadOnly_
|Return false in all cases.

| _getFeatureDescriptors_
|Return null.

| _getCommonPropertyType_ a|
If base is non-null, return null.

If base is null, return Object.class.

|===



=== [[a2962]]el.ResourceBundleELResolver

This entry in the chain must have the
semantics the same as the class _javax.el.ResourceBundleELResolver_ .
The default implementation just includes an instance of this resolver in
the chain.

=== [[a2964]]ResourceBundle ELResolver for Programmatic Access

This resolver has the same semantics as the
one in link:JSF.html#a2741[See ResourceBundle ELResolver for JSP
Pages].

=== [[a2966]]Stream, StaticField, Map, List, Array, and Bean ELResolvers

These ELResolver instances are provided by
the Unified EL API and must be added in the following order:

{empty}[P1-start_EL_3_0] If running on a
container that supports EL 3.0: The return from
_ExpressionFactory.getStreamELResolver_ ,
_javax.el.StaticFieldELResolver_ . [P1-end_EL_3_0]

 _javax.el.MapELResolver,
javax.el.ListELResolver, javax.el.ArrayELResolver,
javax.el.BeanELResolver_ . These actual ELResolver instances must be
added. It is not compliant to simply add other resolvers that preserve
these semantics.

=== [[a2970]]ScopedAttribute ELResolver

This ELResolver is responsible for doing the
scoped lookup that makes it possible for expressions to pick up anything
stored in the request, session, or application scopes by name.

=== Scoped Attribute ELResolver

[width="100%",cols="50%,50%",options="header",]
|===
|ELResorver method
|implementation requirements
| _getValue_ a|
If base is non-null, return null.

If base is null and property is null, throw
PropertyNotFoundException.

Use the argument property as the key in a
call to externalContext.getRequestMap().get(). If this returns non-null,
call setPropertyResolved(true) on the argument ELContext and return the
value.

Use the argument property as the key in a
call to facesContext.getViewRoot().getViewMap().get() (accounting for
the potential for null returns safely). If this returns non-null, call
setPropertyResolved(true) on the argument ELContext and return the
value.

Use the argument property as the key in a
call to externalContext.getSessionMap().get(). If this returns non-null,
call setPropertyResolved(true) on the argument ELContext and return the
value.

Use the argument property as the key in a
call to externalContext.getApplicationMap().get(). If this returns
non-null, call setPropertyResolved(true) on the argument ELContext and
return the value.

Otherwise call setPropertyResloved(true) and
return null;

| _getType_ a|
If base is non-null, return null.

If base is null and property is null, throw
PropertyNotFoundException.

Otherwise, setPropertyResolved(true) and
return Object.class to indicate that any type is permissable to pass to
a call to setValue().

| _setValue_ a|
If base is non-null, return null.

If base is null and property is null, throw
PropertyNotFoundException.

Consult the Maps for the request, session,
and application, in order, looking for an entry under the key property.
If found, replace that entry with argument value. If not found, call
externalContext.getRequestMap().put(property, value).

Call setPropertyResolved(true) and return;

| _isReadOnly_ a|
If base is false, setPropertyResolved(true)
return false;

Otherwise, return false;

| _getFeatureDescriptors_ a|
If base is non-null, return null.

If base is null, return an Iterator of
java.beans.FeatureDescriptor instances for all attributes in all scopes.
The FeatureDescriptor name and shortName is the name of the scoped
attribute. The actual runtime type of the attribute must be stored as
the value of the ELResolver.TYPE attribute. Boolean.TRUE must be set as
the value of the ELResolver.RESOLVABLE_AT_DESIGN_TIME attribute. The
shortDescription must be a suitable description depending on the
implementation. The expert and hidden properties must be false. The
preferred property must be true.

| _getCommonPropertyType_ a|
If base is non-null, return null.

If base is null return String.class.

|===

=== CDI for EL Resolution

If the any of the managed beans in the
application have the _@javax.faces.annotation.FacesConfig_ annotation,
the ImplicitObjectELResolver from link:JSF.html#a2830[See
Implicit Object ELResolver for Facelets and Programmatic Access] is not
present in the chain. Instead, CDI is used to perform EL resolution in
the same manner is in link:JSF.html#a2832[See
ImplicitObjectELResolver for Programmatic Access] with the following
additional implicit objects:

 _externalContext_

the current _ExternalContext_ from the
current _FacesContext_

=== 

image:SF-25.png[image]

Current Expression Evaluation APIs

=== ELResolver

This class is the Unified EL’s answer to
Faces’s _VariableResolver_ and _PropertyResolver_ . It turns out that
variable resolution can be seen as a special case of property resolution
with the base object being _null_ . Please see
_link:JSF.html#a2634[See ELResolver]_ for more details _._

=== ValueExpression

This class is the Unified EL’s answer to
Faces’s _ValueBinding_ . It is the main object oriented abstraction for
al EL expression that results in a value either being retrieved or set.
Please see Chapter 2 of the Expression Language Specification, Version
2.1.

=== MethodExpression

This class is the Unified EL’s answer to
Faces’s _MethodBinding_ . It is the main object oriented abstraction for
al EL expression that results in a method being invoked. Please see
Chapter 2 of the Expression Language Specification, Version 2.1.

=== Expression Evaluation Exceptions

Four exception classes are defined to report
errors related to the evaluation of value exceptions:

 _javax.el.ELException_ (which extends
_java.lang.Exception_ )—used to report a problem evaluating a value
exception dynamically.

 _MethodNotFoundException_ (which extends
_javax.el.ELException_ )—used to report that a requested public method
does not exist in the context of evaluation of a method expression.

 _javax.el.PropertyNotFoundException_ (which
extends _javax.el.ELException_ )—used to report that a requested
property does not exist in the context of evaluation of a value
expression.

 _javax.el.PropertyNotWriteableException_
(which extends _javax.el.ELException_ )—used to indicate that the
requested property could not be written to when evaluating the
expression.

=== 

image:SF-25.png[image]

Deprecated Expression Evaluation APIs

Applications written for version 1.0 and 1.1
of the Faces specification must continue to run in this version of the
specification. This means deprecated APIs. This section describes the
migration story for these APIs that implementations must follow to allow
1.0 and 1.1 based applications to run.

=== [[a3020]]VariableResolver and the Default VariableResolver

User-provided VariableResolver instances will
still continue to work by virtue of _link:JSF.html#a2773[See
VariableResolver Chain Wrapper]_ . The decorator pattern described in
_link:JSF.html#a6336[See Delegating Implementation Support]_
must be supported. Users wishing to affect EL resolution are advised to
author a custom ELResolver instead. These will get picked up as
specified in _link:JSF.html#a2771[See ELResolvers in the
application configuration resources]_ .

The JSF implementation must provide a default
_VariableResolver_ implementation that gets the _ELContext_ from the
argument _FacesContext_ and calls _setPropertyResolved(false)_
on it

The _VariableResolver_ chain is no longer
accessible from _Application.getVariableResolver()_ . The chain must be
kept in an implementation dependent manner, but accessible to the
ELResolver described in _link:JSF.html#a2773[See
VariableResolver Chain Wrapper]_ .

=== [[a3025]]PropertyResolver and the Default PropertyResolver

User-provided propertyResolver instances will
still continue to work by virtue of _link:JSF.html#a2773[See
VariableResolver Chain Wrapper]_ . The decorator pattern described in
_link:JSF.html#a6336[See Delegating Implementation Support]_
must be supported. Users wishing to affect EL resolution are advised to
author a custom ELResolver instead. These will get picked up as
specified in _link:JSF.html#a2771[See ELResolvers in the
application configuration resources]_ .

The JSF implementation must provide a default
_propertyResolver_ implementation that gets the _ELContext_ from the
argument _FacesContext_ and calls _setPropertyResolved(false)_ on it.

The _PropertyResolver_ chain is no longer
accessible from _Application.getpropertyResolver()_ . The chain must be
kept in an implementation dependent manner, but accessible to to the
ELResolver described in _link:JSF.html#a2798[See
PropertyResolver Chain Wrapper]_ .

=== [[a3029]]ValueBinding

The _ValueBinding_ class encapsulates the
actual evaluation of a value binding. Instances of _ValueBinding_ for
specific references are acquired from the _Application_ instance by
calling the _createValueBinding_ method (see
link:JSF.html#a4179[See Acquiring ValueBinding Instances]).

[width="100%",cols="100%",]
|===
|public Object getValue(FacesContext context)
throws EvaluationException, PropertyNotFoundException;
|===

Evaluate the value binding used to create
this _ValueBinding_ instance, relative to the specified _FacesContext_ ,
and return the referenced value.

[width="100%",cols="100%",]
|===
|public void setValue(FacesContext context,
Object value) throws EvaluationException, PropertyNotFoundException;
|===

Evaluate the value binding used to create
this _ValueBinding_ instance, relative to the specified _FacesContext_ ,
and update the referenced value to the specified new value.

[width="100%",cols="100%",]
|===
|public boolean isReadOnly(FacesContext
context) throws EvaluationException, PropertyNotFoundException;
|===

Evaluate the value binding used to create
this _ValueBinding_ instance, relative to the specified _FacesContext_ ,
and return _true_ if the corresponding property is known to be
immutable. Otherwise, return _false_ .

[width="100%",cols="100%",]
|===
|public Class getType(FacesContext context)
throws EvaluationException, PropertyNotFoundException;
|===

Evaluate the value binding used to create
this _ValueBinding_ instance, relative to the specified _FacesContext_ ,
and return the _Class_ that represents the data type of the referenced
value, if it can be determined. Otherwise, return _null_ .

=== [[a3039]]MethodBinding

The _MethodBinding_ class encapsulates the
actual evaluation of a method binding. Instances of _MethodBinding_ for
specific references are acquired from the _Application_ instance by
calling the _createMethodBinding()_ method. Note that instances of
_MethodBinding_ are immutable, and contain no references to a
_FacesContext_ (which is passed in as a parameter when the reference
binding is evaluated).

[width="100%",cols="100%",]
|===
|public Object invoke(FacesContext context,
Object params[]) throws EvaluationException, MethodNotFoundException;
|===

Evaluate the method binding (see
link:JSF.html#a2403[See MethodExpression Syntax and Semantics])
and call the identified method, passing the specified parameters. Return
any value returned by the invoked method, or return _null_ if the
invoked method is of type _void_ .

[width="100%",cols="100%",]
|===
|public Class getType(FacesContext context)
throws MethodNotFoundException;
|===

Evaluate the method binding (see
link:JSF.html#a2403[See MethodExpression Syntax and Semantics])
and return the _Class_ representing the return type of the identified
method. If this method is of type _void_ , return _null_ instead.

=== Expression Evaluation Exceptions

Four exception classes are defined to report
errors related to the evaluation of value exceptions [Note that these
exceptions are deprecated]:

 _EvaluationException_ (which extends
_FacesException_ )—used to report a problem evaluating a value exception
dynamically.

 _MethodNotFoundException_ (which extends
_EvaluationException_ )—used to report that a requested public method
does not exist in the context of evaluation of a method expression.

 _PropertyNotFoundException_ (which extends
_EvaluationException_ )—used to report that a requested property does
not exist in the context of evaluation of a value expression.

 _ReferenceSyntaxException_ (which extends
_EvaluationException_ )—used to report a syntax error in a value
exception.

=== 

image:SF-25.png[image]

CDI Integration

As of version 2.3 of this specification, JSF
must run in a container that supports CDI version 2.0. This requirement
allows CDI to provide all the functionality of the managed bean facility
from link:JSF.html#a2406[See The Managed Bean Facility] and
link:JSF.html#a2536[See Managed Bean Annotations] but in a
better integrated way with the rest of the Java EE platform. Delegating
these features to CDI allows them to evolve independently of JSF. The
remainder of this section specifies some details of CDI integration
pertinent to JSF.

=== [[a3054]]JSF Objects Valid for @Inject Injection

It must be possible to inject the following
JSF objects into other objects using _@Inject_ .

=== Maps Returned by Various JSF Accessors

The annotations in package
_javax.faces.annotation_ are used to cause _@Inject_ injection of the
corresponding _Map_ into a field. Generics may be used.

=== JSF Objects

It must be possible to _@Inject_ the
following JSF and Java EE objects into CDI beans.

 _javax.faces.application.ResourceHandler_

javax.faces.context.ExternalContext

javax.faces.context.FacesContext

javax.faces.context.Flash

javax.servlet.http. _HttpSession_

=== Support for Injection into JSF Managed Objects

It must be possible to use _@Inject_ when
specifying the following kinds of JSF managed objects.

Validators declared with @
_javax.faces.validator.FacesValidator(managed=”true”)_

Converters declared with @
_javax.faces.convert.FacesConverter(managed=”true”)_

FacesBehaviors declared with @
_javax.faces.component.behavior.FacesBehavior(managed=”true”)_

=== [[a3070]]EL Resolution

The following implicit objects must be
resolved using CDI

application

cc

component

facesContext

flash

flowScope

header

headerValues

initParam

param

paramValues

session

view

viewScope



=== 

image:SF-28.png[image]

Per-Request State Information

image:SF-29.png[image]

During request processing for a JSF page, a
context object is used to represent request-specific information, as
well as provide access to services for the application. This chapter
describes the classes which encapsulate this contextual information.

=== 

image:SF-30.png[image]

[[a3091]]FacesContext

JSF defines the
_javax.faces.context.FacesContext_ abstract base class for representing
all of the contextual information associated with processing an incoming
request, and creating the corresponding response. A _FacesContext_
instance is created by the JSF implementation, prior to beginning the
request processing lifecycle, by a call to the _getFacesContext_ method
of _FacesContextFactory_ , as described in
link:JSF.html#a3366[See FacesContextFactory]. When the request
processing lifecycle has been completed, the JSF implementation will
call the _release_ method, which gives JSF implementations the
opportunity to release any acquired resources, as well as to pool and
recycle _FacesContext_ instances rather than creating new ones for each
request.

=== Application[[a3096]]

[width="100%",cols="100%",]
|===
|public Application getApplication();
|===

{empty}[P1-start-application]The JSF
implementation must ensure that the _Application_ instance for the
current web application is available via this method, as a convenient
alternative to lookup via an _ApplicationFactory_ .[P1-end]

=== Attributes

[width="100%",cols="100%",]
|===
|public Map<Object,Object> getAttributes();
|===

{empty}[P1-start-attributes]Return a mutable
_Map_ representing the attributes associated wth this _FacesContext_
instance. This _Map_ is useful to store attributes that you want to go
out of scope when the Faces lifecycle for the current request ends,
which is not always the same as the request ending, especially in the
case of _Servlet_ filters that are invoked after the Faces lifecycle for
this request completes. Accessing this _Map_ does not cause any events
to fire, as is the case with the other maps: for request, session, and
application scope.[P1-end]

=== [[a3099]]ELContext

[width="100%",cols="100%",]
|===
|public ELContext getELContext();
|===

Return the _ELContext_ instance for this
_FacesContext_ instance. This _ELContext_ instance has the same lifetime
and scope as the _FacesContext_ instance with which it is associated,
and may be created lazily the first time this method is called for a
given _FacesContext_ instance. [P1-start-elcontext]Upon creation of the
ELContext instance, the implementation must take the following action:

Call the
_ELContext.putContext(java.lang.Class, java.lang.Object)_ method on the
instance, passing in _FacesContext.class_ and the _this_ reference for
the _FacesContext_ instance itself.

{empty}If the _Collection_ returned by
_javax.faces.Application.getELContextListeners()_ is non-empty, create
an instance of _ELContextEvent_ and pass it to each _ELContextListener_
instance in the _Collection_ by calling the
_ELContextListener.contextCreated(javax.el.ELContextEvent)_
method.[P1-end]

=== ExternalContext

{empty}It is sometimes necessary to interact
with APIs provided by the containing environment in which the JavaServer
Faces application is running. In most cases this is the servlet API, but
it is also possible for a JavaServer Faces application to run inside of
a portlet. JavaServer Faces provides the _ExternalContext_ abstract
class for this purpose. [P1-start-externalContext]This class must be
implemented along with the _FacesContext_ class, and must be accessible
via the _getExternalContext_ method in _FacesContext_ .[P1-end]

[width="100%",cols="100%",]
|===
|public ExternalContext getExternalContext();
|===

{empty}[P1-start externalContext during Init]
The default implementation must return a valid value when this method is
called during startup time. See the javadocs for this method for the
complete specification. [P1-end]

The _ExternalContext_ instance provides
immediate access to all of the components defined by the containing
environment (servlet or portlet) within which a JSF-based web
application is deployed. The following table lists the container objects
available from _ExternalContext_ . Note that the Access column refers to
whether the returned object is mutable. None of the properties may be
set through _ExternalContext_ . itself.

[width="100%",cols="25%,25%,25%,25%",options="header",]
|===
|Name |Access
|Type |Description
| _applicationMap_
|RW |
_java.util.Map_ |The application context
attributes for this application.

| _authType_ |RO
| _String_ |The
method used to authenticate the currently logged on user (if any).

| _context_ |RW
| _Object_ |The
application context object for this application.

| _initParameterMap_
|RO |
_java.util.Map_ |The context initialization
parameters for this application

| _remoteUser_ |RO
| _String_ |The
login name of the currently logged in user (if any).

| _request_ |RW
| _Object_ |The
request object for this request.

| _requestContextPath_
|RO | _String_
|The context path for this application.

| _requestCookieMap_
|RO |
_java.util.Map_ |The cookies included with
this request.

| _requestHeaderMap_
|RO |
_java.util.Map_ |The HTTP headers included
with this request (value is a String).

| _requestHeaderValuesMap_
|RO |
_java.util.Map_ |.The HTTP headers included
with this request (value is a String array).

| _requestLocale_
|RW |
_java.util. +
Locale_ |The preferred Locale for this
request.

| _requestLocales_
|RW |
_java.util. +
Iterator_ |The preferred Locales for this
request, in descending order of preference.

| _requestMap_ |RW
| _java.util.Map_
|The request scope attributes for this
request.

| _requestParameterMap_
|RO |
_java.util.Map_ |The request parameters
included in this request (value is a String).

| _requestParameterNames_
|RO | _Iterator_
|The set of request parameter names included
in this request.

| _requestParameterValuesMap_
|RO |
_java.util.Map_ |The request parameters
included in this request (value is a String array).

| _requestPathInfo_
|RO | _String_
|The extra path information from the request
URI for this request.

| _requestServletPath_
|RO | _String_
|The servlet path information from the
request URI for this request.

| _response_ |RW
| _Object_ |The
response object for the current request.

| _sessionMap_ |RW
| _java.util.Map_
|The session scope attributes for this
requestlink:#a9087[5].

| _userPrincipal_
|RO |
_java.security.Principal_ |The Principal
object containing the name of the currently logged on user (if any).
|===

See the JavaDocs for the normative
specification.

=== Flash

The _Flash_ provides a way to pass temporary
objects between the user views generated by the faces lifecycle.
Anything one places in the flash will be exposed to the next view
encountered by the same user session and then cleared out..

[width="100%",cols="25%,25%,25%,25%",options="header",]
|===
|Name |Access
|Type |Description
| _flash_ |R
| _Flash_ |See the
javadocs for the complete specification.
|===



=== ViewRoot

[width="100%",cols="100%",]
|===
a|
public UIViewRoot getViewRoot();



public void setViewRoot(UIViewRoot root);

|===

During the _Restore View_ phase of the
request processing lifecycle, the state management subsystem of the JSF
implementation will identify the component tree (if any) to be used
during the inbound processing phases of the lifecycle, and call
_setViewRoot()_ to establish it.

=== Message Queue

[width="100%",cols="100%",]
|===
|public void addMessage(String clientId,
FacesMessage message);
|===

During the _Apply Request Values_ , _Process
Validations_ , _Update Model Values_ , and _Invoke Application_ phases
of the request processing lifecycle, messages can be queued to either
the component tree as a whole (if _clientId_ is _null_ ), or related to
a specific component based on its client identifier.

[width="100%",cols="100%",]
|===
a|
public Interator<String>
getClientIdsWithMessages();



public Severity getMaximumSeverity();



public Iterator<FacesMessage>
getMessages(String clientId);



public Iterator<FacesMessage> getMessages();

|===

[P1-start-messageQueue]The
_getClientIdsWithMessages()_ method must return an _Iterator_ over the
client identifiers for which at least one _Message_ has been queued.
This method must be implemented so the clientIds are returned in the
order of calls to _addMessage().[P1-end]_ The _getMaximumSeverity()_
method returns the highest severity level on any _Message_ that has been
queued, regardless of whether or not the message is associated with a
specific client identifier or not. The _getMessages(String)_ method
returns an _Iterator_ over queued _Message_ s, either those associated
with the specified client identifier, or those associated with no client
identifier if the parameter is _null_ . The _getMessages()_ method
returns an _Iterator_ over all queued _Messages_ , whether or not they
are associated with a particular client identifier. Both of the
_getMessage()_ variants must be implemented such that the messages are
returned in the order in which they were added via calls to
_addMessage()_ .

For more information about the _Message_
class, see link:JSF.html#a3300[See FacesMessage].

=== RenderKit

[width="100%",cols="100%",]
|===
|public RenderKit getRenderKit();
|===

Return the _RenderKit_ associated with the
render kit identifier in the current _UIViewRoot_ (if any).



=== [[a3198]]ResponseStream and ResponseWriter

[width="100%",cols="100%",]
|===
a|
public ResponseStream getResponseStream();



public void setResponseStream(ResponseStream
responseStream);



public ResponseWriter getResponseWriter();



public void setResponseWriter(ResponseWriter
responseWriter);



public void enableResponseWriting(boolean
enable);

|===

JSF supports output that is generated as
either a byte stream or a character stream. _UIComponent_ s or
_Renderer_ s that wish to create output in a binary format should call
_getResponseStream()_ to acquire a stream capable of binary output.
Correspondingly, _UIComponent_ s or _Renderer_ s that wish to create
output in a character format should call _getResponseWriter()_ to
acquire a writer capable of character output.

Due to restrictions of the underlying servlet
APIs, either binary or character output can be utilized for a particular
response—they may not be mixed.

Please see link:JSF.html#a3871[See
ViewHandler] to learn when _setResponseWriter()_ and
_setResponseStream()_ are called.

The enableResponseWriting method is useful to
enable or disable the writing of content to the current _ResponseWriter_
instance in this FacesContext. [P1-start-enableWriting]If the enable
argument is false, content should not be written to the response if an
attempt is made to use the current _ResponseWriter._

=== Flow Control Methods

[width="100%",cols="100%",]
|===
a|
public void renderResponse();



public void responseComplete();



public boolean getRenderResponse();



public boolean getResponseComplete();

|===

Normally, the phases of the request
processing lifecycle are executed sequentially, as described in
link:JSF.html#a369[See Request Processing Lifecycle].” However,
it is possible for components, event listeners, and validators to affect
this flow by calling one of these methods.

The _renderResponse()_ method signals the JSF
implementation that, at the end of the current phase (in other words,
after all of the processing and event handling normally performed for
this phase is completed), control should be transferred immediately to
the _Render Response_ phase, bypassing any intervening phases that have
not yet been performed. For example, an event listener for a tree
control that was designed to process user interface state changes (such
as expanding or contracting a node) on the server would typically call
this method to cause the current page to be redisplayed, rather than
being processed by the application.

The _responseComplete()_ method, on the other
hand, signals the JSF implementation that the HTTP response for this
request has been completed by some means other than rendering the
component tree, and that the request processing lifecycle for this
request should be terminated when the current phase is complete. For
example, an event listener that decided an HTTP redirect was required
would perform the appropriate actions on the response object (i.e.
calling _ExternalContext.redirect()_ ) and then call this method.

{empty}In some circumstances, it is possible
that both _renderResponse()_ and _responseComplete()_ might have been
called for the request. [P1-start-flowControl]In this case, the JSF
implementation must respect the _responseComplete()_ call (if it was
made) before checking to see if _renderResponse()_ was called.[P1-end]

The _getRenderResponse()_ and
_getResponseComplete()_ methods allow a JSF-based application to
determine whether the renderResponse() or responseComplete() methods,
respectively, have been called already for the current request.

=== [[a3225]]Partial Processing Methods



[width="100%",cols="100%",]
|===
|public PartialViewContext
getPartialViewContext();
|===

{empty}[P1-start-getpartialViewContext]The
getPartialViewContext()method must return an instance of
PartialViewContext either by creating a new instance, or returning an
existing instance from the FacesContext.[P1-end-getpartialViewcontext]

=== [[a3229]]Partial View Context

The PartialViewContext contains the
constants, properties and methods to facilitate partial view processing
and partial view rendering. Refer to
link:JSF.html#a6831[See Partial View
Processing] and link:JSF.html#a6833[See
Partial View Rendering]. Refer to the JavaDocs for the
javax.faces.context.PartialViewContext class for method requirements.

=== [[a3231]]Access To The Current FacesContext Instance

[width="100%",cols="100%",]
|===
a|
public static FacesContext
getCurrentInstance();



protected static void
setCurrentInstance(FacesContext context);

|===

{empty}Under most circumstances, JSF
components, and application objects that access them, are passed a
reference to the _FacesContext_ instance for the current request.
However, in some cases, no such reference is available. The
_getCurrentInstance()_ method may be called by any Java class in the
current web application to retrieve an instance of the _FacesContext_
for this request. [P1-start-currentInstance]The JSF implementation must
ensure that this value is set correctly before _FacesContextFactory_
returns a _FacesContext_ instance, and that the value is maintained in a
thread-safe manner.[P1-end]

{empty}[P1-start facesContextDuringInit] The
default implementation must allow this method to be called during
application startup time, before any requests have been serviced. If
called during application startup time, the instance returned must have
the special properties as specified on the javadocs for
_FacesContext.getCurrentInstance()_ The . [P1-end]

=== [[a3237]]CurrentPhaseId

The default lifecycle implementation is
responsible for setting the _currentPhaseId_ property on the
_FacesContext_ instance for this request, as specified in
link:JSF.html#a401[See Standard Request Processing Lifecycle
Phases]. The following table describes this property.

[width="100%",cols="25%,25%,25%,25%",options="header",]
|===
|Name |Access
|Type |Description
| _currentPhaseId_
|RW | _PhaseId_
|The _PhaseId_ constant for the current phase
of the request processing lifecycle __
|===

=== ExceptionHandler

The _FacesContextFactory_ ensures that each
newly created _FacesContext_ instance is initialized with a fresh
instance of _ExceptionHandler_ , created from _ExceptionHandlerFactory_
.The following table describes this property.

[width="100%",cols="25%,25%,25%,25%",options="header",]
|===
|Name |Access
|Type |Description
| _exceptionHandler_
|RW |
_ExceptionHandler_ |Set by
_FacesContextFactory.getFacesContext()_ , this class is the default
exception handler for any unexpected Exceptions that happen during the
Faces lifecycle. See the Javadocs for _ExceptionHandler_ for details.
|===

Please see link:JSF.html#a6635[See
PhaseListener] for the circumstances under which _ExceptionHandler_ is
used.

=== 

image:SF-30.png[image]

[[a3253]]ExceptionHandler

 _ExceptionHandler_ is the central point for
handling _unexpected_ _Exceptions_ that are thrown during the Faces
lifecycle. The _ExceptionHandler_ must _not_ be notified of any
_Exceptions_ that occur during application startup or shutdown.

Several places in the Faces specification
require an _Exception_ to be thrown as a result of normal lifecycle
processing. [P1-start_expected_exceptions]The following expected
_Exception_ cases must not be handled by the ExceptionHandler.

All cases where a _ValidatorException_ is
specified to be thrown or caught

All cases where a _ConverterException_ is
specified to be thrown or caught

The case when a MissingResourceException is
thrown during the processing of the _<f:loadBundle />_ tag.

If an exception is thrown when the runtime is
processing the _@PreDestroy_ annotation on a managed bean.

All classes when an
_AbortProcessingException_ is thrown.

All other _Exception_ cases must not be
swallowed, and must be allowed to flow up to the _Lifecycle.execute_ ()
method where the individual lifecycle phases are implemented.
[P1-end_expected_exceptions] At that point, all _Exceptions_ are passed
to the _ExceptionHandler_ as described in
link:JSF.html#a6635[See PhaseListener].

Any code that is not a part of the core Faces
implementation may leverage the _ExceptionHandler_ in one of two ways.

=== Default ExceptionHandler implementation

The default ExceptionHandler must implement
the following behavior for each of its methods

[width="100%",cols="100%",]
|===
|public ExceptionQueuedEvent
getHandledExceptionEvent();
|===

Return the first “handled”
_ExceptionQueuedEvent_ , that is, the one that was actually re-thrown.

[width="100%",cols="100%",]
|===
|public Iterable<ExceptionQueuedEvent>
getHandledExceptionEvents();
|===

The default implementation must return an
_Iterable_ over all _ExceptionEvents_ that have been handled by the
_handle()_ method.

[width="100%",cols="100%",]
|===
|public Throwable getRootCause(Throwable t);
|===

Unwrap the argument _t_ until the unwrapping
encounters an _Object_ whose _getClass()_ is not equal to
_FacesException.class_ or _javax.el.ELException.class_ . If there is no
root cause, _null_ is returned.

[width="100%",cols="100%",]
|===
|public Iterable<ExceptionQueuedEvent>
getUnhandledExceptionEvents();
|===

Return an _Iterable_ over all
_ExceptionEvents_ that have not yet been handled by the _handle()_
method.

[width="100%",cols="100%",]
|===
|public void handle() throws FacesException;
|===

Inspect all unhandled _ExceptionQueuedEvent_
instances in the order in which they were queued by calls to
_Application.publishEvent(ExceptionQueuedEvent.class, eventContext)_ .

For each _ExceptionQueuedEvent_ in the list,
call its _getContext()_ method and call _getException()_ on the returned
result. Upon encountering the first such _Exception_ the corresponding
_ExceptionQueuedEvent_ must be set so that a subsequent call to
_getHandledExceptionEvent()_ or _getHandledExceptionEvents()_ returns
that _ExceptionQueuedEvent_ instance. The implementation must also
ensure that subsequent calls to _getUnhandledExceptionEvents()_ do not
include that _ExceptionQueuedEvent_ instance. Let _toRethrow_ be either
the result of calling _getRootCause()_ on the _Exception_ , or the
_Exception_ itself, whichever is non- _null_ . Re-wrap _toThrow_ in a
_ServletException_ or ( _PortletException_ , if in a portlet
environment) and throw it, allowing it to be handled by any
_<error-page>_ declared in the web application deployment descriptor or
by the default error page as described elsewhere in this section.

There are two exceptions to the above
processing rules. In both cases, the _Exception_ must be logged and not
re-thrown.

If an unchecked _Exception_ occurs as a
result of calling a method annotated with _PreDestroy_ on a managed
bean.

If the _Exception_ originates inside the
_ELContextListener.removeElContextListener()_ method __

The _FacesException_ must be thrown if and
only if a problem occurs while performing the algorithm to handle the
_Exception_ , not as a means of conveying a handled Exception itself.

[width="100%",cols="100%",]
|===
|public boolean isListenerForSource(Object
source);
|===

The default implementation must return _true_
if and only if the source argument is an instance of
_ExceptionEventContext_ .

[width="100%",cols="100%",]
|===
|public void processEvent(SystemEvent
ExceptionQueuedEvent) throws AbortProcessingException;
|===

The default implementation must store the
argument _ExceptionQueuedEvent_ in a strongly ordered queue for later
processing by the _handle()_ method. __

=== Backwards Compatible ExceptionHandler

[P1-startPreJsf2ExceptionHandler]The runtime
must provide an _ExceptionHandlerFactory_ implementation with the fully
qualified java classname of
_javax.faces.webapp.PreJsf2ExceptionHandlerFactory_ that creates
_ExceptionHandler_ instances that behave exactly like the default
_ExceptionHandler_ except that the _handle()_ method behaves as follows.

Versions of JSF prior to 2.0 stated in
link:JSF.html#a6635[See PhaseListener] “Any exceptions thrown
during the _beforePhase()_ listeners must be caught, logged, and
swallowed...Any exceptions thrown during the _afterPhase()_ liseteners
must be caught, logged, and swallowed.” The _PreJsf2ExceptionHandler_
restores this behavior for backwards compatibilty.

{empty}The implementation must allow users to
install this _ExceptionHandlerFactory_ into the application by nesting
_<exception-handler-factory>javax.faces.webapp.PreJsf2ExceptionHandlerFactory</exception-handler-factory>_
inside the <factory> element in the application configuration
resource.[P1-endPreJsf2ExceptionHandler]

=== Default Error Page

If no _<error-page>_ elements are declared in
the web application deployment descriptor, the runtime must provide a
default error page that contains the following information.

The stack trace of the _Exception_

The _UIComponent_ tree at the time the
_ExceptionQueuedEvent_ was handled.

All scoped variables in request, view,
session and application scope.

If the error happens during the execution of
the view declaration language page (VDL)

The physical file being traversed at the time
the _Exception_ was thrown, such as _/user.xhtml_

The line number within that physical file at
the time the _Exception_ was thrown

Any available error message(s) from the VDL
page, such as: “The prefix "foz" for element "foz:bear" is not bound.”

The viewId at the time the
_ExceptionQueuedEvent_ was handled

If _Application.getProjectStage()_ returns
_ProjectStage.Development_ , the runtime must guarantee that the above
debug information is available to be included in any Facelet based error
page using the _<ui:include />_ with a _src_ attribute equal to the
string “ _javax.faces.error.xhtml_ ”.

=== 

image:SF-30.png[image]

[[a3300]]FacesMessage

Each message queued within a _FacesContext_
is an instance of the _javax.faces.application.FacesMessage_ class. The
presence of one or more _FacesMessage_ instances on the _FacesContext_
indicates a failure of some kind during the lifecycle. In particular, a
validation or conversion failure is required to cause a _FacesMessage_
to be added to the _FacesContext_ . __

It offers the following constructors:

[width="100%",cols="100%",]
|===
a|
public FacesMessage();



public FacesMessage(String summary, String
detail);



public FacesMessage(Severity severity, String
summary, String detail);

|===

The following method signatures are supported
to retrieve and set the properties of the completed message:

[width="100%",cols="100%",]
|===
a|
public String getDetail();

public void setDetail(String detail);



public Severity getSeverity();

public void setSeverity(Severity severity);



public String getSummary();

public void setSummary(String summary);

|===

The message properties are defined as
follows:

 _detail_ —Localized detail text for this
_FacesMessage_ (if any). This will generally be additional text that can
help the user understand the context of the problem being reported by
this _FacesMessage_ , and offer suggestions for correcting it.

 _severity_ —A value defining how serious the
problem being reported by this _FacesMessage_ instance should be
considered. Four standard severity values ( _SEVERITY_INFO_ ,
_SEVERITY_WARN_ , _SEVERITY_ERROR_ , and _SEVERITY_FATAL_ ) are defined
as a typesafe enum in the _FacesMessage_ class.

 _summary_ —Localized summary text for this
_FacesMessage_ . This is normally a relatively short message that
concisely describes the nature of the problem being reported by this
_FacesMessage_ .

=== 

image:SF-30.png[image]

ResponseStream

 _ResponseStream_ is an abstract class
representing a binary output stream for the current response. It has
exactly the same method signatures as the _java.io.OutputStream_ class.

=== 

image:SF-30.png[image]

[[a3324]]ResponseWriter

 _ResponseWriter_ is an abstract class
representing a character output stream for the current response. A
_ResponseWriter_ instance is obtained via a factory method on
_RenderKit._ Please see link:JSF.html#a4223[See RenderKit]”. It
supports both low-level and high level APIs for writing character based
information

[width="100%",cols="100%",]
|===
a|
public void close() throws IOException;



public void flush() throws IOException;



public void write(char c[]) throws
IOException;



public void write(char c[], int off, int len)
throws IOException;



public void write(int c) throws IOException;



public void write(String s) throws
IOException;



public void write(String s, int off, int len)
throws IOException;

|===

The _ResponseWriter_ class extends
_java.io.Writer_ , and therefore inherits these method signatures for
low-level output. The _close()_ method flushes the underlying output
writer, and causes any further attempts to output characters to throw an
_IOException_ . The _flush_ method flushes any buffered information to
the underlying output writer, and commits the response. The _write_
methods write raw characters directly to the output writer.

[width="100%",cols="100%",]
|===
a|
public abstract String getContentType();

public abstract String
getCharacterEncoding();

|===

Return the content type or character encoding
used to create this ResponseWriter.

[width="100%",cols="100%",]
|===
a|
public void startCDATA();

public void endCDATA();

|===

Start and end an XML CDATA Section..

[width="100%",cols="100%",]
|===
a|
public void startDocument() throws
IOException;

public void endDocument() throws IOException;

|===

Write appropriate characters at the beginning
( _startDocument_ ) or end ( _endDocument_ ) of the current response.

[width="100%",cols="100%",]
|===
|public void startElement(String name,
UIComponent componentForElement) throws IOException;
|===

Write the beginning of a markup element (the
_<_ character followed by the element name), which causes the
_ResponseWriter_ implementation to note internally that the element is
open. This can be followed by zero or more calls to _writeAttribute_ or
_writeURIAttribute_ to append an attribute name and value to the
currently open element. The element will be closed (i.e. the trailing
_>_ added) on any subsequent call to _startElement_ (), _writeComment_
(), _writeText_ (), _endDocument_ (), _close()_ , _flush()_ , or
_write()_ . The _componentForElement_ parameter tells the
_ResponseWriter_ which _UIComponent_ this element corresponds to, if
any. This parameter may be null to indicate that the element has no
corresponding component. The presence of this parameter allows tools to
provide their own implementation of _ResponseWriter_ to allow the design
time environment to know which component corresponds to which piece of
markup.

[width="100%",cols="100%",]
|===
|public void endElement(String name) throws
IOException;
|===

Write a closing for the specified element,
closing any currently opened element first if necessary.

[width="100%",cols="100%",]
|===
|public void writeComment(Object comment)
throws IOException;
|===

Write a comment string wrapped in appropriate
comment delimiters, after converting the comment object to a _String_
first. Any currently opened element is closed first.

[width="100%",cols="100%",]
|===
a|
public void writeAttribute(String name,
Object value, String componentPropertyName) throws IOException;



public void writeURIAttribute(String name,
Object value, String componentPropertyName) throws IOException;

|===

These methods add an attribute name/value
pair to an element that was opened with a previous call to
_startElement()_ , throwing an exception if there is no currently open
element. The _writeAttribute()_ method causes character encoding to be
performed in the same manner as that performed by the _writeText()_
methods. The _writeURIAttribute()_ method assumes that the attribute
value is a URI, and performs URI encoding (such as _%_ encoding for
HTML). The _componentPropertyName_ , if present, denotes the property on
the associated _UIComponent_ for this element, to which this attribute
corresponds. The _componentPropertyName_ parameter may be null to
indicate that this attribute has no corresponding property.

[width="100%",cols="100%",]
|===
a|
public void writeText(Object text, String
property) throws IOException;



public void writeText(char text[], int off,
int len) throws IOException;

|===

Write text (converting from _Object_ to
_String_ first, if necessary), performing appropriate character encoding
and escaping. Any currently open element created by a call to
_startElement_ is closed first.

[width="100%",cols="100%",]
|===
|public abstract ResponseWriter
cloneWithWriter(Writer writer);
|===

Creates a new instance of this
_ResponseWriter_ , using a different _Writer_ .

=== 

image:SF-30.png[image]

[[a3366]]FacesContextFactory

[P1-start-facesContextFactory]A single
instance of _javax.faces.context.FacesContextFactory_ must be made
available to each JSF-based web application running in a servlet or
portlet container.[P1-end] This class is primarily of use by JSF
implementors—applications will not generally call it directly. The
factory instance can be acquired, by JSF implementations or by
application code, by executing:

[width="100%",cols="100%",]
|===
a|
FacesContextFactory factory =

(FacesContextFactory)

FactoryFinder.getFactory(FactoryFinder.FACES_CONTEXT_FACTORY);

|===

pThe _FacesContextFactory_ implementation
class provides the following method signature to create (or recycle from
a pool) a _FacesContext_ instance:

[width="100%",cols="100%",]
|===
|public FacesContext getFacesContext(Object
context, Object request, Object response, Lifecycle lifecycle);
|===

Create (if necessary) and return a
_FacesContext_ instance that has been configured based on the specified
parameters. In a servlet environment, the first argument is a
_ServletContext_ , the second a _ServletRequest_ and the third a
_ServletResponse_ .

=== 

image:SF-30.png[image]

[[a3375]]ExceptionHandlerFactory

[P1-start-exceptionHandlerFactory]A single
instance of _javax.faces.context.ExceptionHandlerFactory_ must be made
available to each JSF-based web application running in a servlet or
portlet container.[P1-end] The factory instance can be acquired, by JSF
implementations or by application code, by executing:

[width="100%",cols="100%",]
|===
a|
ExceptionHandlerFactory factory =

(ExceptionHandlerFactory)

FactoryFinder.getFactory(FactoryFinder.EXCEPTION_HANDLER_FACTORY);

|===

The _ExceptionHandlerFactory_ implementation
class provides the following method signature to create an
_ExceptionHandler_ instance:

[width="100%",cols="100%",]
|===
|public ExceptionHandler
getExceptionHandler(FacesContext currentContext);
|===

Create and return a _ExceptionHandler_
instance that has been configured based on the specified parameters.

=== 

image:SF-30.png[image]

[[a3384]]ExternalContextFactory

[P1-start-externalContextFactory]A single
instance of _javax.faces.context.ExternalContextFactory_ must be made
available to each JSF-based web application running in a servlet or
portlet container.[P1-end] This class is primarily of use by JSF
implementors—applications will not generally call it directly. The
factory instance can be acquired, by JSF implementations or by
application code, by executing:

[width="100%",cols="100%",]
|===
a|
ExternalContextFactory factory =

(ExternalContextFactory)

FactoryFinder.getFactory(FactoryFinder.EXTERNAL_CONTEXT_FACTORY);

|===

pThe _ExternalContextFactory_ implementation
class provides the following method signature to create (or recycle from
a pool) a _FacesContext_ instance:

[width="100%",cols="100%",]
|===
|public ExternalContext
getExternalContext(Object context, Object request, Object response);
|===

Create (if necessary) and return an
_ExternalContext_ instance that has been configured based on the
specified parameters. In a servlet environment, the first argument is a
_ServletContext_ , the second a _ServletRequest_ and the third a
_ServletResponse_ .







=== 

image:SF-31.png[image]

Application Integration

image:SF-32.png[image]

Previous chapters of this specification have
described the component model, request state information, and the next
chapter describes the rendering model for JavaServer Faces user
interface components. This chapter describes APIs that are used to link
an application’s business logic objects, as well as convenient pluggable
mechanisms to manage the execution of an application that is based on
JavaServer Faces. These classes are in the _javax.faces.application_
package.

Access to application related information is
centralized in an instance of the _Application_ class, of which there is
a single instance per application based on JavaServer Faces.
Applications will typically provide one or more implementations of
_ActionListener_ (or a method that can be referenced by an _action_
expression) in order to respond to _ActionEvent_ events during the
_Apply Request Values_ or _Invoke Application_ phases of the request
processing lifecycle. Finally, a standard implementation of
_NavigationHandler_ (replaceable by the application or framework) is
provided to manage the selection of the next view to be rendered.

=== 

image:SF-33.png[image]

[[a3400]]Application

There must be a single instance of
_Application_ per web application that is utilizing JavaServer Faces. It
can be acquired by calling the _getApplication()_ method on the
_FacesContext_ instance for the current request, or the
_getApplication()_ method of the _ApplicationFactory_ (see
link:JSF.html#a3542[See ApplicationFactory]), and provides
default implementations of features that determine how application logic
interacts with the JSF implementation. Advanced applications (or
application frameworks) can install replacements for these default
implementations, which will be used from that point on. Access to
several integration objects is available via JavaBeans property getters
and setters, as described in the following subsections.

=== [[a3402]]ActionListener Property

[width="100%",cols="100%",]
|===
a|
public ActionListener getActionListener();



public void setActionListener(ActionListener
listener);

|===

Return or replace an _ActionListener_
instance that will be utilized to process _ActionEvent_ events during
the _Apply Request Values_ or _Invoke Application_ phase of the request
processing lifecycle. [P1-start default ActionListener requirements] The
JSF implementation must provide a default implementation
_ActionListener_ that performs the following functions:

The _processAction()_ method must first call
_FacesContext.renderResponse()_ in order to bypass any intervening
lifecycle phases, once the method returns.

The _processAction()_ method must next
determine the logical outcome of this event, as follows:

If the originating component has a non-null
_action_ property, retrieve the _MethodBinding_ and call _invoke()_ to
perform the application-specified processing in this action method. If
the method returns non- _null_ , call _toString()_ on the result and use
the value returned as the logical outcome. See
link:JSF.html#a1092[See Properties] for a decription of the
_action_ property.

Otherwise, the logical outcome is _null_ .

{empty}The processAction() method must
finally retrieve the _NavigationHandler_ instance for this application,
and pass the logical outcome value (determined above) as a parameter to
the _handleNavigation()_ method of the _NavigationHandler_ instance. If
the originating component has an attribute whose name is equal to the
value of the symbolic constant
_ActionListener.TO_FLOW_DOCUMENT_ID_ATTR_NAME_ , invoke
_handleNavigation(FacesContext, String, String, String)_ passing the
value of the attribute as the last parameter. Otherwise, invoke
_handleNavigation(FacesContext, String, String)_ . In either case, the
first _String_ argument is the expression string of the _fromAction_ and
the second _String_ argument is the logical outcome.[P1-end]

See the Javadocs for getActionListener() for
important backwards compatability information.

=== DefaultRenderKitId Property

[width="100%",cols="100%",]
|===
a|
public String getDefaultRenderKitId();



public void setDefaultRenderKitId(String
defaultRenderKitId);

|===

An application may specify the render kit
identifier of the _RenderKit_ to be used by the _ViewHandler_ to render
views for this application. If not specified, the default render kit
identifier specified by _RenderKitFactory.HTML_BASIC_RENDER_KIT_ will be
used by the default _ViewHandler_ implementation.

[P1-start defaultRenderKit called after
startup] Unless the application has provided a custom _ViewHandler_ that
supports the use of multiple RenderKit instances in the same
application, this method may only be called at application startup,
before any Faces requests have been processed. [P1-end] This is a
limitation of the current Specification, and may be lifted in a future
release.

=== FlowHandler Property

[width="100%",cols="100%",]
|===
a|
public FlowHandler getFlowHandler();



public void setFlowHandler(FlowHandler
handler);

|===

Return or replace the _FlowHandler_ that will
be used by the _NavigationHandler_ to make decisions about navigating
application flow. See link:JSF.html#a3840[See FlowHandler] for
an overview of the flow feature.

[P1-start flowHandler called after startup]
_setFlowHandler()_ may only be called at application startup, before any
Faces requests have been processed. [P1-end] This is a limitation of the
current Specification, and may be lifted in a future release.
_getFlowHandler()_ may be called at any time after application startup.

=== NavigationHandler Property

[width="100%",cols="100%",]
|===
a|
public NavigationHandler
getNavigationHandler();



public void
setNavigationHandler(NavigationHandler handler);

|===

Return or replace the _NavigationHandler_
instance (see link:JSF.html#a3561[See NavigationHandler]) that
will be passed the logical outcome of the application _ActionListener_
as described in the previous subsection. A default implementation must
be provided, with functionality described in
link:JSF.html#a3571[See Default NavigationHandler Algorithm]:

=== StateManager Property

[width="100%",cols="100%",]
|===
a|
public StateManager getStateManager();



public void setStateManager(StateManager
manager);

|===

Return or replace the _StateManager_ instance
that will be utilized during the _Restore View_ and _Render Response_
phases of the request processing lifecycle to manage state persistence
for the components belonging to the current view. A default
implementation must be provided, which operates as described in
link:JSF.html#a4117[See StateManager].

=== [[a3435]]ELResolver Property

[width="100%",cols="100%",]
|===
a|
public ELResolver getELResolver();



public void addELResolver(ELResolver
resolver);

|===

{empty}[N/T-start elresolver test] Return the
ELResolver instance to be used for all EL resolution. This is actually
an instance of javax.el.CompositeELResolver that must contain the
ELResolver instances as specified in _link:JSF.html#a2822[See
ELResolver for Facelets and Programmatic Access]_ . [N/T-end]

{empty}[N/T-start addELResolver ordering]
addELResolver must cause the argument resolver to be added at the end of
the list in the javax.el.CompositeELResolver returned from
getELResolver(). See the diagram in _link:JSF.html#a2822[See
ELResolver for Facelets and Programmatic Access]_ [N/T-end]

=== ELContextListener Property

[width="100%",cols="100%",]
|===
a|
public addELContextListener(ELContextListener
listener);



public void
removeELContextListener(ELContextListener listener);



public ELContextListener[]
getELContextListeners();

|===

addELContextListener() registers an
ELContextListener for the current Faces application. This listener will
be notified on creation of ELContext instances, and it will be called
once per request.

removeELContextListener() removes the
argument listener from the list of ELContextListeners. If listener is
null, no exception is thrown and no action is performed. If listener is
not in the list, no exception is thrown and no action is performed.

getELContextListeners() returns an array
representing the list of listeners added by calls to
addELContextListener().

=== [[a3450]]ViewHandler Property

[width="100%",cols="100%",]
|===
a|
public ViewHandler getViewHandler();



public void setViewHandler(ViewHandler
handler);

|===

{empty}See link:JSF.html#a3871[See
ViewHandler] for the description of the ViewHandler. The JSF
implementation must provide a default _ViewHandler_ implementation. This
implementation may be replaced by calling _setViewHandler()_ before the
first time the _Render Response_ phase has executed. [P1-start
setViewHandler() called after startup] If a call is made to
_setViewHandler()_ after the first time the _Render Response_ phase has
executed, the call must be ignored by the implementation. [P1-end]

=== [[a3455]]ProjectStage Property

[width="100%",cols="100%",]
|===
a|
public ProjectStage getProjectStage();



|===

{empty} [P1-start getProjectStage]This method
must return the enum constant from the class
_javax.faces.application.ProjectStage_ as specified in the corresponding
application init parameter, JNDI entry, or default Value. See
link:JSF.html#a6088[See Application Configuration
Parameters].[P1-end]

=== [[a3459]]Acquiring ExpressionFactory Instance

[width="100%",cols="100%",]
|===
|public ExpressionFactory
getExpressionFactory();
|===

Return the ExpressionFactory instance for
this application. This instance is used by the evaluateExpressionGet (
_link:JSF.html#a3463[See Programmatically Evaluating
Expressions]_ ) convenience method.

{empty}[P1-start getExpressionFactory
requirements] The default implementation simply returns the
ExpressionFactory from the JSP container by calling
JspFactory.getDefaultFactory().getJspApplicationContext(servletContext).getExpressionFactory().
[P1-end]

=== [[a3463]]Programmatically Evaluating Expressions

[width="100%",cols="100%",]
|===
|public Object
evaluateExpressionGet(FacesContext context, String expression, Class
expectedType)
|===

Get a value by evaluating an expression.

Call
_getExpressionFactory().createValueExpression()_ passing the argument
_expression_ and _expectedType_ . Call _FacesContext.getELContext()_ and
pass it to _ValueExpression.getValue()_ , returning the result.

It is also possible and sometimes desireable
to obtain the actual _ValueExpression_ or _MethodExpression_ instance
directly. This can be accomplished by using the
_createValueExpression()_ or _createMethodExpression()_ methods on the
_ExpressionFactory_ returned from _getExpressionFactory()._

=== [[a3468]]Object Factories

The _Application_ instance for a web
application also acts as an object factory for the creation of new JSF
objects such as components, converters, validators and behaviors..

[width="100%",cols="100%",]
|===
a|
public UIComponent createComponent(String
componentType);

public UIComponent createComponent(String
componentType,

 String rendererType);



public Converter createConverter(Class
targetClass);



public Converter createConverter(String
converterId);



public Validator createValidator(String
validatorId);



public Behavior createBehavior(String
behaviorId);

|===

Each of these methods creates a new instance
of an object of the requested typelink:#a9088[6], based on the
requested identifier. The names of the implementation class used for
each identifier is normally provided by the JSF implementation
automatically (for standard classes described in this Specification), or
in one or more application configuration resources (see
link:JSF.html#a6195[See Application Configuration Resources])
included with a JSF web application, or embedded in a JAR file
containing the corresponding implementation classes.

All variants _createConverter()_ must take
some action to inspect the converter for _@ResourceDependency_ and
_@ListenerFor_ annotations.



[width="100%",cols="100%",]
|===
|public UIComponent
createComponent(ValueExpression componentExpression, FacesContext
context, String componentType);
|===

[P1-start createComponent(ValueExpression)
requirements] This method has the following behavior:

Call the _getValue()_ method on the specified
_ValueExpression_ , in the context of the specified _FacesContext_ . If
this results in a non-null _UIComponent_ instance, return it as the
value of this method.

{empty}If the getValue() call did not return
a component instance, create a new component instance of the specified
component type, pass the new component to the s _etValue()_ method of
the specified ValueExpression, and return it.[P1-end]

[width="100%",cols="100%",]
|===
|public UIComponent
createComponent(FacesContext context, Resource componentResource);
|===

All variants _createComponent()_ must take
some action to inspect the component for _@ResourceDependency_ and
_@ListenerFor_ annotations. Please see the JavaDocs and
link:JSF.html#a1671[See Composite Component Metadata] for the
normative specification relating to this method.

[width="100%",cols="100%",]
|===
a|
public void addComponent(String
componentType, String componentClass);



public void addConverter(Class targetClass,
String converterClass);



public void addConverter(String converterId,
String converterClass);



public void addValidator(String validatorId,
String validatorClass);



public void addBehavior(String behaviorId,
String behaviorClass);

|===

JSF-based applications can register
additional mappings of identifiers to a corresponding fully qualified
class name, or replace mappings provided by the JSF implementation in
order to customize the behavior of standard JSF features. These methods
are also used by the JSF implementation to register mappings based on
_<component>_ , _<converter>_ , _<behavior>_ and _<validator>_ elements
discovered in an application configuration resource.

[width="100%",cols="100%",]
|===
a|
public Iterator<String> getComponentTypes();



public Iterator<String> getConverterIds();



public Iterator<Class> getConverterTypes();



public Iterator<String> getValidatorIds();



public Iterator<String> getBehaviorIds();

|===

JSF-based applications can ask the
_Application_ instance for a list of the registered identifiers for
components, converters, and validators that are known to the instance.

=== [[a3510]]Default Validator Ids

From the list of mappings of _validatorId_ to
fully qualified class name, added to the application via calls to
_addValidator()_ , the application maintains a subset of that list under
the heading of default validator ids. The following methods provide
access to the default validator ids registered on an application:

[width="100%",cols="100%",]
|===
a|
 _public void addDefaultValidatorId(String
validatorId);_

public Map<String,String>
getDefaultValidatorInfo();

|===

The required callsites for these methods are
specified in link:JSF.html#a1419[See Validation Registration].

=== Internationalization Support

The following methods and properties allow an
application to describe its supported locales, and to provide
replacement text for standard messages created by JSF objects.

[width="100%",cols="100%",]
|===
a|
public Iterator<Locale>
getSupportedLocales();

public void
setSupportedLocales(Collection<Locale> newLocales);

public Locale getDefaultLocale();

public void setDefaultLocale(Locale
newLocale);

|===

JSF applications may state the _Locale_ s
they support (and the default _Locale_ within the set of supported
_Locale_ s) in the application configuration resources file. The setters
for the following methods must be called when the configuration
resources are parsed. Each time the setter is called, the previous value
is overwritten.

[width="100%",cols="100%",]
|===
a|
public String getMessageBundle();



public void setMessageBundle(String
messageBundle);

|===

Specify the fully qualified name of the
ResourceBundle from which the JSF implementation will acquire message
strings that correspond to standard message keys See
link:JSF.html#a584[See Localized Application Messages] for a
list of the standard message keys recognized by JSF.

=== [[a3526]]System Event Methods

System events are described in
link:JSF.html#a1359[See System Events]. This section describes
the methods defined on _Application_ that support system events

=== Subscribing to system events

[width="100%",cols="100%",]
|===
a|
public abstract void subscribeToEvent(Class<?
extends SystemEvent> systemEventClass, SystemEventListener listener)

public abstract void subscribeToEvent(Class<?
extends SystemEvent> systemEventClass, Class sourceClass,
SystemEventListener listener);

public abstract void publishEvent(Class<?
extends SystemEvent> systemEventClass, SystemEventListenerHolder
source);

public void publishEvent(Class<? extends
SystemEvent> systemEventClass, Class<?> sourceBaseType, Object source)

|===

The first variant of _subscribeToEvent()_
subscribes argument _listener_ to have its _isListenerForSource()_
method, and (depending on the result from _isListenerForSource()_ ) its
_processEvent()_ method called any time any call is made to
_Application.publishEvent(Class<? extends SystemEvent> systemEventClass,
SystemEventListenerHolder source)_ where the first argument in the call
to _publishEvent()_ is equal to the first argument to
_subscribeToEvent()_ . [P1-start eventClassAndInheritance] _NOTE_ : The
implementation must not support subclasses for the _systemEventClass_
and/or _sourceClass_ arguments to _subscribeToEvent()_ or
_publishEvent()_ .[P1-end] For example, consider two event types,
_SuperEvent_ and _SubEvent extends SuperEvent_ . If a listener
subscribes to _SuperEvent.class_ events, but later someone publishes a
_SubEvent.class_ event (which extends _SuperEvent_ ), the listener for
_SuperEvent.class_ must not be called.

The second variant of _subscribeToEvent()_ is
equivalent to the first, with the additional constraint the the
_sourceClass_ argument to _publishEvent()_ must be equal to the _Class_
object obtained by calling _getClass()_ on the _source_ argument to
_publishEvent()_ .

See the javadocs for both variants of
_subscribeForEvent()_ for the complete specification of these methods.

 _publishEvent()_ is called by the system at
several points in time during the runtime of a JSF application. The
specification for when _publishEvent()_ is called is given in the
javadoc for the event classes that are listed in
link:JSF.html#a1308[See Event Classes]. See the javadoc for
_publishEvent()_ for the complete specification.

=== Unsubscribing from system events

[width="100%",cols="100%",]
|===
a|
public abstract void
unsubscribeFromEvent(Class<? extends SystemEvent> systemEventClass,
SystemEventListener listener);

public abstract void
unsubscribeFromEvent(Class<? extends SystemEvent> systemEventClass,
Class sourceClass, SystemEventListener listener);

|===

See the javadocs for both variants of
_unsubscribeFromEvent()_ for the complete specification.

=== 

image:SF-33.png[image]

[[a3542]]ApplicationFactory

A single instance of
_javax.faces.application.ApplicationFactory_ must be made available to
each JSF-based web application running in a servlet or portlet
container. The factory instance can be acquired by JSF implementations
or by application code, by executing:

[width="100%",cols="100%",]
|===
a|
ApplicationFactory factory =
(ApplicationFactory)


FactoryFinder.getFactory(FactoryFinder.APPLICATION_FACTORY);

|===

The _ApplicationFactory_ implementation class
supports the following methods:

[width="100%",cols="100%",]
|===
a|
public Application getApplication();



public void setApplication(Application
application);

|===

Return or replace the _Application_ instance
for the current web application. The JSF implementation must provide a
default _Application_ instance whose behavior is described in
link:JSF.html#a3400[See Application].

Note that applications will generally find it
more convenient to access the _Application_ instance for this
application by calling the _getApplication()_ method on the
_FacesContext_ instance for the current request.

=== 

image:SF-33.png[image]

[[a3553]]Application Actions

An _application action_ is an
application-provided method on some Java class that performs some
application-specified processing when an _ActionEvent_ occurs, during
either the _Apply Request Values_ or the _Invoke Application_ phase of
the request processing lifecycle (depending upon the _immediate_
property of the _ActionSource_ instance initiating the event).

Application action is not a formal JSF API;
instead any method that meets the following requirements may be used as
an Action by virtue of evaluating a method binding expression:

The method must be public.

The method must take no parameters.

The method must return _Object_ .

The action method will be called by the
default _ActionListener_ implementation, as described in
link:JSF.html#a3402[See ActionListener Property] above. Its
responsibility is to perform the desired application actions, and then
return a logical “outcome” (represented as a _String_ ) that can be used
by a _NavigationHandler_ in order to determine which view should be
rendered next. The action method to be invoked is defined by a
_MethodBinding_ that is specified in the _action_ property of a
component that implements _ActionSource_ . Thus, a component tree with
more than one such _ActionSource_ component can specify individual
action methods to be invoked for each activated component, either in the
same Java class or in different Java classes.

=== 

image:SF-33.png[image]

[[a3561]]NavigationHandler

=== [[a3562]]Overview

Most JSF applications can be thought of as a
directed graph of views, each node of which roughly corresponds to the
user’s perception of “location” within the application. Applications
that use the Faces Flows feature have additional kinds of nodes in the
directed graph. In any case, navigating the nodes of this graph is the
responsibility of the _NavigationHandler_ . A single _NavigationHandler_
instance is responsible for consuming the logical outcome returned by an
application action that was invoked, along with additional state
information that is available from the _FacesContext_ instance for the
current request, and (optionally) selecting a new view to be rendered.
If the outcome returned by the applicationaction is _null_ or the empty
string, and none of the navigation cases that map to the current view
identifier have a non-null condition expression, the same view must be
re-displayed. This is a change from the old behavior. As of JSF 2.0, the
NavigationHandler is consulted even on a _null_ outcome, but under this
circumstance it only checks navigation cases that do not specify an
outcome (no <from-outcome>) and have a condition expression (specified
with <if>). This is the only case where the same view (and component
tree) is re-used.

[width="100%",cols="100%",]
|===
|public void handleNavigation(FacesContext
context, String fromAction, String outcome);
|===

The _handleNavigation_ method may select a
new view by calling _createView()_ on the _ViewHandler_ instance for
this application, optionally customizing the created view, and then
selecting it by calling the _setViewRoot()_ method on the _FacesContext_
instance that is passed. Alternatively, the _NavigationHandler_ can
complete the actual response (for example, by issuing an HTTP redirect),
and call _responseComplete()_ on the _FacesContext_ instance.

After a return from the _handleNavigation_
method, control will normally proceed to the _Render Response_ phase of
the request processing lifecycle (see link:JSF.html#a457[See
Render Response]), which will cause the newly selected view to be
rendered. If the _NavigationHandler_ called the _responseComplete()_
method on the _FacesContext_ instance, however, the _Render Response_
phase will be bypassed.

Prior to JSF 2, the NavigationHandler's sole
task was to execute the navigation for a given scenario. JSF 2
introduces the _ConfigurableNavigationHandler_ interface, which extends
the contract of the _NavigationHandler_ to include two additional
methods that accomodate runtime inspection of the NavigationCases that
represent the rule-based navigation metamodel. The method
_getNavigationCase_ consults the _NavigationHandler_ to determine which
_NavigationCase_ the _handleNavigation_ method would resolve for a given
"from action" expression and logical outcome combination. The method
_getNavigationCases_ returns a java.util.Map of all the _NavigationCase_
instances known to this _NavigationHandler_ . Each key in the map is a
from view ID and the cooresponding value is a java.util.Set of
NavigationCases for that from view ID.

[width="100%",cols="100%",]
|===
a|
public NavigationCase
getNavigationCase(FacesContext context, String fromAction, String
outcome);

public Map<String, Set<NavigationCase>>
getNavigationCases();

|===

{empty}[P1-start-configurablenavhandler]A JSF
2 compliant-implemention must ensure that its _NavigationHandler_
implements the _ConfigurableNavigationHandler_ interface. The
_handleNavigation_ and _getNavigation_ Case methods should use the same
logic to resolve a _NavigationCase_ , which is outlined in the next
section.[P1-end]

=== [[a3571]]Default NavigationHandler Algorithm

JSF implementations must provide a default
_NavigationHandler_ implementation that maps the action reference that
was utilized (by the default _ActionListener_ implementation) to invoke
an application action, the logical outcome value returned by that
application action, as well as other state information, into the view
identifier for the new view or flow node to be selected. The remainder
of this section describes the functionality provided by this default
implementation.

The behavior of the default
_NavigationHandler_ implementation is configured, at web application
startup time, from the contents of zero or more _application
configuration resources_ (see link:JSF.html#a6195[See
Application Configuration Resources]). The configuration information is
represented as zero or more _<navigation-rule>_ elements, each keyed to
a matching pattern for the _view identifier_ of the current view
expressed in a _<from-view-id>_ element. This matching pattern must be
either an exact match for a view identifier (such as “/index.jsp” if you
are using the default _ViewHandler_ ), or the prefix of a component view
id, followed by an asterisk (“*”) character. A matching pattern of “*”,
or the lack of a _<from-view-id>_ element inside a _<navigation-rule>_
rule, indicates that this rule matches any possible component view
identifier.

Version 2.2 of the specification introduced
the Faces Flows feature. [P1-start-FlowNavigationConstraints] With
respect to the navigation algorithm, any text that references a _view
identifier_ , such as _<from-view-id>_ or _<to-view-id>_ , can also
refer to a flow node, subject to these constraints.

When outside of a flow, _view identifier_ has
the additional possibility of being a flow id.

{empty}When inside a flow, a _view
identifier_ has the additional possibility of being the id of any node
within the current flow.[P1-end]

If the specification needs to refer to a
_view identifier_ that is an actual VDL view (and not a VDL view or a
flow, or flow node), the term _vdl view identifier_ will be used.

Nested within each _<navigation-rule>_
element are zero or more _<navigation-case>_ elements that contain
additional matching criteria based on the action reference expression
value used to select an application action to be invoked (if any), and
the logical outcome returned by calling the _invoke()_ method of that
application action _link:#a9089[7]_ . As of JSF 2, navigation
cases support a condition element, <if>, whose content must be a single,
contiguous value expression expected to resolve to a boolean value (if
the content does not match this requirement, the condition is
ignored)link:#a9090[8]. When the <if> element is present, the
value expression it contains must evaluate to true when the navigation
case is being consulted in order for the navigation case to
matchlink:#a9092[9]. Finally, the <navigation-case> element
contains a <to-view-id> element, whose content is either the view
identifier or a value expression that resolves to the view identifier.
If the navigation case is a match, this view identifier is to be
selected and stored in the FacesContext for the current request
following the invocation of the NavigationHandler. See below for an
example of the configuration information for the default
_NavigationHandler_ might be configured.

It is permissible for the application
configuration resource(s) used to configure the default
_NavigationHandler_ to include more than one _<navigation-rule>_ element
with the same _<from-view-id>_ matching pattern. For the purposes of the
algorithm described below, all of the nested _<navigation-case>_
elements for all of these rules shall be treated as if they had been
nested inside a single _<navigation-rule>_ element.

[P1-start navigation handler requirements]
The default _NavigationHandler_ implementation must behave as if it were
performing the following algorithm (although optimized implementation
techniques may be utilized):

If no navigation case is matched by a call to
the handleNavigation() method, this is an indication that the current
view should be redisplayed. As of JSF 2.0, a null outcome does not
unconditionally cause all navigation rules to be skipped.

Find a _<navigation-rule>_ element for which
the view identifier (of the view in the _FacesContext_ instance for the
current request) matches the _<from-view-id>_ matching pattern of the
_<navigation-rule>_ . Rule instances are considered in the following
order:

An exact match of the view identifier against
a _<from-view-id>_ pattern that does not end with an asterisk (“*”)
character.

For _<from-view-id>_ patterns that end with
an asterisk, an exact match on characters preceding the asterisk against
the prefix of the view id. If the patterns for multiple navigation rules
match, pick the longest matching prefix first.

If there is a _<navigation-rule>_ with a
_<from-view-id>_ pattern of only an asterisklink:#a9093[10], it
matches any view identifier.

From the _<navigation-case>_ elements nested
within the matching _<navigation-rule>_ element, locate a matching
navigation case by matching the _<from-action>_ and _<from-outcome>_
values against the _fromAction_ and outcome parameter values passed to
the _handleNavigation()_ method. To match an outcome value of null, the
_<from-outcome>_ must be absent and the _<if>_ element present.
Regardless of outcome value, if the _<if>_ element is present, evaluate
the content of this element as a value expression and only select the
navigation case if the expression resolves to true. Navigation cases are
checked in the following order:

Cases specifying both a _<from-action>_ value
and a _<from-outcome>_ value are matched against the _action_ expression
and _outcome_ parameters passed to the _handleNavigation()_ method (both
parameters must be not null, and both must be equal to the corresponding
condition values, in order to match).

Cases that specify only a _<from-outcome>_
value are matched against the _outcome_ parameter passed to the
_handleNavigation()_ method (which must be not null, and equal to the
corresponding condition value, to match).

Cases that specify only a _<from-action>_
value are matched against the _action_ expression parameter passed to
the _handleNavigation()_ method (which must be non-null, and equal to
the corresponding condition value, to match; if the <if> element is
absent, only match a non-null outcome; otherwise, match any outcome).

Any remaining case is assumed to match so
long as the outcome parameter is non-null or the <if> element is
present.

For cases that match up to this point and
contain an <if> element, the condition value expression must be
evaluated and the resolved value true for the case to match.

If a matching _<navigation-case>_ element was
located, proceed as follows.

{empty}If the _<to-view-id>_ element is the
id of a flow, discover that flow’s start node and resolve it to a _vdl
view identifier_ by following the algorithm in
link:JSF.html#a3622[See Requirements for Explicit Navigation in
Faces Flow Call Nodes other than ViewNodes]

If the _<to-view-id>_ element is a non-view
flow node, resolve it to a _vdl view identifier_ by following the
algorithm in link:JSF.html#a3622[See Requirements for Explicit
Navigation in Faces Flow Call Nodes other than ViewNodes].

If _UIViewAction.isProcessingBroadcast()_
returns _true_ , call _getFlash().setKeepMessages(true)_ on the current
_FacesContext_ . Compare the viewId of the current viewRoot with the
_<to-view-id>_ of the matching _<navigation-case>_ . If they differ,
take any necessary actions to effectively restart the JSF lifecycle on
the _<to-view-id>_ of the matching _<navigation-case>_ . Care must be
taken to preserve any view parameters or navigation case parameters,
clear the view map of the _UIViewRoot_ , and call _setRenderAll(true)_
on the _PartialViewContext_ . Implementations may choose to meet this
requirement by treating this case as if a _<redirect />_ was specified
on the matching _<navigation-case>_ . If the viewIds do not differ,
continue on to the next bullet point.

Clear the view map if the viewId of the new
_UIViewRoot_ differs from the viewId of the current _UIViewRoot_ .

If the _<redirect/>_ element was _not_
specified in this _<navigation-case>_ (or the application is running in
a Portlet environment, where redirects are not possible), use the
_<to-view-id>_ element of the matching case to request a new
_UIViewRoot_ instance from the _ViewHandler_ instance for this
application. Call _transition()_ on the _FlowHandler_ , passing the
current _FacesContext_ , the current flow, the new flow and the
_facesFlowCallNode_ corresponding to this faces flow call, if any. Pass
the new _UIViewRoot_ to the _setViewRoot()_ method of the _FacesContext_
instance for the current request.

Then, exit the algorithm. If the content of
<to-view-id> is a value expression, first evaluate it to obtain the
value of the view id.

If the _<redirect/>_ element _was_ specified
in this _<navigation-case>_ , or this invocation of _handleNavigation()_
was due to a _UIViewAction_ broadcast event where the new _viewId_ is
different from the current _viewId_ , resolve the _<to-view-id>_ to a
view identifier, using the algorithm in _link:JSF.html#a3622[See
Requirements for Explicit Navigation in Faces Flow Call Nodes other than
ViewNodes]_ . Call _getRedirectURL()_ on the _ViewHandler_ , passing the
current _FacesContext_ , the _<to-view-id>_ , any name=value parameter
pairs specified within _<view-param>_ elements within the _<redirect>_
element, and the value of the _include-view-params_ attribute of the
_<redirect />_ element if present, _false_ , if not. If this navigation
is a flow transition (where current flow is not the same as the new
flow), include the relevant flow metadata as entries in the _parameters_
.

If current flow is not null and new flow is
null, include the following entries:
_FlowHandler.TO_FLOW_DOCUMENT_ID_REQUEST_PARAM_NAME:
FlowHandler.NULL_FLOW +
FlowHandler.FLOW_ID_REQUEST_PARAM_NAME: “”_ (the empty string)

If current flow is null and new flow is not
null, include the following entries: +
_FlowHandler.TO_FLOW_DOCUMENT_ID_REQUEST_PARAM_NAME:_ The to flow
document id +
_FlowHandler.FLOW_ID_REQUEST_PARAM_NAME:_ the flow id for the flow that
is the destination of the transition.

If the _parameters_ map has entries for
either of these keys, both of the entries must be replaced with the new
values. This allows the call to _FlowHandler.clientWindowTransition()_
to perform correctly when the GET request after the redirect happens.

The return from _getRedirectURL()_ is the
value to be sent to the client to which the redirect will occur. Call
_getFlash().setRedirect(true)_ on the current _FacesContext_ . Cause the
current response to perform an HTTP redirect to this path, and call
_responseComplete()_ on the _FacesContext_ instance for the current
request. If the content of <to-view-id> is a value expression, first
evaluate it to obtain the value of the view id.

If no matching _<navigation-case>_ element
was located, return to Step 1 and find the next matching
_<navigation-rule>_ element (if any). If there are no more matching rule
elements, execute the following algorithm to search for an implicit
match based on the current _outcome_ . This implicit matching algorithm
also includes navigating within the current faces flow, and returning
from the current faces flow.

Let _outcome_ be _viewIdToTest_ .

Examine the _viewIdToTest_ for the presence
of a “?” character, indicating the presence of a URI query string. If
one is found, remove the query string from _viewIdToTest_ , including
the leading “ _?_ ” and let it be _queryString_ , look for the string “
_faces-redirect=true_ ” within the query string. If found, let
_isRedirect_ be _true_ , otherwise let _isRedirect_ be _false_ . Look
for the string “ _includeViewParams=true_ ” or “
_faces-include-view-params=true_ ”. If either are found, let
_includeViewParams_ be _true_ , otherwise let _includeViewParams_ be
_false_ . When performing preemptive navigation, redirect is implied,
even if the navigation case doesn't indicate it, and the query string
must be preserved. Refer to link:JSF.html#a2060[See
UIOutcomeTarget] for more information on preemptive navigation.

If _viewIdToTest_ does not have a “file
extension”, take the file extension from the current _viewId_ and append
it properly to _viewIdToTest_ .

If _viewIdToTest_ does not begin with “/”,
take the current _viewId_ and look for the last “ _/_ ”. If not found,
prepend a “ _/_ ” and continue. Otherwise remove all characters in
_viewId_ after, but not including, “ _/_ ”, then append _viewIdToTest_
and let the result be _viewIdToTest_ .

Obtain the current ViewHandler and call its
_deriveViewId()_ method, passing the current _FacesContext_ and
_viewIdToTest_ . If _UnsupportedOperationException_ is thrown, which
will be the case if the _ViewHandler_ is a Pre JSF 2.0 _ViewHandler_ ,
the implementation must ensure the algorithm described for
_ViewHandler.deriveViewId()_ specified in
_link:JSF.html#a3910[See Default ViewHandler Implementation]_ is
performed. Let the result be _implicitViewId_ .

If _implicitViewId_ is non- _null_ , discover
if _fromOutcome_ is equal to the flow-id of an existing flow in the
_FlowHandler_ . If so find the start node of the flow. If the start node
is a _ViewNode_ , let _viewIdToTest_ be the _vdlDocumentId_ value of the
_ViewNode_ . Call _deriveViewId_ as in the preceding step and let the
result be _implicitViewId_ . If _fromOutcome_ is not equal to the
flow-id of an existing flow in the _FlowHandler_ , and we are currently
in a flow, discover if this is call to a _faces-flow-return_ node. If
so, obtain the _fromOutcome_ of the _faces-flow-return_ node, re-apply
this algorithm to derive the value of the _implicitViewId_ and continue.

If the _implicitViewId_ is non- _null_ , take
the following action. If _isRedirect_ is _true_ , append the
_queryString_ to _implicitViewId_ . Let _implicitNavigationCase_ be a
conceptual _<navigation-case>_ element whose _fromViewId_ is the current
_viewId_ , _fromAction_ is passed through from the arguments to
_handleNavigation()_ , _fromOutcome_ is passed through from the
arguments to _handleNavigation(), toViewId_ is _implicitViewId_ , and
_redirect_ is the value of _isRedirect,_ and _include-view-params_ is
_includeViewParams_ . Treat _implicitNavigationCase_ as a matching
navigation case and return to the first step above that starts with “If
a matching _<navigation-case>_ element was located...”.

If _UIViewAction.isProcessingBroadcast()_
returns _true_ , call _getFlash().setKeepMessages(true)_ on the current
_FacesContext_ . Compare the viewId of the current viewRoot with the
effective _<to-view-id>_ of the matching _<navigation-case>_ . If they
differ, take any necessary actions effectively restart the JSF lifecycle
on the effective _<to-view-id>_ of the matching _<navigation-case>_ .
Care must be taken to preserve any view parameters or navigation case
parameters, clear the view map of the _UIViewRoot_ , and call
_setRenderAll(true)_ on the _PartialViewContext_ .

If none of the above steps found a matching
_<navigation-case>_ , perform the steps in
link:JSF.html#a3622[See Requirements for Explicit Navigation in
Faces Flow Call Nodes other than ViewNodes] to find a matching
_<navigation-case>_ .

If none of the above steps found a matching
_<navigation-case>_ , if _ProjectStage_ is not _Production_ render a
message in the page that explains that there was no match for this
outcome.

A rule match always causes a new view to be
created, losing the state of the old view. This includes clearing out
the view map.

Query string parameters may be contributed by
three different sources: the outcome (implicit navigation), a nested
_<f:param>_ on the component tag (e.g., _<h:link>_ , _<h:button>_ ,
_<h:commandLink>_ , _<h:commandButton>_ ), and view parameters. When a
redirect URL is built, whether it be by the N _avigationHandler_ on a
redirect case or a _UIOutcomeTarget_ renderer, the query string
parameter sources should be consulted in the following order:

the outcome (implicit navigation)

view parameter

nested _<f:param>_

If a query string parameter is found in two
or more sources, the latter source must replace all instances of the
query string parameter from the previous source(s).

{empty}[P1-end]

=== [[a3622]]Requirements for Explicit Navigation in Faces Flow Call Nodes other than ViewNodes

[P1-start ExplicitNavigationNonViewFlowNode
requirements] These steps must be performed in this order to determine
the _vdl view identifier_ when navigating to a flow node that is not a
view node.

Algorithm for resolving a _nodeId_ to a _vdl
view identifier_ .

If _nodeId_ is a view node, let _vdl view
identifier_ be the value of _nodeId_ and exit the algorithm.

If the node is a _SwitchNode_ , iterate over
the _NavigationCase_ instances returned from its _getCases()_ method.
For each, one call _getCondition()_ . If the result is _true_ , let
_nodeId_ be the value of its _fromOutcome_ property.

If the node is a _MethodCallNode_ , let
_nodeId_ be the value invoking the value of its _methodExpression_
property. If the result is _null_ , let _nodeId_ be the value of the
_MethodCallNode_ ’s _outcome_ property.

If the node is a _FlowCallNode_ , save it
aside as _facesFlowCallNode_ . Let _flowId_ be the value of its
_calledFlowId_ property and _flowDocumentId_ be the value of its
_calledFlowDocumentId_ property. If no _flowDocumentId_ exists for the
node, let it be the string resulting from _flowId + “/” + flowId +
“.xhtml”_ . Ask the _FlowHandler_ for a _Flow_ for this _flowId_ ,
_flowDocumentId_ pair. Obtain a reference to the start node and execute
this algorithm again, on that start node.

If the node is a _ReturnNode_ obtain its
navigation case and call _FlowHandler.pushReturnMode()_ . This enables
the navigation to proceed with respect to the calling flow’s navigation
rules, or the application’s navigation rules if there is no calling
flow. Start the navigation algorithm over using it as the basis but pass
the value of the symbolic constant
_javax.faces.flow.FlowHandler.NULL_FLOW_ as the value of the
_toFlowDocumentId_ argument. If this does not yield a navigation case,
call _FlowHandler.getLastDisplayedViewId()_ , which will return the last
displayed view id of the calling flow, or _null_ if there is no such
flow. In a _finally_ block, when the re-invocation of the navigation
algorithms completes, call _FlowHandler.popReturnMode()_ .

=== Requirements for Entering a Flow

[P1-start FlowEntryRequirements] If any of
the preceding navigation steps cause a flow to be entered, the
implementation must perform the following steps, in this order, before
continuing with navigation.

Make it so any _@FlowScoped_ beans for this
flow are able to be activated when an EL expression that references them
is evaluated.

Call the initializer for the flow, if any.

Proceed to the start node of the flow, which
may be any flow node type.

An attempt to navigate into a flow other than
via the identified start node of that throw should cause a
_FacesException_ .

{empty}[P1-end]

=== Requirements for Exiting a Flow

[P1-start FlowExitRequirements] If any of the
preceding navigation steps cause a flow to be exited, the implementation
must perform the following steps, in this order, before continuing with
navigation.

Call the finalizer for the flow, if any.

De-activate any _@FlowScoped_ beans for the
current flow.

If exiting via a return node ensure the
return parameters are correctly passed back to the caller.

{empty}[P1-end]

=== Requirements for Calling A Flow from the Current Flow

[P1-start FlowExitRequirements] If any of the
preceding navigation steps cause a flow to be called from another flow,
the _transition()_ method on _FlowHandler_ will ensure parameters are
correctly passed.

{empty}[P1-end]

=== [[a3646]]Example NavigationHandler Configuration

The following _<navigation-rule>_ elements
might appear in one or more application configuration resources (see
link:JSF.html#a6195[See Application Configuration Resources]) to
configure the behavior of the default _NavigationHandler_
implementation:

[width="100%",cols="100%",]
|===
a|
<navigation-rule>



 <description>

 APPLICATION WIDE NAVIGATION HANDLING

 </description>

 <from-view-id> * </from-view-id>



 <navigation-case>

 <description>

 Assume there is a “Logout” button on every
page that

 invokes the logout Action.

 </description>

 <display-name>Generic Logout
Button</display-name>


<from-action>#\{userBean.logout}</from-action>

 <to-view-id>/logout.jsp</to-view-id>

 </navigation-case>



 <navigation-case>

 <description>

 Handle a generic error outcome that might be
returned

 by any application Action.

 </description>

 <display-name>Generic Error
Outcome</display-name>

 <from-outcome>loginRequired</from-outcome>


<to-view-id>/must-login-first.jsp</to-view-id>

 </navigation-case>



 <navigation-case>

 <description>

 Illustrate paramaters

 </description>


<from-outcome>redirectPasswordStrength</from-outcome>

 <redirect>


<view-param><name>userId</name><value>someValue</value> +
</view-param>


<include-view-params>true</include-view-params>

 </redirect>

 </navigation-case>



</navigation-rule>

|===

[width="100%",cols="100%",]
|===
a|
<navigation-rule>



 <description>

 LOGIN PAGE NAVIGATION HANDLING

 </description>

 <from-view-id> /login.jsp </from-view-id>



 <navigation-case>

 <description>

 Handle case where login succeeded.

 </description>

 <display-name>Successful
Login</display-name>


<from-action>#\{userBean.login}</from-action>

 <from-outcome>success</from-outcome>

 <to-view-id>/home.jsp</to-view-id>

 </navigation-case>



 <navigation-case>

 <description>

 User registration for a new user succeeded.

 </description>

 <display-name>Successful New User
Registration</display-name>


<from-action>#\{userBean.register}</from-action>

 <from-outcome>success</from-outcome>

 <to-view-id>/welcome.jsp</to-view-id>

 </navigation-case>



 <navigation-case>

 <description>

 User registration for a new user failed
because of a

 duplicate username.

 </description>

 <display-name>Failed New User
Registration</display-name>


<from-action>#\{userBean.register}</from-action>


<from-outcome>duplicateUserName</from-outcome>


<to-view-id>/try-another-name.jsp</to-view-id>

 </navigation-case>



</navigation-rule>

|===

[width="100%",cols="100%",]
|===
a|
<navigation-rule>



 <description>

 Assume there is a search form on every page.
These navigation

 cases get merged with the application-wide
rules above because

 they use the same “from-view-id” pattern.
The same thing would

 also happen if “from-view-id” was omitted
here, because that is

 equivalent to a matching pattern of “*”.

 </description>

 <from-view-id> * </from-view-id>



 <navigation-case>

 <display-name>Search Form
Success</display-name>

 <from-action>#\{searchForm.go}</from-action>

 <from-outcome>success</from-outcome>

 <to-view-id>/search-results.jsp</to-view-id>

 </navigation-case>



 <navigation-case>

 <display-name>Search Form
Failure</display-name>

 <from-action>#\{searchForm.go}</from-action>

 <to-view-id>/search-problem.jsp</to-view-id>

 </navigation-case>



</navigation-rule>

|===

[width="100%",cols="100%",]
|===
a|
<navigation-rule>



 <description>

 Searching works slightly differently in part
of the site.

 </description>

 <from-view-id> /movies/* </from-view-id>



 <navigation-case>

 <display-name>Search Form
Success</display-name>

 <from-action>#\{searchForm.go}</from-action>

 <from-outcome>success</from-outcome>


<to-view-id>/movie-search-results.jsp</to-view-id>

 </navigation-case>



 <navigation-case>

 <display-name>Search Form
Failure</display-name>

 <from-action>#\{searchForm.go}</from-action>

 <to-view-id>/search-problem.jsp</to-view-id>

 </navigation-case>



</navigation-rule>

|===

[width="100%",cols="100%",]
|===
a|
public void savePizza();



<navigation-rule>

 <description>

 Pizza topping selection navigation handling

 </description>


<from-view-id>/selectToppings.xhtml</from-view-id>

 <navigation-case>

 <description>

Case where pizza is saved but there is
additional cost

 </description>

 <display-name>Pizza saved w/
extras</display-name>


<from-action>#\{pizzaBuilder.savePizza}</from-action>

 <if>#\{pizzaBuilder.additionalCost}</if>


<to-view-id>/approveExtras.xhtml</to-view-id>

 </navigation-case>

 <navigation-case>

 <description>

Case where pizza is saved and additional
pizzas are needed

 </description>

 <display-name>

Pizza saved, additional pizzas needed

</display-name>


<from-action>#\{pizzaBuilder.savePizza}</from-action>

 <if>#\{not order.complete}</if>

 <to-view-id>/createPizza.xhtml</to-view-id>

 </navigation-case>

 <navigation-case>

 <description>

 Handle case where pizza is saved and order
is complete

 </description>

 <display-name>Pizza complete</display-name>


<from-action>#\{pizzaBuilder.savePizza}</from-action>

 <if>#\{order.complete}</if>

 <to-view-id>/cart.xhtml</to-view-id>

 </navigation-case>

</navigation-rule>



|===

[width="100%",cols="100%",]
|===
a|
public String placeOrder();



<navigation-rule>

 <description>

 Cart navigation handling

 </description>

 <from-view-id>/cart.xhtml</from-view-id>

 <navigation-case>

 <description>

 Handle case where account has one click
delivery enabled

 </description>

 <display-name>Place order w/ one-click
delivery</display-name>


<from-action>#\{pizzaBuilder.placeOrder}</from-action>

 <if>#\{account.oneClickDelivery}</if>

 <to-view-id>/confirmation.xhtml</to-view-id>

 </navigation-case>

 <navigation-case>

 <description>

 Handle case where delivery information is
required

 </description>

 <display-name>

Place order w/o one-click delivery

</display-name>


<from-action>#\{pizzaBuilder.placeOrder}</from-action>

 <if>#\{not account.oneClickDelivery}</if>

 <to-view-id>/delivery.xhtml</to-view-id>

 </navigation-case>

</navigation-rule>



|===

=== 

image:SF-33.png[image]

[[a3840]]FlowHandler

Any JSF application can be modeled as a
directed graph where the nodes are views and the edges are transitions
between the views. Faces Flows introduces several other kinds of nodes
to this directed graph, providing support for encapsulating related
views and edges together. Applications can be created as composites of
modules of functionality, with each module consisting of well defined
entry and exit conditions, and the ability to share state among the
nodes within each module. This feature is heavily influenced by the
design of ADF Task Flows in Oracle’s Fusion Middleware and also by
Spring Web Flow and Apache MyFaces CODI. The normative specification for
this feature proceeds from the Javadoc for the class
_javax.faces.flow.FlowHandler_ , and also from related requirements in
link:JSF.html#a3561[See NavigationHandler]. This section
provides a non-normative usage example and walkthrough of feature so
that all the other parts of the specification that intersect with this
feature can be discovered.

=== Non-normative example

Here is a simple example to introduce the
feature. It does not touch on all aspects of the feature. The example
has two flows, each of which calls the other, passing parameters. Any
view outside of a flow may navigate to either of the flows, named flow-a
and flow-b.

image:SF-34.png[image]

This diagram uses the following conventions.

view nodes are boxes

faces flow return nodes are circles

faces flow call nodes are boxes with the
corners chopped off

 _@FlowScoped_ beans are rectangles
semi-circular short sides

the start node is marked “start”

inbound and outbound parameters are listed by
name

arrows show valid traversals among the nodes.

These flows are identical, except for the
names of their constituents, and each has the following properties.

Three view nodes, one of which is the
implicit start node

One faces flow return node, each of which
returns the outcome “return1”

One flow call node, which calls the other
flow, with two outbound parameters, named to match up with the other
flow

Two inbound parameters, named to match up
with the other flow

The different kinds of nodes mentioned in the
preceding discussion are defined in the javadoc for class
_javax.faces.flow.FlowHandler_ .

Consider this simple web app, called
_basic_faces_flow_call.war_ , containing the above mentioned flows. The
file layout for of the app is shown next. The example is shown using
maven war packaging

[width="100%",cols="100%",]
|===
|basic_faces_flow_call/ +
pom.xml +
src/main/webapp/ +
index.xhtml +
return1.xhtml +
WEB-INF/beans.xml +
flow-a/ +
flow-a.xhtml +
next_a.xhtml +
next_b.xhtml +
flow-b/ +
flow-b-flow.xml +
next_a.xhtml +
next_b.xhtml +
src/main/java/com/sun/faces/basic_faces_flow_call/ +
FlowA.java +
Flow_a_Bean.java +
Flow_b_Bean.java
|===

To complete the example, the execution of the
flows is examined. When the application containing these flows is
deployed, the runtime discovers the flow definitions and adds them to
the internal flow data structure. One flow is defined in
_flow-b-flow.xml_ . This is an XML file conforming to the Application
Configuration Resources syntax described in
link:JSF.html#a6195[See Application Configuration Resources].
The other flow is defined in _FlowA.java_ , a class with a method with
the _@FlowDefinition_ annotation. When the flow discovery is complete,
an application scoped, thread safe data structure containing the flow
definitions is available from the _javax.faces.flow.FlowHandler_
singleton. This data structure is navigable by the runtime via the
_javax.faces.flow.Flow_ API.

When the user agent visits
_http://localhost:8080/basic_faces_flow_call/faces/index.xhtml_ , they
see a page with two buttons, the actions of which are _flow-a_ , and
_flow-b_ , respectively. Clicking either button causes entry to the
corresponding flow. In this case, the user clicks the _flow-a_ button.
The _@FlowScoped_ bean _Flow_a_Bean_ is instantiated by the container
and navigation proceeds immediately to the start node, in this case
_flow-a.xhtml_ . The user proceeds directly to click a button taking
them to _next_a.xhtml_ , and then to _next_b.xhtml_ . On that page there
is a button whose action is _callB_ . Clicking this button activates the
correspondingly named faces flow call node, which prepares the specified
outbound parameters, de-activates _Flow_a_Bean_ and calls _flow-b_ .

Upon entry to _flow-b_ , the _@FlowScoped_
bean _Flow_b_Bean_ is instantiated by the container, the outbound
parameters from _flow-a_ are matched up with corresponding inbound
parameters on _flow-b_ and navigation proceeds immediately to the start
node, in this case _flow-b.xhtml_ . The user proceeds directly to click
a button taking them to _next_a.xhtml_ , and then to _next_b.xhtml_ . On
that page there is a button whose action is _taskFlowReturn1_ . Clicking
this button causes _Flow_b_Bean_ to be deactivated and navigation to the
view named _return1_ to be performed.

=== Non-normative Feature Overview

The normative requirements of the feature are
stated in the context of the part of the specification impacted. This
section gives the reader a non-normative overview of the feature that
touches on all the parts of the specification that intersect with this
feature.

 _Startup Time_

At startup time, the runtime will discover
flows available for this application. _This behavior is normatively
specified in link:JSF.html#a6228[See Faces Flows] and in the XML
schema for the application configuration resources._

 _Invoke Application Time_

The default _ActionListener_ may need to take
special action when calling into a flow. _This behavior is normatively
specified in link:JSF.html#a3402[See ActionListener Property]._

The default _NavigationHandler_
implementation must use the _FlowHandler_ during its operation. _This
behavior is normatively specified in link:JSF.html#a3571[See
Default NavigationHandler Algorithm]_ .

=== 

image:SF-33.png[image]

[[a3871]]ViewHandler

 _ViewHandler_ is the pluggability mechanism
for allowing implementations of or applications using the JavaServer
Faces specification to provide their own handling of the activities in
the _Render Response_ and _Restore View_ phases of the request
processing lifecycle. This allows for implementations to support
different response generation technologies, as well as different state
saving/restoring approaches.

A JSF implementation must provide a default
implementation of the _ViewHandler_ interface. __ See
link:JSF.html#a3450[See ViewHandler Property] for information on
replacing this default implementation with another implementation.

=== [[a3874]]Overview

 ViewHandler defines the public APIs
described in the following paragraphs

[width="100%",cols="100%",]
|===
a|
public Locale calculateLocale(FacesContext
context);

public String
calculateRenderKitId(FacesContext context);

|===

These methods are called from _createView()_
to allow the new view to determine the _Locale_ to be used for all
subsequent requests, and to find out which _renderKitId_ should be used
for rendering the view.

[width="100%",cols="100%",]
|===
a|
public void initView(FacesContext) throws
FacesException;

public String
calculateCharacterEncoding(FacesContext context);

|===

The _initView()_ method must be called as the
first method in the implementation of the _Restore View Phase_ of the
request processing lifecycle, immediately after checking for the
existence of the _FacesContext_ parameter. See the javadocs for this
method for the specification.. __

[width="100%",cols="100%",]
|===
|public String deriveViewId(FacesContext
context, String input);
|===

The _deriveViewId()_ method is an
encapsulation of the viewId derivation algorithm in previous versions of
the specification. This method looks at the argument _input_ , and the
current request and derives the _viewId_ upon which the lifecycle will
be run. __

[width="100%",cols="100%",]
|===
|public UIViewRoot createView(FacesContext
context, String viewId);
|===

Create and return a new _UIViewRoot_
instance, initialized with information from the specified _FacesContext_
and view identifier parameters.

If the view being requested is a Facelet
view, the _createView()_ method must ensure that the _UIViewRoot_ is
fully populated with all the children defined in the VDL page before
_createView()_ returns.

[width="100%",cols="100%",]
|===
|public String getActionURL(FacesContext
context, String viewId);
|===

Returns a URL, suitable for encoding and
rendering, that (if activated) will cause the JSF request processing
lifecycle for the specified _viewId_ to be executed

[width="100%",cols="100%",]
|===
|public String
getBookmarkableURL(FacesContext context, String viewId,
Map<String,List<String>> parameters, boolean includeViewParams);
|===

Return a JSF action URL derived from the
viewId argument that is suitable to be used as the target of a link in a
JSF response. The URL, if activated, would cause the browser to issue an
initial request to the specified viewId

[width="100%",cols="100%",]
|===
|public String getRedirectURL(FacesContext
context, String viewId, Map<String, List<String>> parameters, boolean
includeViewParams);
|===

Return a JSF action URL derived from the
_viewId_ argument that is suitable to be used by the _NavigationHandler_
to issue a redirect request to the URL using an initial request.

[width="100%",cols="100%",]
|===
|public String getResourceURL(FacesContext
context, String path);
|===

Returns a URL, suitable for encoding and
rendering, that (if activated) will retrieve the specified web
application resource.

[width="100%",cols="100%",]
|===
|public void renderView(FacesContext context,
UIViewRoot viewToRender) throws IOException, FacesException;
|===

This method must be called during the _Render
Response_ phase of the request processing lifecycle. It must provide a
valid _ResponseWriter_ or _ResponseStream_ instance, storing it in the
_FacesContext_ instance for the current request (see
link:JSF.html#a3198[See ResponseStream and ResponseWriter]), and
then perform whatever actions are required to cause the view currently
stored in the _viewRoot_ of the _FacesContext_ instance for the current
request to be rendered to the corresponding writer or stream. It must
also interact with the associated _StateManager_ (see
link:JSF.html#a4117[See StateManager]), by calling the
_getSerializedView()_ and _saveView()_ methods, to ensure that state
information for current view is saved between requests.

[width="100%",cols="100%",]
|===
|public UIViewRoot restoreView(FacesContext
context, String viewId) throws IOException;
|===

This method must be called from the _Restore
View_ phase of the request processing lifecycle. __ It must perform
whatever actions are required to restore the view associated with the
specified _FacesContext_ and _viewId_ .

It is the caller’s responsibility to ensure
that the returned _UIViewRoot_ instance is stored in the _FacesContext_
as the new _viewRoot_ property. In addition, if _restoreView()_ returns
_null_ (because there is no saved state for this view identifier), the
caller must call _createView()_ , and call _renderResponse()_ on the
_FacesContext_ instance for this request.

[width="100%",cols="100%",]
|===
|public void writeState(FacesContext context)
throws IOException;
|===

Take any appropriate action to either
immediately write out the current view’s state information (by calling
_StateManager.writeState()_ ), or noting where state information may
later be written. This method must be called once per call to the
_encodeEnd()_ method of any renderer for a _UIForm_ component, in order
to provide the _ViewHandler_ an opportunity to cause saved state to be
included with each submitted form.

[width="100%",cols="100%",]
|===
a|
public ViewDeclarationLanguage
getViewDeclarationLanguage();



|===

See the javadocs for this method for the
specification.

[width="100%",cols="100%",]
|===
a|
public Set<String>
getProtectedViewsUnmodifiable();

public void addProtectedView(String
urlPattern);

public boolean removeProtectedView(String
urlPattern)



|===

See the javadocs for these methods for the
specification.

=== [[a3910]]Default ViewHandler Implementation

The terms _view identifier_ and _viewId_ are
used interchangeably below and mean the context relative path to the web
application resource that produces the view, such as a JSP page or a
Facelets page. In the JSP case, this is a context relative path to the
jsp page representing the view, such as _/foo.jsp_ . In the Facelets
case, this is a context relative path to the XHTML page representing the
view, such as _/foo.xhtml_ .

JSF implementations must provide a default
_ViewHandler_ implementation, along with a default
_ViewDeclarationLanguageFactory_ implementation that vends
_ViewDeclarationLanguage_ implementations designed to support the
rendering of JSP pages containing JSF components and Facelets pages
containing JSF components. The default _ViewHandler_ is specified in
this section and the default _ViewDeclarationLanguage_ implementations
are specified in the following section.

=== [[a3913]]ViewHandler Methods that Derive Information From the Incoming Request

[P1-start ViewHandler.deriveViewId()
requirements] The _deriveViewId()_ method must fulfill the following
responsibilities:

If the argument input is _null_ , return
_null_ .

If prefix mapping (such as “/faces/*”) is
used for _FacesServlet_ , normalize the _viewId_ according to the
following algorithm, or its semantic equivalent, and return it.

Remove any number of occurrences of the
prefix mapping from the viewId. For example, if the incoming value was
_/faces/faces/faces/view.xhtml_ the result would be simply _view.xhtml_
.

If suffix mapping (such as “*.faces”) is used
for _FacesServlet_ , the _viewId_ is set using following algorithm.

Let _requestViewId_ be the value of argument
_input_ .

Consult the javadocs for
_ViewHandler.FACELETS_VIEW_MAPPINGS_PARAM_NAME_ and perform the steps
necessary to obtain a value for that param (or its alias as in the
javadocs). Let this be _faceletsViewMappings_ .

Obtain the value of the context
initialization parameter named by the symbolic constant
_ViewHandler.DEFAULT_SUFFIX_PARAM_NAME_ (if no such context
initialization parameter is present, use the value of the symbolic
constant _ViewHandler.DEFAULT_SUFFIX_ ). Let this be
_jspDefaultSuffixes_ . For each entry in the list from
_jspDefaultSuffixes_ , replace the suffix of _requestViewId_ with the
current entry from _jspDefaultSuffixes_ . For discussion, call this
_candidateViewId_ . For each entry in _faceletsViewMappings_ , If the
current entry is a prefix mapping entry, skip it and continue to the
next entry. If _candidateViewId_ is exactly equal to the current entry,
consider the algorithm complete with the result being _candidateViewId_
. If the current entry is a wild-card extension mapping, apply it
non-destructively to _candidateViewId_ and look for a physical resource
with that name. If present, consider the algorithm complete with the
result being the name of the physical resource. Otherwise look for a
physical resource with the name _candidateViewId_ . If such a resource
exists, consider the algorithm complete with the result being
_candidateViewId_ . If there are no entries in _faceletsViewMappings_ ,
look for a physical resource with the name _candidateViewId_ . If such a
resource exists, _candidateViewId_ is the correct _viewId_ .

Otherwise, obtain the value of the context
initialization parameter named by the symbolic constant
_ViewHandler.FACELETS_SUFFIX_PARAM_NAME_ . (if no such context
initialization parameter is present, use the value of the symbolic
constant _ViewHandler.DEFAULT_FACELETS_SUFFIX_ ). Let this be
_faceletsDefaultSuffix_ . Replace the suffix of _requestViewId_ with
_faceletsDefaultSuffix_ . For discussion, call this _candidateViewId_ .
If a physical resource exists with that name, _candidateViewId_ is the
correct _viewId_ .

Otherwise, if a physical resource exists with
the name _requestViewId_ let that value be _viewId_ .

Otherwise return _null_ .

If an exact mapping (such as /foo) is used
for FacesServlet, the viewId is set using following algorithm.

Let _requestViewId_ be the value of the
argument input.

Obtain the value of the context
initialization parameter named by the symbolic constant
_ViewHandler.FACELETS_SUFFIX_PARAM_NAME_ . (if no such context
initialization parameter is present, use the value of the symbolic
constant _ViewHandler.DEFAULT_FACELETS_SUFFIX_ ). Let this be
_faceletsDefaultSuffix_ .

Obtain the value of the context
initialization parameter named by the symbolic constant
_ViewHandler.DEFAULT_SUFFIX_PARAM_NAME_ (if no such context
initialization parameter is present, use the value of the symbolic
constant _ViewHandler.DEFAULT_SUFFIX_ ). Let this be _defaultSuffixes_ .

Add _faceletsDefaultSuffix_ to
_defaultSuffixes_ .

For each entry in the list from
_defaultSuffixes_ , add that current entry to the end of _requestViewId_
. For discussion, call this _candidateViewId_ . Look for a physical
resource with the name _candidateViewId_ . If such a resource exists,
consider the algorithm complete with the result being _candidateViewId_
.

Otherwise, if a physical resource exists with
the name _requestViewId_ let that value be _viewId_ . Otherwise return
_null_ .

{empty}[P1-end]

The getViewDeclarationLanguage() must fulfill
the following responsibilites.

See the javadocs for the normative
specification for this method.

{empty}[P1-start
ViewHandler.deriveLogicalViewId() requirements] The
_deriveLogicalViewId()_ method is identical to _deriveViewId()_ except
that it does not check for the existence of the resource. [P1-end]

[P1-start
ViewHandler.calculateCharacterEncoding() requirements] The
_calculateCharacterEncoding()_ method must fulfill the following
responsibilities:

Examine the _Content-Type_ request header. If
it has a _charset_ parameter extract it and return it.

{empty}If not, test for the existence of a
session by calling _getSession(false)_ on the _ExternalContext_ for this
_FacesContext_ . If the session is non- _null_ , look in the _Map_
returned by the _getSessionMap()_ method of the _ExternalContext_ for a
value under the key given by the value of the symbolic constant
_javax.faces.application.ViewHandler.CHARACTER_ENCODING_KEY_ . If a
value is found, convert it to a String and return it. [P1-end]

[P1-start calculateLocale() requirements] The
_calculateLocale()_ method must fulfill the following responsibilities:

Attempt to match one of the locales returned
by the _getLocales()_ method of the _ExternalContext_ instance for this
request, against the supported locales for this application as defined
in the application configuration resources. Matching is performed by the
algorithm described in Section JSTL.8.3.2 of the JSTL Specification. If
a match is found, return the corresponding _Locale_ object.

Otherwise, if the application has specified a
default locale in the application configuration resources, return the
corresponding _Locale_ object.

{empty}Otherwise, return the value returned
by calling _Locale.getDefault()_ .[P1-end]

[P1-start calculateRenderKitId()
requirements] The _calculateRenderKitId()_ method must fulfill the
following responsibilities:

Return the value of the request parameter
named by the symbolic constant
_ResponseStateManager.RENDER_KIT_ID_PARAM_ if it is not _null_ .

Otherwise, return the value returned by
_Application.getDefaultRenderKitId()_ if it is not _null_ .

Otherwise, return the value specified by the
symbolic constant _RenderKitFactory.HTML_BASIC_RENDER_KIT._

=== ViewHandler Methods that are Called to Fill a Specific Role in the Lifecycle

{empty}[P1-start createView() requirements]
The _createView()_ method must obtain a reference to the
_ViewDeclarationLanguage_ for this _viewId_ and call its
_ViewDeclarationLanguage.createView()_ method, returning the result and
not swallowing any exceptions thrown by that method.[P1-end]

[P1-start initView() requirements] The
_initView()_ method must fulfill the following responsibilities:

{empty}See the javadocs for this method for
the specification.[P1-end]

{empty}[P1-start renderView() requirements]
The _renderView()_ method must obtain a reference to the
_ViewDeclarationLanguage_ for the _viewId_ of the argument
_viewToRender_ and call its _ViewDeclarationLanguage.restoreView()_
method, returning the result and not swallowing any exceptions thrown by
that method.[P1-end]

{empty}[P1-start restoreView()
requirements]The _restoreView()_ method must obtain a reference to the
_ViewDeclarationLanguage_ for the _viewId_ of the argument
_viewToRender_ and call its _ViewDeclarationLanguage.restoreView()_
method, returning the result and not swallowing any exceptions thrown by
that method.[P1-end]

The _writeState()_ method must fulfill the
following responsibilities:

{empty}Obtain the saved state stored in a
thread-safe manner during the invocation of _renderView()_ and pass it
to the _writeState()_ method of the _StateManager_ for this application.
[N/T-end]

=== [[a3955]]ViewHandler Methods Relating to Navigation

[P1-start getActionURL() requirements] The
_getActionURL()_ method must fulfill the following responsibilities:

If the specified _viewId_ does not start with
a “/”, throw _IllegalArgumentException_ .

If exact mapping (such as /foo) is used for
FacesServlet, the following algorithm must be followed to derive the
result.

Retrieve the collection of existing mappings
of the FacesServlet, e.g. using _ServletRegistration#getMappings()_ .
Let this be _facesServletMappings_ . If the argument _viewId_ has an
extension, then obtain the value of the context initialization parameter
named by the symbolic constant _ViewHandler.FACELETS_SUFFIX_PARAM_NAME_
. (if no such context initialization parameter is present, use the value
of the symbolic constant _ViewHandler.DEFAULT_FACELETS_SUFFIX_ ). Let
this be _faceletsDefaultSuffix_ .

Obtain the value of the context
initialization parameter named by the symbolic constant
_ViewHandler.DEFAULT_SUFFIX_PARAM_NAME_ (if no such context
initialization parameter is present, use the value of the symbolic
constant _ViewHandler.DEFAULT_SUFFIX_ ). Let this be _defaultSuffixes_ .

Add _faceletsDefaultSuffix_ to
_defaultSuffixes_ .

For each entry in the list from
_defaultSuffixes_ , if the extension of the argument _viewId_ is equal
to this entry, remove the extension from _viewId_ . For discussion, call
this _candidateViewId_ .

Look if the _candidateViewId_ is present in
_facesServletMappings_ . If so,the result is _contextPath +
candidateViewId_ .

If the argument _viewId_ has no extension,
then look if the _viewId_ is present in _facesServletMappings_ . If so,
the result is _contextPath + viewId_ .

If no result has been obtained, pick any
prefix mapping or extension mapping from _facesServletMappings_ . If no
such mapping is found, throw an _IllegalStateException_ .

If such mapping is found remove the "*"
character from that mapping, take that as the new mapping and continue
with evaluating this mapping as specified below for "if prefix mapping
[...] is used" and for "if suffix mapping [...] is used



If prefix mapping (such as “/faces/*”) is
used for _FacesServlet_ , prepend the context path of the current
application, and the specified prefix, to the specified viewId and
return the completed value. For example “
_/cardemo/faces/chooseLocale.jsp_ ”.

If suffix mapping (such as “*.faces”) is used
for _FacesServlet_ , the following algorithm must be followed to derive
the result.

If the argument _viewId_ has no extension,
the result is _contextPath + viewId + mapping_ , where _contextPath_ is
the context path of the current application, _viewId_ is the argument
_viewId_ and _mapping_ is the value of the mapping (such as “*.faces”).

If the argument _viewId_ has an extension,
and this extension is not _mapping_ , the result is _contextPath +
viewId.substring(0, period) + mapping_ .

If the argument _viewId_ has an extension,
and this extension is _mapping_ , the result is _contextPath + viewId_ .

For example “ _/cardemo/chooseLocale.faces_ ”

If the current view is one of the views to
which view protection must be applied, the returned URL must contain the
parameter with a name equal to the value of the constant defined by
_ResponseStateManager.NON_POSTBACK_VIEW_TOKEN_PARAM_ . The value of this
parameter must be the return value from a call to
_ResponseStateManager.getCryptographicallyStrongTokenFromSession()_ .
This parameter is inspected during the restore view phase (see
link:JSF.html#a404[See Restore View]).

{empty}[P1-end]

[P1-start getBookmarkableURL() requirements]
The _getBookmarkableURL()_ method must fulfill the following
responsibilities:

If argument _includeViewParams_ is _true_ ,
obtain the view paramaters corresponding to the argument _viewId_ and
append them to the _Map_ given in argument _parameters_ . Let the
resultant _Map_ be called _paramsToEncode_ .

If the _viewId_ of the current _FacesContext_
is not equal to the argument _viewId_ , get the
_ViewDeclarationLanguage_ for the argument _viewId_ , obtain its
_ViewMetadata_ , call _createMetadataView()_ on it, then call
_ViewMetadata.getViewParameters()_ passing the return from
_createMetadataView()_ . Let the result of this method be _toViewParams_
.

If the _viewId_ of the current _FacesContext_
is equal to the argument _viewId_ , call
_ViewMetadata.getViewParameters()_ passing the current _UIViewRoot_ .
Let the result of this method be _toViewParams_ .

If _toViewParams_ is empty, take no further
action to add view parameters to this URL. Iterate over each
_UIViewParameter_ element in _toViewParams_ and take the following
actions on each element.

If the _Map_ given by _parameters_ has a key
equal to the _name_ property of the current element, take no action on
the current element and continue iterating.

If the current _UIViewParameter_ has a
_ValueExpression_ under the key _“value”_ (without the quotes), let
_value_ be the result of calling _getStringValueFromModel()_ on the
current _UIViewParameter_ .

Otherwise, if the current _viewId_ is the
same as the argument _viewId_ , let _value_ be the result of calling
_getStringValue()_ on the current _UIViewParameter_ .

Otherwise, if the current _viewId_ is
different from the argument _viewId_ , locate the _UIViewParameter_
instance in the current view whose name is equivalent to the current
element and let _value_ be the result of calling _getStringValue()_ on
the located _UIViewParameter_ .

If the above steps yielded a non- _null_
_value_ , find the _List<String>_ value in the _parameters_ map under
the key given by the _name_ property of the current _UIViewParameter_
element. If such a _List_ exists, add _value_ to it. Otherwise create a
_List<String>_ , add _value_ to it, and add it to the _parameters_ map
under the appropriate key.

If argument _includeViewParams_ is _false_ ,
take no action to add additional entries to _paramaters_ . Let
_paramsToEncode_ be _parameters_ .

Call _getActionURL()_ on the argument
_viewId_ . Let the result be _actionEncodedViewId_ .

Call _encodeBookmarkableURL()_ on the current
_ExternalContext_ , passing _actionEncodedViewId_ as the first argument
and _paramsToEncode_ as the second. Let the result be
_bookmarkEncodedURL_ .

{empty}Pass _bookmarkEncodedURL_ to
_ExternalContext.encodeActionURL()_ and return the result.[P1-end]

[P1-start getRedirectURL() requirements] The
_getRedirectURL()_ method must fulfill the following responsibilities:

Take exactly the same action as in
_getBookmarkableURL()_ up to and including the call to _getActionURL()_
. Thereafter take the following actions.

Call _encodeRedirectURL()_ on the current
_ExternalContext_ , passing _actionEncodedViewId_ as the first argument
and _paramsToEncode_ as the second. Let the result be
_redirectEncodedURL_ .

{empty}Pass _redirectEncodedURL_ to
_ExternalContext.encodeActionURL()_ and return the result.[P1-end]

[P1-start getResourceURL() requirements] The
_getResourceURL()_ method must fulfill the following responsibilities:

If the specified path starts with a “/”,
prefix it with the context path for the current web application, and
return the result.

{empty}Otherwise, return the specified _path_
value unchanged.[P1-end]

=== [[a3997]]ViewHandler Methods that relate to View Protection

{empty}[P1-start addProtectedView()
requirements] See the javadocs for _addProtectedView()_ for the
normative specification. [P1-end]

{empty}[P1-start removeProtectedView()
requirements] See the javadocs for _removeProtectedView()_ for the
normative specification. [P1-end]

{empty}[P1-start
getProtectedViewsUnmodifiable() requirements] See the javadocs for
_getProtectedViewsUnmodifiable()_ for the normative specification.
[P1-end]

See the _View Protection_ section within
link:JSF.html#a404[See Restore
View]link:JSF.html#a404[See Restore View] for the normative
specification of this feature.

=== 

image:SF-33.png[image]

[[a4003]]ViewDeclarationLanguage

To support the introduction of Facelets into
the core specification, whilst preserving backwards compatibility with
existing JSP applications, the concept of the _View Declaration
Language_ was formally introduced in version 2 of the specification. A
View Declaration Language (VDL) is a syntax used to declare user
interfaces comprised of instances of JSF _UIComponent_ s. Under this
definition, both JSP and Facelets are examples of an implementation of a
VDL. Any of the responsibilities of the _ViewHandler_ that specifically
deal with the VDL sub-system are now the domain of the VDL
implementation. These responsibilities are defined on the
_ViewDeclarationLanguage_ class.

=== ViewDeclarationLanguageFactory

 _ViewDeclarationLanguageFactory_ is a
factory object that creates (if needed) and returns a new
_ViewDeclarationLanguage_ instance based on the VDL found in a specific
view.

The factory mechanism specified in
link:JSF.html#a6147[See FactoryFinder] and
the decoration mechanism specified in link:JSF.html#a6336[See
Delegating Implementation Support] are used to allow decoration or
replacement of the _ViewDeclarationLanguageFactory_ .

[width="100%",cols="100%",]
|===
|public ViewDeclarationLanguage
getViewDeclarationLanguage(String viewId)
|===

Return the _ViewDeclarationLanguage_ instance
suitable for handling the VDL contained in the page referenced by the
argument viewId. [P1-start_required_ViewDeclarationLanguageImpls]The
default implementation must return a valid _ViewDeclarationLanguage_
instance for views written in either JSP or Facelets.
[P1-end_required_ViewDeclarationLanguageImpls]Whether the instance
returned is the same for a JSP or a Facelet view is an implementation
detail.

=== [[a4010]]Default ViewDeclarationLanguage Implementation

For each of the methods on
_ViewDeclarationLanguage_ , the required behavior is broken into three
segments:

Behavior required of all compliant
implementations

Behavior required of the implementation that
handles Facelet views

Behavior required of the implementation that
handles JSP views

Any implementation strategy is valid as long
as these requirements are met.

=== [[a4016]]ViewDeclarationLanguage.createView()

[width="100%",cols="100%",]
|===
|public UIViewRoot createView(FacesContext
context, String viewId)
|===

[P1-start createView() requirements] The
_createView()_ method must fulfill the following responsibilities.

All implementations must:

If there is an existing _UIViewRoot_
available on the _FacesContext_ , this method must copy its _locale_ and
_renderKitId_ to this new view root. If not, this method must call
_calculateLocale()_ and _calculateRenderKitId()_ , and store the results
as the values of the _locale_ and _renderKitId_ , properties,
respectively, of the newly created _UIViewRoot_ .

If no _viewId_ could be identified, or the
_viewId_ is exactly equal to the servlet mapping, send the response
error code _SC_NOT_FOUND_ with a suitable message to the client.

Create a new _UIViewRoot_ object instance
using _Application.createComponent(UIViewRoot.COMPONENT_TYPE)_ .

Pass the argument _viewId_ to the
_setViewId()_ method on the new _UIViewRoot_ instance.

The new _UIViewRoot_ instance must be passed
to _FacesContext.setViewRoot()_ . This enables the broadest possible
range of implementations for how tree creation is actually implemented.

The JSP and implementation is not required to
take any additional action.

The Facelet implementation must call
_calculateResourceLibraryContracts()_ , passing the argument _viewId_ ,
and unconditionally set the result as the _resourceLibraryContracts_
property on the _FacesContext_ . The implementation must obtain the
_ViewDeclarationLanguage_ reference on which to invoke
_calculateResourceLibraryContracts()_ from the _ViewHandler_ . This
ensures the methods can be correctly decorated.

All implementations must:

Return the newly created _UIViewRoot_ .

{empty}[P1-end]

=== [[a4030]]ViewDeclarationLanguage.calculateResourceLibraryContracts()

[width="100%",cols="100%",]
|===
|public List<String>
calculateResourceLibraryContracts(FacesContext context, viewId)
|===

The JSP implementation must return _null_ .

The Facelet implementation must examine the
resource library contracts data structure, which was populated as
specified in link:JSF.html#a6215[See Resource Library
Contracts], and find the _<contract-mapping>_ element that matches the
argument _viewId_ . When processing the nested _<url-pattern>_ matches
must be made using the following rules in this order.

An exact match.

The longest match

The value * matches all incoming viewIds

The value returned from this method is the
list whose contents are taken from the _contracts_ attribute of the
matching _<contract-mapping>_ element.

=== ViewDeclarationLanguage.buildView()

[width="100%",cols="100%",]
|===
|public void buildView(FacesContext context,
UIComponent root)
|===

[P1-start buildView() requirements] The
_buildView()_ method must fulfill the following responsibilities.

All implementations must:

The implementation must guarantee that the
page is executed in such a way that the _UIComponent_ tree described in
the VDL page is completely built and populated, rooted at the new
_UIViewRoot_ instance created previously.

The runtime must guarantee that the view must
be fully populated before the _afterPhase()_ method of any
_PhaseListeners_ attached to the application or to the _UIViewRoot_ (via
_UIViewRoot.setAfterPhaseListener()_ or _UIViewRoot.addPhaseListener()_
) are called.

The Facelets implementation must guarantee
the markup comprising the view is executed with the UIComponent
instances in the view being encountered in the same depth-first order as
in other lifecycle methods defined on _UIComponent_ , and added to the
view (but not rendered at this time), during the traversal. .

{empty}[P1-end]

=== [[a4046]]ViewDeclarationLanguage.getComponentMetadata()

[width="100%",cols="100%",]
|===
|public BeanInfo
getComponentMetadata(FacesContext context, Resource componentResource)
|===

[P1-start getComponentMetaData()
requirements] The _getComponentMetadata()_ method must fulfill the
following responsibilities:

All implementations must:

Return a reference to the component metadata
for the composite component represented by the argument
_componentResource_ , or _null_ if the metadata cannot be found. The
implementation may share and pool what it ends up returning from this
method to improve performance.

The Facelets implementation must

Support argument _componentResource_ being a
Facelet markup file that is to be interpreted as a composite component
as specified in link:JSF.html#a1671[See Composite Component
Metadata].

{empty}The JSP implementation is not required
to support argument _componentResource_ being a JSP markup file. In this
case, _null_ must be returned from this method.[P1-end]

=== ViewDeclarationLanguage.getViewMetadata() and getViewParameters()

[width="100%",cols="100%",]
|===
|public ViewMetadata
getViewMetadata(FacesContext context, String viewId)
|===

[P1-start getViewtMetaData() requirements]
The _getViewMetadata()_ method must fulfill the following
responsibilities:

All implementations must:

Return a reference to the view metadata for
the view represented by the argument _viewId_ , or _null_ if the
metadata cannot be found. The implementation may share and pool what it
ends up returning from this method to improve performance.

The Facelets implementation must support
argument _viewId_ being a Facelet markup file from which the view
metadata should be extracted.

{empty}The JSP implementation is not required
to support argument _viewId_ being a JSP markup file. In this case,
_null_ must be returned from this method.[P1-end]

=== ViewMetadata Contract

[width="100%",cols="100%",]
|===
|public UIViewRoot createMetadataView()
|===

The content of the metadata is provided by
the page author as a special _<f:facet/>_ of the _UIViewRoot_ . The name
of this facet is given by the value of the symbolic constant
_UIViewRoot.METADATA_FACET_NAME_ . The _UIViewRoot_ return from this
method must have that facet, and its children as its only children. This
facet may contain _<f:viewParameter>_ or _<f:viewAction>_ children. Each
such element is the metadata will cause a _UIViewParameter_ or
_UIViewAction_ (respectively) to be added to the view. Because
_UIViewParameter_ extends _UIInput_ it is valid to attach any of the
kinds of attached objects to an _<f:viewParameter>_ that are valid for
any element that represents any other kind of _UIInput_ in the view.
Because _UIViewAction_ implements _ActionSource2_ , it is valid to
attach any of the kinds of attached objects to an _<f:viewAction>_ that
are valid for any element that represents any other kind of
_ActionSource2_ in the view.

{empty}]

[width="100%",cols="100%",]
|===
|public Collection<UIViewParameter>
getViewParameters(UIViewRoot)
|===

Convenience method that uses the view
metadata specification above to obtain the _List<UIViewParameter>_ for
the argument viewId.

=== ViewDeclarationLanguage.getScriptComponentResource()

[width="100%",cols="100%",]
|===
|public Resource
getScriptComponentResource(FacesContext context, Resource
componentResource)
|===

[P1-start getScriptComponentResource()
requirements] The _getScriptComponentResource()_ method must fulfill the
following responsibilities:

The Facelets implementation must:

Take implementation specific action to
discover a _Resource_ given the argument _componentResource_ . The
returned _Resource_ if non- _null_ , must point to a script file that
can be turned into something that extends _UIComponent_ and implements
_NamingContainer_ .

{empty}The JSP implementation is not required
to support this method. In this case, _null_ must be returned from this
method.[P1-end]



=== ViewDeclarationLanguage.renderView()

[width="100%",cols="100%",]
|===
|public void renderView(FacesContext context,
String viewId)
|===

[P1-start renderView() requirements] The
_renderView()_ method must fulfill the following responsibilities:

All implementations must:

Return immediately if calling _isRendered()_
on the argument _UIViewRoot_ returns _false_ .

The JSP implementation must:

If the current request is a _ServletRequest_
, call the _set()_ method of the _javax.servlet.jsp.jstl.core.Config_
class, passing the current _ServletRequest_ , the symbolic constant
_Config.FMT_LOCALE_ , and the _locale_ property of the specfied
_UIViewRoot_ . This configures JSTL with the application’s preferred
locale for rendering this response.

Update the JSTL locale attribute in request
scope so that JSTL picks up the new locale from the _UIViewRoot_ . This
attribute must be updated before the JSTL _setBundle_ tag is called
because that is when the new _LocalizationContext_ object is created
based on the locale.

Create a wrapper around the current response
from the _ExternalContext_ and set it as the new response in the
_ExternalContext_ . Otherwise, omit this step. This wrapper must buffer
all content written to the response so that it is ready for output at a
later point. This is necessary to allow any content appearing after the
_<f:view>_ tag to appear in the proper position in the page.

Execute the JSP page to build the view by
treating the _viewId_ as a context-relative path (starting with a slash
character), by passing it to the _dispatch()_ method of the
_ExternalContext_ associated with this request. Otherwise, continue to
the next step. This causes control to pass to the JSP container, and
then to _UIComponentClassicTagBase_ . Please consult the javadocs for
that class for the specification of how to handle building the view by
executing the JSP page.

Store the wrapped response in a thread-safe
manner for use below. Otherwise, omit this step. The default
implementation uses the request scope for this purpose.

Restore the original response into the
_ExternalContext_ .

If the _FacesContext_ has a non- _null_
_ResponseWriter_ create a new writer using its _cloneWithWriter()_
method, passing the response’s _Writer_ as the argument. Otherwise, use
the current _RenderKit_ to create a new _ResponseWriter_ .

Set the new _ResponseWriter_ into the
_FacesContext_ , saving the old one aside.

All implementations must:

Call _saveView()_ on the _StateManager_ for
this application, saving the result in a thread-safe manner for use in
the _writeState()_ method of _ViewHandler_ .

Call _startDocument()_ on the
_ResponseWriter_ .

The Facelets implementation must:

Call _encodeAll()_ on the _UIViewRoot_ .

The JSP implementation must:

Output any content in the wrapped response
from above to the response, removing the wrapped response from the
thread-safe storage.

All implementations must:

Call _endDocument()_ on the _ResponseWriter_
.

The JSP implementation must:

If the old _ResponseWriter_ was not _null_ ,
place the old _ResponseWriter_ back into the _FacesContext_ .

The Facelets implementation must

{empty}Close the writer used to write the
response.[P1-end]

=== [[a4101]]ViewDeclarationLanguage.restoreView()

[width="100%",cols="100%",]
|===
|public UIViewRoot restoreView(FacesContext
context, String viewId)
|===

[P1-start restoreView() requirements]The
_restoreView()_ method must fulfill the following responsibilities:

The JSP implementation must:

If no _viewId_ could be identified, return
_null_ .

Call the _restoreView()_ method of the
associated _StateManager_ , passing the _FacesContext_ instance for the
current request and the calculated _viewId_ , and return the returned
_UIViewRoot_ , which may be _null_ .

The Facelets implementation must:

Call _ResponseStateManager.isStateless()_ .
If the result is _false_ , proceed as specified in the JSP
implementation. Otherwise, take the following steps and return.

Obtain a reference to the
_ViewDeclarationLanguage_ from the _ViewDeclarationLanguageFactory_ .
This is necessary to allow for proper decoration. It is not acceptable
to simply use the java language _this_ keyword.

Call _createView()_ on the
_ViewDeclarationLanguage_ instance, passing the _context_ and _viewId_
arguments. Let _viewRoot_ be the result.

Call _FacesContext.setViewRoot(_ _viewRoot_
_)_ .

Call _buildView()_ on the
_ViewDeclarationLanguage_ , passing the _context_ and _viewRoot_ .

Return the _viewRoot_ .

{empty}[P1-end]



=== 

image:SF-33.png[image]

[[a4117]]StateManager

 _StateManager_ directs the process of saving
and restoring the view between requests. The _StateManager_ instance for
an application is retrieved from the _Application_ instance, and
therefore cannot know any details of the markup language created by the
_RenderKit_ being used to render a view. Therefore, the _StateManager_
utilizes a helper object (see link:JSF.html#a4288[See
ResponseStateManager]), that is provided by the _RenderKit_
implementation, and is therefore aware of the markup language details.
The JSF implementation must provide a default _StateManager_
implementation that supports the behavior described below.

=== [[a4119]]Overview

Conceptually, the state of a view can be
divided into two pieces:

 _Tree Structure_ . This includes component
parent-child relationships, including facets.

 _Component State_ . This includes:

Component attributes and properties, and

 _Validator_ s, _Converter_ s,
_FacesListener_ s, and other objects attached to a component. The manner
in which these _attached objects_ are saved is up to the component
implementation. For attached objects that may have state, the
_StateHolder_ interface (see link:JSF.html#a1138[See
StateHolder]) is provided to allow these objects to preserve their own
attributes and properties. If an attached object does not implement
_StateHolder_ , but does implement _Serializable_ , it is saved using
standard serialization. Attached objects that do not implement either
_StateHolder_ or _Serializable_ must have a public, zero-arg
constructor, and will be restored only to their initial, default object
statelink:#a9094[11].

It is beneficial to think of this separation
between tree structure and tree state to allow the possibility that
implementations can use a different mechanism for persisting the
structure than is used to persist the state. For example, in a system
where the tree structure is stored statically, as an XML file, for
example, the system could keep a DOM representation of the trees
representing the webapp UI in memory, to be used by all requests to the
application.

=== [[a4126]]Stateless Views

Version 2.2 of the specification adds support
for stateless views. In such a view, the _UIComponent_ state for the
components is not saved. This feature must be used with full awareness
of the statefulness requirements of the components in the view. If a
component requires state to operate correctly, it must not be used in a
stateless view. Furthermore, it is not required that _@ViewScoped_
managed beans work at all with stateless views. This feature only works
with Facelet based views, not JSP based views.

To mark a view as stateless, the existing
_transient_ property from _UIComponent_ is exposed to the view author by
means of the _transient_ attribute on the _<f:view>_ tag from the Faces
Core tag library. The following spec sections contain more normative
requirements for stateless views.

The vdldocs for the Facelet variant of the
_<f:view>_ tag.

The javadocs for
_ResponseStateManager.writeState(FacesContext, Object)_

The javadocs for
_ResponseStateManager.isStateless(FacesContext)_

{empty}link:JSF.html#a4101[See
ViewDeclarationLanguage.restoreView()]

The javadocs for
_javax.faces.view.ViewScoped_

The javadocs for
_javax.faces.bean.ViewScoped_

=== [[a4135]]State Saving Alternatives and Implications

JSF implementations support two primary
mechanisms for saving state, based on the value of the
_javax.faces.STATE_SAVING_METHOD_ initialization parameter (see
link:JSF.html#a6088[See Application Configuration Parameters]).
The possible values for this parameter give a general indication of the
approach to be used, while allowing JSF implementations to innovate on
the technical details:

 _client_ -- Cause the saved state to be
included in the rendered markup that is sent to the client (such as in a
hidden input field for HTML). The state information must be included in
the subsequent request, making it possible for JSF to restore the view
without having saved information on the server side. It is advisable
that this information be encrypted and tamper evident, since it is being
sent down to the client, where it may persist for some time.The default
implementation Serializes the view in _client_ mode.

 _server_ -- Cause the saved state to be
stored on the server in between requests. Implementations that wish to
enable their saved state to fail over to a different container instance
must keep this in mind when implementing their server side state saving
strategy. Serializing the view in server mode is optional but must be
possible by setting the _context-param
javax.faces.SERIALIZE_SERVER_STATE_ to _true_ . In the _server_ mode,
this serialized view is stored in the session and a unique key to
retrieve the view is sent down to the client. By storing the serialized
view in the session, failover may happen using the usual mechanisms
provided by the container.

Serializable in the preceding text means the
values of all component attributes and properties (as well as the saved
state of attached objects) must implement _java.io.Serializable_ such
that if the aggregate saved state were written to an
_ObjectOutputStream_ , a _NotSerializableException_ would not be thrown.

=== [[a4140]]State Saving Methods.

[width="100%",cols="100%",]
|===
|public Object saveView(FacesContext
context);
|===

{empty}[P1-start saveView() requirements]
This method causes the tree structure and component state of the view
contained in the argument _FacesContext_ to be collected, stored, and
returned in a _java.lang.Object_ instance that must implement
_java.io.Serializable_ . If _null_ is returned from this method, there
is no state to save.[P1-end]

The returned object must represent the entire
state of the view, such that a request processing lifecycle can be run
against it on postback. Special care must be taken to guarantee that
objects attached to component instances, such as listeners, converters,
and validators, are also saved. The _StateHolder_ interface is provided
for this reason.

This method must also enforce the rule that
component ids within a _NamingContainer_ must be unique

[width="100%",cols="100%",]
|===
|public void writeState(FacesContext context,
Object state) throws IOException;
|===

Save the state represented in the specified
_Object_ instance, in an implementation dependent manner.

=== State Restoring Methods

[width="100%",cols="100%",]
|===
|public UIViewRoot restoreView(FacesContext
context, String viewId);
|===

Restore the tree structure and the component
state of the view for this _viewId_ to be restored, in an implementation
dependent manner. If there is no saved state information available for
this _viewId_ , this method returns _null_ .

The default implementation of this method
calls through to _restoreTreeStructure()_ and, if necessary
_restoreComponentState()._

=== Convenience Methods

[width="100%",cols="100%",]
|===
|public boolean
isSavingStateInClient(FacesContext context);
|===

{empty}[P1-start isSavingStateInClient()
requirements] Return _true_ if and only if the value of the
_ServletContext_ init parameter named by the value of the constant
_StateManager.STATE_SAVING_METHOD_PARAM_NAME_ is equal to the value of
the constant _STATE_SAVING_METHOD_CLIENT_ . Return _false_ otherwise.
[P1-end]

[width="100%",cols="100%",]
|===
|public String getViewState(FacesContext
context);
|===

Return the current view state as a String.
[P1-start-getViewState] This method must call
ResposeStateManger.getViewState.[P1-end] Refer to
link:JSF.html#a4288[See ResponseStateManager] for more details.

=== 

image:SF-33.png[image]

ResourceHandler

The normative specification for this class is
in the javadoc for _javax.faces.application.ResourceHandler_ . See also
link:JSF.html#a746[See Resource Handling].

[width="100%",cols="100%",]
|===
a|
public ResourceHandler getResourceHandler();



public void
setResourceHandler(ResourceHandler impl);

|===

=== 

image:SF-33.png[image]

Deprecated
APIs

=== [[a4163]]PropertyResolver Property

[width="100%",cols="100%",]
|===
a|
public PropertyResolver
getPropertyResolver();

{empty}[deprecated]



public void
setPropertyResolver(PropertyResolver resolver);

{empty}[deprecated]

|===

[N/T-start getPropertyResolver()
requirements] getPropertyResolver() must return a _PropertyResolver_
instance that wraps the _ELResolver_ instance that Faces provides to the
unified EL. [N/T-end] The _PropertyResolver_ instance will be utilized
to evaluate each . or [] operator when processing value expressions.
This method has been deprecated for getELResolver() (see
link:JSF.html#a3435[See ELResolver Property]).

setPropertyResolver() replaces the
_PropertyResolver_ instance that will be utilized to evaluate each _._
or _[]_ operator when processing a value binding expression. A default
implementation must be provided, which operates as described in
link:JSF.html#a3025[See PropertyResolver and the Default
PropertyResolver]. This method has been deprecated. See the Javadocs for
setPropertyResolver().

=== [[a4171]]VariableResolver Property

[width="100%",cols="100%",]
|===
a|
public VariableResolver
getVariableResolver();

{empty}[deprecated]



public void
setVariableResolver(VariableResolver resolver);

{empty}[deprecated]

|===

{empty}[N/T-start getVariableResolver()
requirements] getVariableResolver() must return the _VariableResolver_
that wraps the ELResolver instance that Faces provides to the unified
EL. The _VariableResolver_ instance will be utilized to convert the
first name in a value expression into a corresponding object. The
implementation must pass _null_ as the base argument for any methods
invoked on the underlying ELResolver _._ This method has been deprecated
for getELResolver(). [N/T-end]

setVariableResolver replaces the
_VariableResolver_ instance that will be utilized to resolve method and
value bindings. A default implementation must be provided, which
operates as described in link:JSF.html#a3020[See
VariableResolver and the Default VariableResolver]. The method has been
deprecated. See the Javadocs for setVariableResolver().

=== [[a4179]]Acquiring ValueBinding Instances

[width="100%",cols="100%",]
|===
a|
public ValueBinding createValueBinding(String
ref);

{empty}[deprecated]

|===

{empty}Create and return a _ValueBinding_
that can be used to evaluate the specified value binding expression.
Call through to _createValueExpression_ , passing the argument ref,
Object.class for the expectedType, and null for the fnMapper. To avoid
nondeterministic behavior, it is recommended that applications (or
frameworks) wishing to plug in their own resolver implementations do so
before _createValueBinding()_ is called for the first time. This method
has been deprecated for _createValueExpression()_
(link:JSF.html#a3463[See Programmatically Evaluating
Expressions]

=== Acquiring MethodBinding Instances

[width="100%",cols="100%",]
|===
a|
public MethodBinding
createMethodBinding(String ref, Class params[]);

{empty}[deprecated]

|===

Create and return a _MethodBinding_ that can
be used to evaluate the specified method binding expression, and invoke
the specified method. The implementation must call through to
_createMethodExpression,_ passing the given arguments, and wrap the
result in a MethodBinding implementation, returning it. The method that
is invoked must have parameter signatures that are compatible with the
classes in the _params_ parameterlink:#a9095[12] (which may be
_null_ or a zero-length array if the method to be called takes no
parameters). The actual parameters to be passed when the method is
executed are specified on the _invoke()_ call of the returned
_MethodBinding_ instance.

To avoid nondeterministic behavior, it is
recommended that applications (or frameworks) wishing to plug in their
own resolver implementations do so before calling
_createMethodBinding()_ for the first time. This method has been
deprecated.

=== Object Factories

[width="100%",cols="100%",]
|===
a|
public UIComponent
createComponent(ValueBinding componentBinding, FacesContext context,
String componentType);

{empty}[deprecated]

|===

Special version of the factory for
UIComponent instances that is used when evaluating component binding
expression properties. The implementation of this method must wrap the
argument componentBinding in an implementation of ValueExpression and
call through to createComponent(javax.el.ValueExpression,
javax.faces.FacesContext, java.lang.String). This method has been
deprecated for createComponent() using ValueExpression (see
link:JSF.html#a3468[See Object Factories])

=== StateManager

This method causes the tree structure and
component state of the view contained in the argument _FacesContext_ to
be collected, stored, and returned in a _StateManager.SerializedView_
instance. If _null_ is returned from this method, there is no state to
save.

This method must also enforce the rule that
component ids within a _NamingContainer_ must be unique

[width="100%",cols="100%",]
|===
a|
public void writeState(FacesContext context,
StateManager.SerializedView state) throws IOException;

{empty}[deprecated]

|===

Save the state represented in the specified
_SerializedView_ instance, in an implementation dependent manner.

[width="100%",cols="100%",]
|===
a|
protected Object
getTreeStructureToSave(FacesContext context);

{empty}[deprecated]

|===

This method must create a _Serializable_
object that represents the tree structure of the component tree for this
view. Tree structure is comprised of parent-child relationships,
including facets. The _id_ of each component and facet must also be
saved to allow the naming containers in the tree to be correctly
restored when this view is restored.

[width="100%",cols="100%",]
|===
a|
protected Object
getComponentStateToSave(FacesContext context);

{empty}[deprecated]

|===

This method must create a _Serializable_
object representing the component state (attributes, properties, and
attached objects) of the component tree for this view. Attached objects
that wish to save and restore their own state must implement
_StateHolder_ .

=== [[a4204]]ResponseStateManager

This method causes the tree structure and
component state of the view contained in the argument _FacesContext_ to
be collected, stored, and returned in a _StateManager.SerializedView_
instance. If _null_ is returned from this method, there is no state to
save.

This method must also enforce the rule that
component ids within a _NamingContainer_ must be unique

[width="100%",cols="100%",]
|===
a|
public void writeState(FacesContext context,
StateManager.SerializedView state) throws IOException;

{empty}[deprecated]

|===

Save the state represented in the specified
_SerializedView_ instance, in an implementation dependent manner.

[width="100%",cols="100%",]
|===
a|
protected Object
getTreeStructureToRestore(FacesContext context, String viewId);

{empty}[deprecated]

|===

The implementation must inspect the current
request and return the tree structure Object passed to it on a previous
invocation of _writeState()_ ..

[width="100%",cols="100%",]
|===
a|
protected Object
getComponentStateToRestore(FacesContext context, String viewId);

{empty}[deprecated]

|===

The implementation must inspect the current
request and return the component state Object passed to it on a previous
invocation of _writeState()_ .



 

=== 

image:SF-35.png[image]

[[a4219]]Rendering Model

image:SF-36.png[image]

JavaServer Faces supports two programming
models for decoding component values from incoming requests, and
encoding component values into outgoing responses - the _direct
implementation_ and _delegated implementation_ models. When the _direct
implementation_ model is utilized, components must decode and encode
themselves. When the _delegated implementation_ programming model is
utilized, these operations are delegated to a _Renderer_ instance
associated (via the _rendererType_ property) with the component. This
allows applications to deal with components in a manner that is
predominantly independent of how the component will appear to the user,
while allowing a simple operation (selection of a particular _RenderKit_
) to customize the decoding and encoding for a particular client device
or localized application user.

Component writers, application developers,
tool providers, and JSF implementations will often provide one or more
_RenderKit_ implementations (along with a corresponding library of
_Renderer_ instances). In many cases, these classes will be provided
along with the _UIComponent_ classes for the components supported by the
_RenderKit_ . Page authors will generally deal with _RenderKit_ s
indirectly, because they are only responsible for selecting a render kit
identifier to be associated with a particular page, and a _rendererType_
property for each _UIComponent_ that is used to select the corresponding
_Renderer_ .

=== 

image:SF-37.png[image]

[[a4223]]RenderKit

{empty}A _RenderKit_ instance is optionally
associated with a view, and supports components using the _delegated
implementation_ programming model for the decoding and encoding of
component values. It also supports _Behavior_ instances for the
rendering of client side behavior and decoding for queuing
_BehaviorEvents._ Refer to
link:JSF.html#a1707[See Component
Behavior Model] for more details about this feature.
[P1-start-renderkit]Each JSF implementation must provide a default
_RenderKit_ instance (named by the render kit identifier associated with
the String constant _RenderKitFactory.HTML_BASIC_RENDER_KIT_ as
described below) that is utilized if no other _RenderKit_ is
selected.[P1-end]

[width="100%",cols="100%",]
|===
|public Renderer getRenderer(String family,
String rendererType);
|===

Return the _Renderer_ instance corresponding
to the specified component _family_ and _rendererType (if any),_ which
will typically be the value of the _rendererType_ property of a
_UIComponent_ about to be decoded or encoded

[width="100%",cols="100%",]
|===
|public ClientBehaviorRenderer
getClientBehaviorRenderer(String type);
|===

Return the _ClientBehaviorRenderer_ instance
corresponding to the specified behavior type.

[width="100%",cols="100%",]
|===
|public void addRenderer(String family,
String rendererType, Renderer renderer);
|===

[width="100%",cols="100%",]
|===
|public void addClientBehaviorRenderer(String
type, ClientBehaviorRenderer renderer);
|===

[width="100%",cols="100%",]
|===
|public Iterator<String>
getClientBehaviorRendererTypes();
|===

Applications that wish to go beyond the
capabilities of the standard _RenderKit_ that is provided by every JSF
implementation may either choose to create their own _RenderKit_
instances and register them with the _RenderKitFactory_ instance (see
link:JSF.html#a4300[See RenderKitFactory]), or integrate
additional (or replacement) supported _Renderer_ instances into an
existing _RenderKit_ instance. For example, it will be common for an
application that requires custom component classes and _Renderer_ s to
register them with the standard _RenderKit_ provided by the JSF
implementation, at application startup time See
link:JSF.html#a6554[See Example Application Configuration
Resource]for an example of a _faces-config.xml_ configuration resource
that defines two additional Renderer instances to be registered in the
default _RenderKit_ .

[width="100%",cols="100%",]
|===
|public ResponseWriter
createResponseWriter(Writer writer, String contentTypeList, String
characterEncoding);
|===

Use the provided _Writer_ to create a new
_ResponseWriter_ instance for the specified character encoding.

The _contentTypeList_ parameter is an "Accept
header style" list of content types for this response, or _null_ if the
_RenderKit_ should choose the best fit. [P1-start-contentTypeList]The
_RenderKit_ must support a value for the _contentTypeList_ argument that
comes straight from the _Accept_ HTTP header, and therefore requires
parsing according to the specification of the _Accept_ header.[P1-end]
Please see Section 14.1 of RFC 2616 (the HTTP 1.1 RFC) for the
specification of the _Accept_ header.

{empty}Implementors are advised to consult
the _getCharacterEncoding()_ method of class
_javax.faces.servlet.ServletResponse_ to get the required value for the
characterEncoding parameter for this method. Since the _Writer_ for this
response will already have been obtained (due to it ultimately being
passed to this method), we know that the character encoding cannot
change during the rendering of the response. Please see
link:JSF.html#a3324[See ResponseWriter]

[width="100%",cols="100%",]
|===
|public ResponseStream
createResponseStream(OuputStream out);
|===

Use the provided _OutputStream_ to create a
new _ResponseStream_ instance.

[width="100%",cols="100%",]
|===
|public ResponseStateManager
getResponseStateManager();
|===

Return an instance of _ResponseStateManager_
to handle rendering technology specific state management decisions..

[width="100%",cols="100%",]
|===
a|
public Iterator<String>
getComponentFamilies();

public Iterator<String>
getRendererTypes(String componentFamily);

|===

The first method returns an _Iterator_ over
the _component-family_ entries supported by this _RenderKit_ . The
second one can be used to get an _Iterator_ over the _renderer-type_
entries for each of the _component-family_ entries returned from the
first method.

=== 

image:SF-37.png[image]

[[a4245]]Renderer

A _Renderer_ instance implements the decoding
and encoding functionality of components, during the _Apply Request
Values_ and _Render Response_ phases of the request processing
lifecycle, when the component has a non- _null_ value for the
_rendererType_ property.

[width="100%",cols="100%",]
|===
|public void decode(FacesContext context,
UIComponent component);
|===

For components utilizing the _delegated
implementation_ programming model, this method will be called during the
_apply request values_ phase of the request processing lifecycle, for
the purpose of converting the incoming request information for this
component back into a new local value. See the API reference for the
_Renderer.decode()_ method for details on its responsibilities.

[width="100%",cols="100%",]
|===
a|
public void encodeBegin(FacesContext context,
UIComponent component) throws IOException;



public void encodeChildren(FacesContext
context, UIComponent component) throws IOException;



public void encodeEnd(FacesContext context,
UIComponent component) throws IOException;

|===

For components utilizing the _delegated
implementation_ programming model, these methods will be called during
the _Render Response_ phase of the request processing lifecycle. These
methods have the same responsibilities as the corresponding
_encodeBegin()_ , _encodeChildren()_ , and _encodeEnd()_ methods of
_UIComponent_ (described in link:JSF.html#a1041[See Component
Specialization Methods] and the corresponding Javadocs) when the
component implements the _direct implementation_ programming model.

[width="100%",cols="100%",]
|===
|public String convertClientId(FacesContext
context, String clientId);
|===

Converts a component-generated client
identifier into one suitable for transmission to the client.

[width="100%",cols="100%",]
|===
|public boolean getRendersChildren();
|===

Return a flag indicating whether this
Renderer is responsible for rendering the children of the component it
is asked to render.

[width="100%",cols="100%",]
|===
a|
 public Object getConvertedValue(FacesContext
context,

UIComponent component, Object submittedValue)
throws ConverterException;

|===

Attempt to convert previously stored state
information into an object of the type required for this component
(optionally using the registered _Converter_ for this component, if
there is one). If conversion is successful, the new value should be
returned from this method; if not, a _ConverterException_ should be
thrown.

A _Renderer_ may listen for events using the
_ListenerFor_ annotation. Refer to the Javadocs for the _ListenerFor_
class for more details.

=== 

image:SF-37.png[image]

[[a4264]]ClientBehaviorRenderer

A _ClientBehaviorRenderer_ instance produces
client side behavior for components in the form of script content. It
also participates in decoding and as such has the ability to enqueue
server side _BehaviorEvents._ ..

[width="100%",cols="100%",]
|===
|public String
getScript(ClientBehaviorContext behaviorContext, ClientBehavior
behavior);
|===

Produce the script content that performs the
client side behavior. This method is called during the _Render Response_
phase of the request processing lifecycle.

[width="100%",cols="100%",]
|===
|public void decode(FacesContext context,
UIComponent component, ClientBehavior behavior);
|===

This method will be called during the _apply
request values_ phase of the request processing lifecycle, for the
primary purpose of enqueuing _BehaviorEvents._ All client behavior
renderer implementations must extend from the _ClientBehaviorRenderer_
interface _._

=== ClientBehaviorRenderer Registration

ClientBehaviorRenderer implementations may be
registered in the JSF faces-config.xml or with an annotation.

=== XML Registration



[width="100%",cols="100%",]
|===
a|
<render-kit>

<render-kit-id>HTML_BASIC</render-kit-id>

<client-behavior-renderer>

<client-behavior-renderer-type>custom.behavior.Greet</client-behavior-renderer-type>

<client-behavior-renderer-class>greet.GreetRenderer</client-behavior-renderer-class>

</client-behavior-renderer>

...

|===

=== Registration By Annotation

JSF provides the
_javax.faces.render.FacesBehaviorRenderer annotation._

[width="100%",cols="100%",]
|===
a|
@FacesClientBehaviorRenderer(value=”Hello”)

public class MyRenderer extends
ClientBehaviorRenderer \{

...

}

|===

=== 

image:SF-37.png[image]

[[a4288]]ResponseStateManager

 _ResponseStateManager_ is the helper class
to _javax.faces.application.StateManager_ that knows the specific
rendering technology being used to generate the response. It is a
singleton abstract class. This class knows the mechanics of saving
state, whether it be in hidden fields, session, or some combination of
the two.

[width="100%",cols="100%",]
|===
|public Object getState(FacesContext
context);
|===

Please see the javadoc for this method for
the normative specification.

[width="100%",cols="100%",]
|===
|public void writeState(FacesContext context,
Object state) throws IOException;
|===

Please see the javadoc for this method for
the normative specification.

[width="100%",cols="100%",]
|===
|public boolean isPostback(FacesContext
context);
|===

Return _true_ if the current request is a
postback. The default implementation returns _true_ if this
_ResponseStateManager_ instance wrote out state on a previous request to
which this request is a postback. Return false otherwise.

Please see _link:JSF.html#a4204[See
ResponseStateManager]_ for deprecated methods in _ResponseStateManager_
.

[width="100%",cols="100%",]
|===
|public String getViewState(FacesContext
context);
|===

Return the view state as a String without any
markup related to the rendering technology supported by this
ResponseStateManager.

=== 

image:SF-37.png[image]

[[a4300]]RenderKitFactory

[P1-start-renderkitFactory]A single instance
of _javax.faces.render.RenderKitFactory_ must be made available to each
JSF-based web application running in a servlet or portlet
container.[P1-end] The factory instance can be acquired by JSF
implementations, or by application code, by executing

[width="100%",cols="100%",]
|===
a|
RenderKitFactory factory = (RenderKitFactory)


FactoryFinder.getFactory(FactoryFinder.RENDER_KIT_FACTORY);

|===

The _RenderKitFactory_ implementation class
supports the following methods:

[width="100%",cols="100%",]
|===
a|
public RenderKit getRenderKit(FacesContext
context, String renderKitId);



|===

Return a _RenderKit_ instance for the
specified render kit identifier, possibly customized based on the
dynamic characteristics of the specified, (yet possibly null)
_FacesContext_ . For example, an implementation might choose a different
_RenderKit_ based on the “User-Agent” header included in the request, or
the _Locale_ that has been established for the response view. Note that
applications which depend on this feature are not guaranteed to be
portable across JSF implementations.

[P1-start-renderkitDefault]Every JSF
implementation must provide a _RenderKit_ instance for a default render
kit identifier that is designated by the _String_ constant
_RenderKitFactory.HTML_BASIC_RENDER_KIT_ .[P1-end] Additional render kit
identifiers, and corresponding instances, can also be made available.

[width="100%",cols="100%",]
|===
|public Iterator<String> getRenderKitIds();
|===

{empty}This method returns an _Iterator_ over
the set of render kit identifiers supported by this factory.
[P1-start-renderkitIds]This set must include the value specified by
_RenderKitFactory.HTML_BASIC_RENDER_KIT_ .[P1-end]

[width="100%",cols="100%",]
|===
|public void addRenderKit(String renderKitId,
RenderKit renderKit);
|===

Register a _RenderKit_ instance for the
specified render kit identifier, replacing any previous RenderKit
registered for that identifier.

=== 

image:SF-37.png[image]

[[a4314]]Standard HTML RenderKit Implementation

To ensure application portability, all JSF
implementations are required to include support for a _RenderKit_ , and
the associated _Renderers_ , that meet the requirements defined in this
section, to generate textual markup that is compatible with HTML 4.01.
JSF implementors, and other parties, may also provide additional
_RenderKit_ libraries, or additional _Renderer_ s that are added to the
standard _RenderKit_ at application startup time, but applications must
ensure that the standard _Renderer_ s are made available for the web
application to utilize them.

The required behavior of the standard HTML
RenderKit is specified in a set of external HTML pages that accompany
this specification, entitled “The Standard HTML RenderKit”. The behavior
described in these pages is normative, and are required to be fulfilled
by all implementations of JSF.

=== 

image:SF-37.png[image]

The Concrete HTML Component Classes

For each valid combination of _UIComponent_
subclass and standard renderer given in the previous section, there is a
concrete class in the package _javax.faces.component.html_ package. Each
class in this package is a subclass of an corresponding class in the
_javax.faces.component_ package, and adds strongly typed JavaBeans
properties for all of the renderer-dependent properties. These classes
also implement the _BehaviorHolder_ interface, enabling them to have
_Behavior attached to them. Refer to_
link:JSF.html#a1707[See Component
Behavior Model] __ for additional details..

=== Concrete HTML Component Classes

javax.faces.component class

renderer-type

javax.faces.component.html class

UICommand

javax.faces.Button

HtmlCommandButton

UICommand

javax.faces.Link

HtmlCommandLink

UIData

javax.faces.Table

HtmlDataTable

UIForm

javax.faces.Form

HtmlForm

UIGraphic

javax.faces.Image

HtmlGraphicImage

UIInput

javax.faces.Hidden

HtmlInputHidden

UIInput

javax.faces.Secret

HtmlInputSecret

UIInput

javax.faces.Text

HtmlInputText

UIInput

javax.faces.Textarea

HtmlInputTextarea

UIMessage

javax.faces.Message

HtmlMessage

UIMessages

javax.faces.Messages

HtmlMessages

UIOutput

javax.faces.Format

HtmlOutputFormat

UIOutput

javax.faces.Label

HtmlOutputLabel

UIOutput

javax.faces.Link

HtmlOutputLink

UIOutput

javax.faces.Text

HtmlOutputText

UIOutcomeTarget

javax.faces.Link

HtmlOutcomeTargetLink

UIOutcomeTarget

javax.faces.Button

HtmlOutcomeTargetButton

UIPanel

javax.faces.Grid

HtmlPanelGrid

UIPanel

javax.faces.Group

HtmlPanelGroup

UISelectBoolean

javax.faces.Checkbox

HtmlSelectBooleanCheckbox

UISelectMany

javax.faces.Checkbox

HtmlSelectManyCheckbox

UISelectMany

javax.faces.Listbox

HtmlSelectManyListbox

UISelectMany

javax.faces.Menu

HtmlSelectManyMenu

UISelectOne

javax.faces.Listbox

HtmlSelectOneListbox

UISelectOne

javax.faces.Menu

HtmlSelectOneMenu

UISelectOne

javax.faces.Radio

HtmlSelectOneRadio

{empty}[P1-start-htmlComponent]As with the
standard components in the _javax.faces.component_ package, each HTML
component implementation class must define a static public final String
constant named _COMPONENT_TYPE_ , whose value is “ _javax.faces._ ”
concatenated with the class name. HTML components, however, must not
define a _COMPONENT_FAMILY_ constant, or override the _getFamily()_
method they inherit from their superclass.[P1-end]



[[a4404]]

=== 

image:SF-38.png[image]

[[a4406]]Integration with JSP

image:SF-39.png[image]

Any JavaServer Faces implementations that
claims compliance with this specification must include a complete
JavaServer Pages implementation, and expose this implementation to the
runtime of any JSF application. JSF applications, however, need not use
JSP as their View Declaration Language (VDL). In fact, a JSF application
is free to use whatever technology it likes for its VDL, as long as that
VDL itself complies with the JSF specification.

This version of the specification requires
that implementations support two View Declaration Language syntaxes

JSP

Facelets XHTML

This chapter describes the JSP support
required by JavaServer Faces. This JSP support is enabled by providing
custom actions so that a JSF user interface can be easy defined in a JSP
page by adding tags corresponding to JSF UI components. Custom actions
provided by a JSF implementation may be mixed with standard JSP actions
and custom actions from other libraries, as well as template text for
layout, in the same JSP page.

Facelets XHTML is specified in
link:JSF.html#a5476[See Facelets and its use in Web
Applications]. This chapters builds on the previous one. Facelets relies
on concepts specified in JSP.

For JSP version 2.0 and onward, the file
extension “ _.jsf_ ” is reserved, and may optionally be used (typically
by authoring tools) to represent VDL pages containing JSF
contentlink:#a9096[13]. When running in a JSP 1.2 environment,
JSP authors must give their JSP pages that contain JSF content a
filename ending in “ _.jsp_ ”.

=== 

image:SF-40.png[image]

[[a4415]]UIComponent Custom Actions

A JSP custom action (aka custom tag or tag)
for a JSF _UIComponent_ is constructed by combining properties and
attributes of a Java UI component class with the rendering attributes
supported by a specific _Renderer_ from a concrete _RenderKit_ . For
example, assume the existence of a concrete _RenderKit_ ,
_HTMLRenderKit_ , which supports three _Renderer_ types for the
_UIInput_ component:

=== Example Renderer Types

RendererType

Render-Dependent Attributes

“Text”

“size”

“Secret”

“size”, “secretChar”

“Textarea”

“size”, “rows”

The tag library descriptor (TLD) file for the
corresponding tag library, then, would define three custom actions—one
per _Renderer_ . Below is an example of a portion of the custom action
definition for the _inputText_ taglink:#a9097[14]:

[width="100%",cols="100%",]
|===
a|
<tag>

 <name>inputText</name>


<tag-class>acme.html.tags.InputTag</tag-class>

 <bodycontent>JSP</bodycontent>

 <attribute>

 <name>id</name>

 <required>false</required>

 <rtexprvalue>true</rtexprvalue>

 </attribute>

 <attribute>

 <name>value</name>

 <required>false</required>

 <deferred-value>

 <type>java.lang.Object</type>

 <deferred-value>

 </attribute>

 <attribute>

 <name>size</name>

 <required>false</required>

 <deferred-value>

 <type>java.lang.Integer</type>

 <deferred-value>

 </attribute>

 ...

</tag>

|===

Note that the _size_ attribute is derived
from the _Renderer_ of type “Text”, while the _id_ and _value_
attributes are derived from the _UIInput_ component class itself. Also
note that the _id_ attribute has _rtexprvalue_ set to _true_ . This is
to allow _$\{}_ expressions in the _id_ attribute so that _<c:forEach>_
can include faces components that incorporate the index into their id.
_RenderKit_ implementors will generally provide a JSP tag library which
includes component custom actions corresponding to each of the component
classes (or types) supported by each of the _RenderKit_ ’s _Renderers_ .
See link:JSF.html#a4223[See RenderKit] and
link:JSF.html#a4245[See Renderer] for details on the
_RenderKit_ and _Renderer_ APIs. JSF implementations must provide such a
tag library for the standard HTML RenderKit (see
link:JSF.html#a5363[See Standard HTML RenderKit Tag Library]).

=== 

image:SF-40.png[image]

Using UIComponent Custom Actions in JSP Pages

The following subsections define how a page
author utilizes the custom actions provided by the _RenderKit_
implementor in the JSP pages that create the user interface of a
JSF-based web application.

=== Declaring the Tag Libraries

This specification hereby reserves the
following Uniform Resource Identifier (URI) values to refer to the
standard tag libraries for the custom actions defined by JavaServer
Faces:

 _http://java.sun.com/jsf/core_ -- URI for
the _JavaServer Faces Core Tag Library_

 _http://java.sun.com/jsf/html_ -- URI for
the _JavaServer Faces Standard HTML RenderKit Tag Library_

The page author must use the standard JSP
_taglib_ directive to declare the URI of each tag library to be
utilized, as well as the prefix used (within this page) to identify
custom actions from this library. For example,

[width="100%",cols="100%",]
|===
a|
<%@ taglib uri=”http://java.sun.com/jsf/core”
prefix=”f” %>

<%@ taglib uri=”http://java.sun.com/jsf/html”
prefix=”h” %>

|===

declares the unique resource identifiers of
the tag libraries being used, as well as the prefixes to be used within
the current page for referencing actions from these
librarieslink:#a9098[15].

=== Including Components in a Page

A JSF _UIComponent_ custom action can be
placed at any desired position in a JSP page that contains the _taglib_
directive for the corresponding tag library, subject to the following
restrictions:

When using a single JSP page to create the
entire view, JSF component custom actions must be nested inside the
_<f:view>_ custom action from the JSF Core Tag Library.

The following example illustrates the general
use of a UIComponent custom action in a JSP page. In this scenario:

[width="100%",cols="100%",]
|===
|<h:inputText id=”username”
value=”#\{logonBean.username}”/>
|===

represents a _UIInput_ field, to be rendered
with the “Text” renderer type, and points to the username property of a
backing bean for the actual value. The _id_ attribute specifies the
component id of a _UIComponent_ instance, from within the component
tree, to which this custom action corresponds. If no _id_ __ is
specified, one will be automatically generated by the custom action
implementation.

Custom actions that correspond to JSF
_UIComponent_ instances must subclass
_javax.faces.webapp.UIComponentELTag_ (see
link:JSF.html#a6175[See UIComponentELTag])

During the _Render Response_ phase of the
request processing lifecycle, the appropriate encoding methods of the
component (or its associated _Renderer_ ) will be utilized to generate
the representation of this component in the response page. In addition,
the first time a particular page is rendered, the component tree may
also be dynamically constructed.

All markup other than _UIComponent_ custom
actions is processed by the JSP container, in the usual way. Therefore,
you can use such markup to perform layout control, or include non-JSF
content, in conjunction with the actions that represent UI components.

=== Creating Components and Overriding Attributes

As _UIComponent_ custom actions are
encountered during the processing of a JSP page, the custom action
implementation must check the component tree for the existence of a
corresponding _UIComponent_ , and (if not found) create and configure a
new component instance corresponding to this custom action. The details
of this process (as implemented in the findComponent() method of
UIComponentClassicTagBase, for easy reuse) are as follows:

If the component associated with this
component custom action has been identified already, return it
unchanged.

Identify the _component identifier_ for the
component related to this UIComponent custom action, as follows:

If the page author has specified a value for
the _id_ attribute, use that value.

Otherwise, call the _createUniqueId()_ method
of the _UIViewRoot_ at the root of the component tree for this view, and
use that value.

If this _UIComponent_ custom action is
creating a _facet_ (that is, we are nested inside an _<f:facet>_ custom
action), determine if there is a facet of the component associated with
our parent _UIComponent_ custom action, with the specified facet name,
and proceed as follows:

If such a facet already exists, take no
additional action.

If no such facet already exists, create a new
_UIComponent_ (by calling the _createComponent()_ method on the
_Application_ instance for this web application, passing the value
returned by _getComponentType()_ , set the component identifier to the
specified value, call _setProperties()_ passing the new component
instance, and add the new component as a facet of the component
associated with our parent _UIComponent_ custom action, under the
specified facet name.

If this _UIComponent_ custom action is not
creating a facet (that is, we are not nested inside an _<f:facet>_
custom action), determine if there is a child component of the component
associated with our parent _UIComponent_ custom action, with the
specified component identifier, and proceed as follows:

If such a child already exists, take no
additional action.

If no such child already exists, create a new
_UIComponent_ (by calling the _createComponent()_ method on the
_Application_ instance for this web application, passing the value
returned by _getComponentType()_ , set the component identifier to the
specified value, call _setProperties()_ passing the new component
instance, and add the new component as a child of the component
associated with our parent _UIComponent_ custom action.

=== Deleting Components on Redisplay

In addition to the support for dynamically
creating new components, as described above, UIComponent custom actions
will also _delete_ child components (and facets) that are already
present in the component tree, but are not rendered on this display of
the page. For example, consider a UIComponent custom action that is
nested inside a JSTL _<c:if>_ custom action whose condition is true when
the page is initially rendered. As described in this section, a new
UIComponent will have been created and added as a child of the
_UIComponent_ corresponding to our parent _UIComponent_ custom action.
If the page is re-rendered, but this time the _<c:if>_ condition is
_false_ , the previous child component will be removed.

=== Representing Component Hierarchies

Nested structures of _UIComponent_ custom
actions will generally mirror the hierarchical relationships of the
corresponding _UIComponent_ instances in the view that is associated
with each JSP page. For example, assume that a _UIForm_ component (whose
component id is _logonForm_ ) contains a _UIPanel_ component used to
manage the layout. You might specify the contents of the form like this:

[width="100%",cols="100%",]
|===
a|
<h:form id=”logonForm”>

 <h:panelGrid columns=”2”>

 <h:outputLabel for=”username”>

 <h:outputText value=”Username:”/>

 </h:outputLabel>

 <h:inputText id=”username”

 value=”#\{logonBean.username}”/>

 <h:outputLabel for=”password”>

 <h:outputText value=”Password:”/>

 </h:outputLabel>

 <h:inputSecret id=”password”

 value=”#\{logonBean.password}”/>

 <h:commandButton id=”submitButton”
type=”SUBMIT”

 action=”#\{logonBean.logon}”/>

 <h:commandButton id=”resetButton”
type=”RESET”/>

 </h:panelGrid>

</h:form>

|===

=== Registering Converters, Event Listeners, and Validators

Each JSF implementation is required to
provide the core tag library (see link:JSF.html#a4636[See JSF
Core Tag Library]), which includes custom actions that (when executed)
create instances of a specified _Converter_ , _ValueChangeListener,_
_ActionListener_ or _Validator_ implementation class, and register the
created instance with the _UIComponent_ associated with the most
immediately surrounding _UIComponent_ custom action.

Using these facilities, the page author can
manage all aspects of creating and configuring values associated with
the view, without having to resort to Java code. For example:

[width="100%",cols="100%",]
|===
a|
<h:inputText id=”username”
value=”#\{logonBean.username}”>

 <f:validateLength minimum=”6”/>

</h:inputText>

|===

associates a validation check (that the value
entered by the user must contain at least six characters) with the
username _UIInput_ component being described.

Following are usage examples for the
_valueChangeListener_ and _actionListener_ custom actions.

[width="100%",cols="100%",]
|===
a|
<h:inputText id=”maxUsers”>

 <f:convertNumber integerOnly=”true”/>

 <f:valueChangeListener

 type="custom.MyValueChangeListener"/>

</h:inputText>

<h:commandButton label="Login">

 <f:actionListener
type="custom.MyActionListener"/>

</h:commandButton>

|===

This example causes a _Converter_ and a
_ValueChangeListener_ of the user specified type to be instantiated and
added as to the enclosing _UIInput_ component, and an _ActionListener_
is instantiated and added to the enclosing _UICommand_ component. If the
user specified type does not implement the proper listener interface a
_JSPException_ must be thrown.

=== Using Facets

A _Facet_ is a subordinate UIComponent that
has a special relationship to its parent _UIComponent_ , as described in
link:JSF.html#a968[See Facet Management]. Facets can be defined
in a JSP page using the _<f:facet>_ custom action. Each facet action
must have one and only one child UIComponent custom
actionlink:#a9099[16]. For example:

[width="100%",cols="100%",]
|===
a|
<h:dataTable ...>

 <f:facet name=”header”>

 <h:outputText value=”Customer List”/>

 </f:facet>

 <h:column>

 <f:facet name=”header”>

 <h:outputText value=”Account Id”/>

 </f:facet>

 <h:outputText id=”accountId” value=
”#\{customer.accountId}”/>

 </h:column>

 ...

</h:dataTable>

|===

=== [[a4536]]Interoperability with JSP Template Text and Other Tag Libraries

It is permissible to use other tag libraries,
such as the JSP Standard Tag Library (JSTL) in the same JSP page with
_UIComponent_ custom actions that correspond to JSF components, subject
to certain restrictions. When JSF component actions are nested inside
custom actions from other libraries, or combined with template text, the
following behaviors must be supported:

JSF component custom actions nested inside a
custom action that conditionally renders its body (such as JSTL’s
_<c:if>_ or _<c:choose>_ ) must contain a manually assigned _id_
attribute.

Interoperation with the JSTL
Internationalization-Capable Formatting library (typically used with the
“ _fmt_ ” prefix) is restricted as follows:

 The _<fmt:parseDate>_ and
_<fmt:parseNumber>_ custom actions should not be used. The corresponding
JSF facility is to use an _<h:inputText>_ component custom action with
an appropriate _DateTimeConverter_ or _NumberConverter_ .

The _<fmt:requestEncoding>_ custom action
should not be used. By the time it is executed, the request parameters
will have already been parsed, so any change in the setting here will
have no impact. JSF handles character set issues automatically in most
cases. To use a fixed character set in exceptional circumstances, use
the a “ _<%@ page contentType=”[content-type];[charset]” %>_ ”
directive.

The _<fmt:setLocale/>_ custom action should
not be used. Even though it might work in some circumstances, it would
result in JSF and JSTL assuming different locales. If the two locales
use different character sets, the results will be undefined.
Applications should use JSF facilities for setting the _locale_ property
on the _UIViewRoot_ component to change locales for a particular user.

=== Composing Pages from Multiple Sources

JSP pages can be composed from multiple
sources using several mechanisms:

The _<%@include%>_ directive performs a
compile-time inclusion of a specified source file into the page being
compiledlink:#a9100[17]. From the perspective of JSF, such
inclusions are transparent—the page is compiled as if the inclusions had
been performed before compilation was initiated.

Several mechanisms (including the
_<jsp:include>_ standard action, the JSTL _<c:import>_ custom action
when referencing a resource in the same webapp, and a call to
_RequestDispatcher.include()_ for a resource in the same webapp) perform
a runtime dynamic inclusion of the results of including the response
content of the requested page resource in place of the include action.
Any JSF components created by execution of JSF component custom actions
in the included resource will be grafted onto the component tree, just
as if the source text of the included page had appeared in the calling
page at the position of the include action.

For mechanisms that aggregate content by
other means (such as use of an _HttpURLConnection_ , a
_RequestDispatcher.include()_ on a resource from a different web
application, or accessing an external resource with the JSTL
_<c:import>_ custom action on a resource from a different web
application, only the response content of the aggregation request is
available. Therefore, any use of JSF components in the generation of
such a response are not combined with the component tree for the current
page.

=== 

image:SF-40.png[image]

[[a4549]]UIComponent Custom Action Implementation Requirements

The custom action implementation classes for
_UIComponent_ custom actions must conform to all of the requirements
defined in the JavaServer Pages Specification. In addition, they must
meet the following JSF-specific requirements:

Extend the _UIComponentELTag_ or
_UIComponentELBodyTag_ base class, so that JSF implementations can
recognize _UIComponent_ custom actions versus others.

Provide a public _getComponentType()_ method
that returns a String-valued component type registered with the
_Application_ instance for this web application. The value returned by
this method will be passed to _Application.createComponent()_ when a new
_UIComponent_ instance associated with this custom action is to be
created.

Provide a public _getRendererType()_ method
that returns a String-valued renderer type registered with the
_RenderKit_ instance for the currently selected _RenderKit,_ or _null_
if there should be no associated _Renderer_ . The value returned by this
method will be used to set the _rendererType_ property of any
UIComponent created by this custom action.

Provide setter methods taking a
_javax.el.ValueExpression_ or _javax.el.MethodExpression_ parameter for
all set-able (from a custom action) properties of the corresponding
_UIComponent_ class, and all additional set-able (from a custom action)
attributes supported by the corresponding _Renderer_ .

On the method that causes a _UIComponent_
instance to be added to the tree, verify that the component id of that
_UIComponent_ is unique within the scope of the closest ancestor
component that is a _NamingContainer_ . If this constraint is not met,
throw _JspException_ . __

Provide a protected _setProperties()_ method
of type _void_ that takes a _UIComponent_ instance as parameter. The
implementation of this method must perform the following tasks:

Call _super.setProperties()_ , passing the
same _UIComponent_ instance received as a parameter.

For each non-null custom action attribute
that corresponds to a property based attribute to be set on the
underlying component, call either _setValueExpression()_ or
_getAttributes().put()_ , depending on whether or not a value expression
was specified as the custom action attribute value (performing any
required type conversion). For example, assume that title is the name of
a render-dependent attribute for this component:

[width="100%",cols="100%",]
|===
a|
public void setTitle(javax.el.ValueExpression
title) \{

 this.title = title;

}



protected void setProperties(UIComponent
component) throws JspException \{

 super.setProperties(component);

 if (title != null) \{

 try \{

 component.setValueExpression(“title”,
title);

 }

 catch (ELException e) \{

 throw new JspException(e);

 }

 ...

}

|===

For each non-null custom action attribute
that corresponds to a method based attribute to be set on the underlying
component, the value of the attribute must be a method reference
expression. We have a number of wrapper classes to turn a
MethodExpression into the appropriate listener. For example, assume that
_valueChangeListener_ is the name of an attribute for this component:

[width="100%",cols="100%",]
|===
a|
public void
setValueChangeListener(javax.el.MethodExpression me) \{

 valueChangeListener = me;

}



protected void setProperties(UIComponent
component) \{

 super.setProperties(component);

 MethodExpressionValueChangeListener listener
=

 new
MethodExpressionValueChangeListener(valueChangeListener);

 input.addValueChangeListener(listener);

 ...

}

|===

Non-null custom action attributes that
correspond to a writable property to be set on the underlying component
are handled in a similar fashion. For example, assume a custom action
for the _UIData_ component is being created that needs to deal with the
_rows_ property (which is of type _int_ ):

[width="100%",cols="100%",]
|===
a|
public void setRows(javax.el.ValueExpression
rows) \{

 this.rows = rows;

}



protected void setProperties(UIComponent
component) \{

 super.setProperties(component);

 if (rows != null) \{

 try \{

 component.setValueExpression(“rows”, rows);

 } catch (ELException e) \{

 throw new JspException(e);

 }

 }

 ...

}

|===

Optionally, provide a public _release()_
method of type _void_ , taking no parameters, to be called when the JSP
page handler releases this custom action instance. If implemented, the
method must perform the following tasks:

Call _super.release()_ to invoke the
superclass’s release functionality.

Clear the instance variables representing the
values for set-able custom action attributes (for example, by setting
String values to null).

Optionally provide overridden implementations
for the following method to fine tune the behavior of your _UIComponent_
custom action implementation class: _encodeComponent()_ .

It is technically possible to override other
public and protected methods of the _UIComponentELTag_ or
_UIComponentBodyELTag_ base class; however, it is likely that overriding
these methods will interfere with the functionality that other portions
of the JSF implementation are assuming to be present, so overriding
these methods is strongly discouraged.

The definition of each _UIComponent_ custom
action in the corresponding tag library descriptor (TLD) must conform to
the following requirements:

The _<body-content>_ element for the custom
action itself must specify _JSP_ .

For each attribute that is intended to be
passed on to the underlying faces component:

The attribute may not be named _id_ . This
name is reserved for Faces use.

If the attribute represents a method
expression, it must have a _<deferred-method>_ element containing a
_<method-signature>_ element that describes the signature of the method
pointed to by the expression, as described in section JSP.C.1 in the JSP
2.1 specification.

Otherwise, the attribute must be a value
based attribute, and must have a _<deferred-value>_ element containing a
<type> element which describes the expected type to which the expression
will evaluate. Please see section JSP.C.1 in the JSP 2.1 specification
for details.

=== Considerations for Custom Actions written for JavaServer Faces 1.1 and 1.0

Versions 1.0 and 1.1 of the JavaServer Faces
spec included their own EL that happend to have similar semantics to the
JSP EL, but the implementation was bundled into the Faces
implementation. This version leverages a new Unified EL facility
provided by JSP. This change has necessitated deprecating some methods
and classes, including the classes Custom Actions as their base class
for tags that expose Faces components to the JSP page. This section
explains how custom actions built for Faces 1.0 and 1.1 can continue to
run Faces 1.2.

=== Past and Present Tag constraints

Faces 1.0 and 1.1 were targeted at JSP
version 1.2 and Servlet version 2.3. This decision brought about several
constraints for faces tag attributes:

all tag attributes had to declare
_rtexprvalue_ to be _false._

all tag attributes had to take the type
_java.lang.String_ .

Faces had to choose a new expression
delimiter, _#\{}_ , to prevent the JSP container from prematurely
evaluating the expression. This became known as deferred evaluation.

Because Faces had introduced its own version
of the EL, the custom tag action layer had to do a lot of extra work to
“value binding enable” its attributes, calling Faces EL APIs to turn the
String attribute value into an instance of _ValueBinding_ or
_MethodBinding_ .

Faces provided the _UIComponentTag_ and
_UIComponentBodyTag_ base classes that were designed to adhere to the
above rules.

Tags that use the Unified EL have the
following constraints:

all tag attributes must not have an
_rtexprvalue_ attribute

all tag attributes must accept
_javax.el.ValueExpression_ or _javax.el.MethodExpression_ as their type
(depending on if the attribute refers to a method or a value).

all tag attributes (except for _id_ ) must
have a _<deferred-value>_ or _<deferred-method>_ element. See
_link:JSF.html#a4636[See JSF Core Tag Library]_ in the
description for the _Attributes_ column.

The JSP Container will hand the tag setter a
_javax.el.ValueExpression_ or _javax.el.MethodExpression_ directly, so
there is no need to use the Faces API to create them.

The _UIComponentTag_ and _UIComponentBodyTag_
classes are deprecated and Faces provides new base class,
UIComponentELTag to the new rules for taglibs in Faces.

It’s very important to note that we still are
using #\{} as the delimiters for expressions that appear in a JSP page
in the value of a tag attribute, but when the Java API is used, either
$\{} or #\{} may be used for delimiters.

=== [[a4629]]Faces 1.0 and 1.1 Taglib migration story

It is imperitive that applications written
for Faces 1.0 and 1.1 continue to run on Faces 1.2. From the JSP
perspective, this means

that JSP pages using the standard h: and f:
tags must work without change

that JSP pages using custom faces taglibs
must work without change

The first item is enabled by re-writing the
h: and f: taglibs which must be provided by the Faces implementor.

The second item is enabled as follows. For
discussion the term _jsp-version_ is used to denote the _jsp-version_
element in a JSP 1.2 (and earlier) TLD, as well as the _version_ element
in a JSP 2.0 (and later) TLD. The JSP container must examine the
_jsp-version_ element of the TLD for a taglib. If the _jsp-version_ is
less than 2.1, the taglib is deemed to be a Faces 1.0 or 1.1 taglib and
the container must ignore all expressions that use #\{} as delimiters,
except for those appearing in tag attribute with a property setter that
takes a _javax.el.ValueExpression_ or _javax.el.MethodExpression_ . If
the _jsp-version_ is 2.1 or greater, the taglib is deemed to be a Faces
1.2 or later taglib and the JSP container is aware of #\{} expressions.

=== 

image:SF-40.png[image]

[[a4636]]JSF Core Tag Library

[P1-start jsf_core taglib requirements] All
JSF implementations must provide a tag library containing core actions
(described below) that are independent of a particular _RenderKit_ . The
corresponding tag library descriptor must meet the following
requirements:

Must declare a tag library version (
_<tlib-version>_ ) value of _1.2_ .

Must declare a URI ( _<uri>_ ) value of
_http://java.sun.com/jsf/core_ .

{empty}Must be included in the _META-INF_
directory of a JAR file containing the corresponding implementation
classes, suitable for inclusion with a web application, such that the
tag library descriptor will be located automatically by the algorithm
described in Section 7.3 of the _JavaServer Pages Specification_
(version 2.1). [P1-end]

{empty}[P1-start no javascript in jsf_core
taglib] The tags in the implementation of this tag library must not
cause JavaScript to be rendered to the client. Doing so would break the
requirement that the JSF Core Tag library is independent of any specific
RenderKit. [P1-end]

Each custom action included in the JSF Core
Tag Library is documented in a subsection below, with the following
outline for each action:

Name—The name of this custom action, as used
in a JSP page.

Short Description—A summary of the behavior
implemented by this custom action.

Syntax—One or more examples of using this
custom action, with the required and optional sets of attributes that
may be used together. If the tag may have an _id_ attribute, its value
may be a literal string, or an immediate, non-defferd expression, such
as “ _userName_ ” or “ _user$\{i}_ ” without the quotes.

Body Content—The type of nested content for
this custom action, using one of the standard values _empty_ , _JSP_ ,
or _tagdependent_ as described in the JSP specification. This section
also describes restrictions on the types of content (template text, JSF
core custom actions, JSF _UIComponent_ custom actions, and/or other
custom actions) that can be nested in the body of this custom action.

Attributes—A table containing one row for
each defined attribute for this custom action. The following columns
provide descriptive information about each attribute:

Name—Name of this attribute, as it must be
used in the page. If the name of the attribute is in _italics_ , it is
required.

Expr—The type of dynamic expression (if any)
that can be used in this attribute value. Legal values are VE (this may
be a literal or a value expression), ME (this may be a method
expression), or NONE (this attribute accepts literal values only). If
the _Expr_ column is VE, the corresponding _<attribute>_ declaration in
the TLD must contain a _<deferred-value>_ element, optionally containing
a _<type>_ element that contains the fully qualified java class name of
the expected type of the expression. If _<type>_ is omitted,
Object.class is assumed. If the _Expr_ column is ME, the corresponding
_<attribute>_ declaration in the TLD must contain a _<deferred-method>_
element, containing a _<method-signature>_ element that describes the
exact method signature for the method. In this case, the _Description_
column the description column contains the method signature.

Type—Fully qualified Java class or primitive
type of this attribute.

Description—The functional meaning of this
attribute’s value.

Constraints—Additional constraints enforced
by this action, such as combinations of attributes that may be used
together.

Description—Details about the functionality
provided by this custom action.

=== [[a4654]]<f:actionListener>

Register an _ActionListener_ instance on the
_UIComponent_ associated with the closest parent _UIComponent_ custom
action.

=== Syntax

<f:actionListener
type=”fully-qualified-classname” binding=”value Expression”/>

=== Body Content

empty.

=== Attributes

[width="100%",cols="25%,25%,25%,25%",options="header",]
|===
|Name |Expr
|Type |Description
| _type_ | _VE_
| _String_ |Fully
qualified Java class name of an _ActionListener_ to be created and
registered

|binding | _VE_
| _ValueExpression_
|A _ValueExpression_ expression that
evaluates to an object that implements
_javax.faces.event.ActionListener_
|===

=== Constraints

Must be nested inside a _UIComponent_ custom
action.

The corresponding _UIComponent_
implementation class must implement _ActionSource_ , and therefore
define a public _addActionListener()_ method that accepts an
_ActionListener_ parameter.

The specified listener class must implement
_javax.faces.event.ActionListener_ .

 _type_ and/or binding must be specified.

[P1-start f:actionListener constraints] If
this tag is not nested inside a _UIComponent_ custom action, or the
_UIComponent_ implementation class does not correctly implement
_ActionSource_ , or the specified listener class does not implement
_javax.faces.event.ActionListener_ , throw a _JspException_ . [P1-end]
Note that if the binding attribute is used, the scope of the
_ValueExpression_ must be chosen carefully so as not to introduce
undesireable results. In general, when using the binding attribute, do
not point to beans in request or narrower scope.

=== Description

Locate the closest parent _UIComponent_
custom action instance by calling
_UIComponentClassicTagBase.getParentUIComponentClassicTagBase()_ . If
the _getCreated()_ method of this instance returns _true,_ check the
binding attribute.

If binding is set, create a _ValueExpression_
by invoking _Application.createValueExpression_ () with binding as the
expression argument, and _Object.class_ as the expectedType argument.
Use the _ValueExpression_ to obtain a reference to the _ActionListener_
instance. If there is no exception thrown, and
_ValueExpression.getValue()_ returned a non-null object that implements
_javax.faces.event.ActionListener_ , register it by calling
_addActionListener()._ If there was an exception thrown, rethrow the
exception as a _JspException._

If the listener instance could not be
created, check the _type_ attribute _._ If the _type_ attribute is set,
instantiate an instance of the specified class, and register it by
calling _addActionListener()_ . If the binding attribute was also set,
evaluate the expression into a _ValueExpression_ and store the listener
instance by calling _setValue()_ on the _ValueExpression_ . If there was
an exception thrown, rethrow the exception as a _JspException._

As an alternative to using the binding and/or
type attributes, you may also register a method in a backing bean class
to receive _ActionEvent_ notifications, by using the _actionListener_
attribute on the corresponding _UIComponent_ custom action.

=== [[a4679]]<f:attribute>

Add an attribute or _ValueExpression_ on the
_UIComponent_ associated with the closest parent _UIComponent_ custom
action.

=== Syntax

<f:attribute name=”attribute-name”
value=”attribute-value”/>

=== Body Content

empty.

=== Attributes

[width="100%",cols="25%,25%,25%,25%",options="header",]
|===
|Name |Expr
|Type |Description
| _name_ | _VE_
| _String_ |Name
of the component attribute to be set

| _value_ | _VE_
| _Object_ |Value
of the component attribute to be set
|===

=== Constraints

Must be nested inside a _UIComponent_ custom
action.

=== Description

Locate the closest parent _UIComponent_
custom action instance by calling
_UIComponentClassicTagBase.getParentUIComponentClassicTagBase()_ . Call
the _getValue()_ method on the argument _name_ to obtain the name of the
attribute. If the associated component already has a component attribute
with that name, take no action. Otherwise, call the _isLiteralText()_
method on the argument _value_ . If it returns _true_ , store the value
in the component’s attribute Map under the name derived above. If it
returns _false_ , store the _ValueExpression_ in the component’s
_ValueExpression_ Map under the name derived above.

There is no standard implementation class for
this action. It must be provided by the implementation.

=== [[a4697]]<f:convertDateTime>

Register a _DateTimeConverter_ instance on
the _UIComponent_ associated with the closest parent _UIComponent_
custom action.

=== Syntax

<f:convertDateTime

{empty}
[dateStyle=”\{default|short|medium|long|full}”]

{empty} [locale=”\{ _locale_ ” | string}]

{empty} [pattern=” _pattern_ ”]

{empty}
[timeStyle=”\{default|short|medium|long|full}”]

{empty} [timeZone=”\{ _timeZone_ | string}”]

{empty}
[type=”\{date|time|both|localDate|localDateTime|localTime|offsetTime|offsetDateTime| +
zonedDateTime}”]

 [binding=”Value Expression”]/>

=== Body Content

empty.

=== Attributes

[width="100%",cols="25%,25%,25%,25%",options="header",]
|===
|Name |Expr
|Type |Description
|date-Style |VE
|String
|Predefined formatting style which determines
how the date component of a date string is to be formatted and parsed.
Applied only if type is "date", "both", "localDate", "localDateTime", or
"zonedDateTime". Valid values are "default", "short", "medium", "long",
and "full". Default value is "default". If a java.time formatter is
being used, yet the dateStyle is set to "default", the value "medium" is
assumed.

|locale |VE
|Locale or String
|Locale whose predefined styles for dates and
times are used during formatting or parsing. If not specified, the
Locale returned by FacesContext.getViewRoot().getLocale() will be used.
Value must be either a VE expression that evaluates to a
java.util.Locale instance, or a String that is valid to pass as the
first argument to the constructor java.util.Locale(String language,
String country). The empty string is passed as the second argument.

|pattern |VE
|String |Custom
formatting pattern which determines how the date/time string should be
formatted and parsed.

|time-Style |VE
|String
|Predefined formatting style which determines
how the time component of a date string is to be formatted and parsed.
Applied only if type is "time", "both", "localTime" or "offsetTime".
Valid values are "default", "short", "medium", "long", and "full".
Default value is "default". If a java.time formatter is being used, yet
the timeStyle is set to "default", the value "medium" is assumed.

|time-Zone |VE
|timezone or String
|Time zone in which to interpret any time
information in the date string. Value must be either a VE expression
that evaluates to a java.util.TimeZone instance, or a String that is a
timezone ID as described in the javadocs for
java.util.TimeZone.getTimeZone().

|type |VE
|String |Specifies
what contents the string value will be formatted to include, or parsed
expecting. Valid values are "date", "time", "both", "localDate",
"localDateTime", "localTime", "offsetTime", "offsetDateTime", and
"zonedDateTime". The values starting with "local", "offset" and "zoned"
correspond to Java SE 8 Date Time API classes in package java.time with
the name derived by upper casing the first letter. For example,
java.time.LocalDate for the value "localDate". Default value is "date".

|binding |VE
|ValueExpression
|A _ValueExpression_ expression that
evaluates to an object that implements _javax.faces.convert.Converter_
|===

=== Constraints

Must be nested inside a _UIComponent_ custom
action whose component class implements _ValueHolder_ , and whose value
is a _java.util.Date_ (or appropriate subclass).

If _pattern_ is specified, the pattern syntax
must use the pattern syntax specified by _java.text.SimpleDateFormat_ or
_java.time.format.DateTimeFormatter_ depending on the value of type.

If _pattern_ is not specified, formatted
strings will contain a date value, a time value, or both depending on
the specified _type_ . When date or time values are included, they will
be formatted according to the specified _dateStyle_ and _timeStyle_ ,
respectively.

if _type_ is not specified:

if _dateStyle_ is set and _timeStyle_ is not,
_type_ defaults to _date_

if _timeStyle_ is set and _dateStyle_ is not,
_type_ defaults to _time_

if both _dateStyle_ and _timeStyle_ are set,
_type_ defaults to _both_

{empty}[P1-start f:convertDateTime
constraints] If this tag is not nested inside a _UIComponent_ custom
action, or the _UIComponent_ implementation class does not correctly
implement _ValueHolder_ , throw a _JspException_ [P1-end]

=== Description

Locate the closest parent _UIComponent_
custom action instance by calling
_UIComponentClassicTagBase.getParentUIComponentClassicTagBase()_ . If
the _getCreated()_ method of this instance returns _true_ , create, call
_createConverter()_ and register the returned Converter instance on the
associated UIComponent.

[P1-start f:convertDateTime implementation
requirements ]The implementation class for this action must meet the
following requirements:

Must extend
_javax.faces.webapp.ConverterELTag_ .

The _createConverter()_ method must:

If _binding_ is non-null, call _getValue()_
on it to obtain a reference to the _Converter_ instance. If there is no
exception thrown, and _binding.getValue()_ returned a non-null object
that implements _javax.faces.convert.Converter_ , it must then cast the
returned instance to _javax.faces.convert.DateTimeConverter_ and
configure its properties based on the specified attributes for this
custom action, and return the configured instance. If there was an
exception thrown, rethrow the exception as a _JspException._

use the _converterId_ if the converter
instance could not be created from the _binding_ attribute. Call the
_createConverter()_ method of the _Application_ instance for this
application, passing converter id “javax.faces.DateTime”. If the binding
attribute was also set, store the converter instance by calling
_binding.setValue()_ . It must then cast the returned instance to
_javax.faces.convert.DateTimeConverter_ and configure its properties
based on the specified attributes for this custom action, and return the
configured instance. If there was an exception thrown, rethrow the
exception as a _JspException._

If the type attribute is not specified, it
defaults as follows:

 If dateStyle is specified but timeStyle is
not specified, default to date.

If dateStyle is not specified but timeStyle
is specified, default to time.

{empty}If both dateStyle and timeStyle are
specified, default to both. [P1-end]

=== [[a4752]]<f:convertNumber>

Register a _NumberConverter_ instance on the
_UIComponent_ associated with the closest parent _UIComponent_ custom
action.

=== Syntax

<f:convertNumber

{empty} [currencyCode=” _currencyCode_ ”]

{empty} [currencySymbol=” _currencySymbol_ ”]

{empty} [groupingUsed=”\{true|false}”]

{empty} [integerOnly=”\{true|false}”]

{empty} [locale=” _locale_ ”]

{empty} [maxFractionDigits=”
_maxFractionDigits_ ”]

{empty} [maxIntegerDigits=”
_maxIntegerDigits_ ”]

{empty} [minFractionDigits=”
_minFractionDigits_ ”]

{empty} [minIntegerDigits=”
_minIntegerDigits_ ”]

{empty} [pattern=” _pattern_ ”]

{empty} [type=”\{number|currency|percent}”]

 [binding=”Value Expression”]/>

=== Body Content

empty.

=== Attributes

[width="100%",cols="25%,25%,25%,25%",options="header",]
|===
|Name |Expr
|Type |Description
|currencyCode |VE
|String |ISO 4217
currency code, applied only when formatting currencies.

|currencySymbol
|VE |String
|Currency symbol, applied only when
formatting currencies.

|groupingUsed |VE
|boolean
|Specifies whether formatted output will
contain grouping separators.

|integerOnly |VE
|boolean
|Specifies whether only the integer part of
the value will be parsed.

|locale |VE
|java.util.Locale
|Locale whose predefined styles for numbers
are used during formatting or parsing. If not specified, the Locale
returned by FacesContext.getViewRoot().getLocale() will be used.

|maxFractionDigits
|VE |int
|Maximum number of digits that will be
formatted in the fractional portion of the output.

|maxIntegerDigits
|VE |int
|Maximum number of digits that will be
formatted in the integer portion of the output

|minFractionDigits
|VE |int
|Minimum number of digits that will be
formatted in the fractional portion of the output.

|minIntegerDigits
|VE |int
|Minimum number of digits that will be
formatted in the integer portion of the output.

|pattern |VE
|String |Custom
formatting pattern which determines how the number string should be
formatted and parsed.

|type |VE
|String |Specifies
whether the value will be parsed and formatted as a number, currency, or
percentage.

|binding |VE
|ValueExpression
|A _ValueExpression_ expression that
evaluates to an object that implements _javax.faces.convert.Converter_
|===

=== Constraints

Must be nested inside a _UIComponent_ custom
action whose component class implements _ValueHolder_ , and whose value
is a numeric wrapper class or primitive.

If _pattern_ is specified, the pattern syntax
must use the pattern syntax specified by _java.text.DecimalFormat_ .

If _pattern_ is not specified, formatting and
parsing will be based on the specified _type_ .

{empty}[P1-start f:convertNumber constraints]
If this tag is not nested inside a _UIComponent_ custom action, or the
_UIComponent_ implementation class does not correctly implement
_ValueHolder_ , throw a _JspException_ . [P1-end]

=== Description

Locate the closest parent _UIComponent_
custom action instance by calling
_UIComponentClassicTagBase.getParentUIComponentClassicTagBase()_ . If
the _getCreated()_ method of this instance returns _true_ , create, call
_createConverter()_ and register the returned Converter instance on the
associated UIComponent.

[P1-start f:convertNumber implementation] The
implementation class for this action must meet the following
requirements:

Must extend
_javax.faces.webapp.ConverterELTag_ .

The _createConverter()_ method must:

If _binding_ is non-null, call
_binding.getValue()_ to obtain a reference to the _Converter_ instance.
If there is no exception thrown, and _binding.getValue()_ returned a
non-null object that implements _javax.faces.convert.Converter_ , it
must then cast the returned instance to
_javax.faces.convert.NumberConverter_ and configure its properties based
on the specified attributes for this custom action, and return the
configured instance. If there was an exception thrown, rethrow the
exception as a _JspException._

{empty}use the _converterId_ if the converter
instance could not be created from the _binding_ attribute. Call the
_createConverter()_ method of the _Application_ instance for this
application, passing converter id “javax.faces.Number”. If the binding
attribute was also set, store the converter instance by calling
_binding.setValue()_ . It must then cast the returned instance to
_javax.faces.convert.NumberConverter_ and configure its properties based
on the specified attributes for this custom action, and return the
configured instance. If there was an exception thrown, rethrow the
exception as a _JspException_ . [P1-end]

=== <f:converter>

Register a named _Converter_ instance on the
_UIComponent_ associated with the closest parent _UIComponent_ custom
action.

=== Syntax

<f:converter converterId=”converterId”
binding=”Value Expression”/>

=== Body Content

empty

=== Attributes

[width="100%",cols="25%,25%,25%,25%",options="header",]
|===
|Name |Expr
|Type |Description
| _converterId_ |
_VE_ | _String_
|Converter identifier of the converter to be
created.

|binding |VE
|ValueExpression
|A _ValueExpression_ expression that
evaluates to an object that implements _javax.faces.convert.Converter_
|===

=== Constraints

Must be nested inside a _UIComponent_ custom
action whose component class implements _ValueHolder_ .

 _converterId_ and/or binding must be
specified.

{empty}[P1-start f:converter constraints] If
this tag is not nested inside a _UIComponent_ custom action, or the
_UIComponent_ implementation class does not correctly implement
_ValueHolder_ , throw a _JspException_ . [P1-end]

=== Description

Locate the closest parent _UIComponent_
custom action instance by calling
_UIComponentClassicTagBase.getParentUIComponentClassicTagBase()_ . If
the _getCreated()_ method of this instance returns _true_ , create, call
_createConverter()_ and register the returned Converter instance on the
associated UIComponent.

[P1-start f:converter implementation] The
implementation class for this action must meet the following
requirements:

Must extend
_javax.faces.webapp.ConverterJspTag_ .

The _createConverter()_ method must:

{empty}If _binding_ is non-null, call
_binding.getValue()_ to obtain a reference to the _Converter_ instance.
If there is no exception thrown, and _binding.getValue()_ returned a
non-null object that implements _javax.faces.convert.Converter_ ,
register it by calling _setConverter()._ If there was an exception
thrown, rethrow the exception as a _JspException._ Use the _converterId_
attribute if the converter instance could not be created from the
_binding_ attribute _._ If the _converterId_ attribute is set, call the
_createConverter()_ method of the _Application_ instance for this
application, passing converter id specified by their converterId
attribute. If the binding attribute was also set, store the converter
instance by calling _binding.setValue()_ . Register the converter
instance by calling _setConverter()._ If there was an exception thrown,
rethrow the exception as a _JspException_ . [P1-end]

=== [[a4843]]<f:facet>

Register a named facet (see
link:JSF.html#a968[See Facet Management]) on the _UIComponent_
associated with the closest parent _UIComponent_ custom action.

=== Syntax

<f:facet name=”facet-name”/>

=== Body Content

JSP. However, only a single UIComponent
custom action (and any related nested JSF custom actions) is allowed; no
template text or other custom actions may be present.

=== Attributes

[width="100%",cols="25%,25%,25%,25%",options="header",]
|===
|Name |Expr
|Type |Description
| _name_ | _NONE_
| _String_ |Name
of the facet to be created
|===

=== Constraints

[P1-start f:facet constraints] Must be nested
inside a _UIComponent_ custom action.

{empty}Exactly one _UIComponent_ custom
action must be nested inside this custom action (although the nested
component custom action could itself have nested children). [P1-end]

=== Description

Locate the closest parent _UIComponent_
custom action instance by calling
_UIComponentClassicTagBase.getParentUIComponentClassicTagBase()_ . If
the associated component does not already have a facet with a name
specified by this custom action’s _name_ attribute, create a facet with
this name from the _UIComponent_ custom action that is nested within
this custom action.

{empty}[P1-start f:facet implementation] The
implementation class must be, or extend, _javax.faces.webapp.FacetTag_ .
[P1-end]

=== [[a4860]]<f:loadBundle>

Load a resource bundle localized for the
locale of the current view, and expose it (as a Map) in the request
attributes for the current request.

=== Syntax

<f:loadBundle basename=”resource-bundle-name”
var=” _attributeKey_ ”/>

=== Body Content

empty

=== Attributes

[width="100%",cols="25%,25%,25%,25%",options="header",]
|===
|Name |Expr
|Type |Description
| _basename_ |
_VE_ | _String_
|Base name of the resource bundle to be
loaded.

|var |NONE
|String |Name of a
request scope attribute under which the resource bundle will be exposed
as a Map.
|===

=== Constraints

{empty}[P1-start f:loadBundle constraints]
Must be nested inside an _<f:view>_ custom action. [P1-end]

=== Description

Load the resource bundle specified by the
_basename_ attribute, localized for the Locale of the _UIViewRoot_
component of the current view, and expose its key-values pairs as a
_Map_ under the attribute key specified by the _var_ attribute. In this
way, value binding expressions may be used to conveniently retrieve
localized values. If the named bundle is not found, throw _JspException_
.

If the _get()_ method for the _Map_ instance
exposed by this custom action is passed a key value that is not present
(that is, there is no underlying resource value for that key), the
literal string “???foo???” (where “foo” is replaced by the key the
String representation of the key that was requested) must be returned,
rather than the standard _Map_ contract return value of _null_ .

=== <f:param>

Add a child _UIParameter_ component to the
_UIComponent_ associated with the closest parent _UIComponent_ custom
action.

=== Syntax

=== Syntax 1: Unnamed value

<f:param
[id=”componentIdOrImmediateExpression”] value=”parameter-value”

 [binding=” _componentReference”]_ />

=== Syntax 2: Named value

{empty}<f:param
[id=”componentIdOrImmediateExpression”]

 [binding=” _componentReference”]_

 name=”parameter-name”
value=”parameter-value”/>

=== Body Content

empty.

=== Attributes

[width="100%",cols="25%,25%,25%,25%",options="header",]
|===
|Name |Expr
|Type |Description
|binding |VE
|ValueExpression
|ValueExpression expression to a backing bean
property bound to the component instance for the UIComponent created by
this custom action

| _id_ | _NONE_
| _String_
|Component identifier of a _UIParameter_
component

| _name_ | _VE_
| _String_ |Name
of the parameter to be set

| _value_ | _VE_
| _String_ |Value
of the parameter to be set
|===

=== Constraints

{empty}[P1-start f:param constraints] Must be
nested inside a _UIComponent_ custom action. [P1-end]

=== Description

Locate the closest parent _UIComponent_
custom action instance by calling
_UIComponentClassicTagBase.getParentUIComponentClassicTagBase()_ . If
the _getCreated()_ method of this instance returns _true_ , create a new
_UIParameter_ component, and attach it as a child of the associated
_UIComponent_ . It is up to the parent _UIComponent_ to determine how it
will handle its _UIParameter_ child _ren._

[P1-start f:param implementation] The
implementation class for this action must meet the following
requirements:

Must extend _javax.faces.UIComponentELTag_ .

The _getComponentType()_ method must return “
_Parameter_ ”.

{empty}The _getRendererType()_ method must
return _null_ . [P1-end]

=== <f:phaseListener>

Register a _PhaseListener_ instance on the
_UIViewRoot_ associated with the closest parent _UIViewRoot_ custom
action.

=== Syntax

<f:phaseListener
type=”fully-qualified-classname”

binding=”Value expression”/>

=== Body Content

empty.

=== Attributes

[width="100%",cols="25%,25%,25%,25%",options="header",]
|===
|Name |Expr
|Type |Description
| _type_ | _VE_
| _String_ |Fully
qualified Java class name of an _PhaseListener_ to be created and
registered

|binding | _VE_
| _ValueExpression_
|A _ValueExpression_ expression that
evaluates to an object that implements _javax.faces.event.PhaseListener_
|===

=== Constraints

[P1-start f:phaseListener constraints] Must
be nested inside a _UIViewRoot_ custom action.

The specified listener class must implement
_javax.faces.event.PhaseListener_ .

{empty} _type_ and/or binding must be
specified. [P1-end]

=== Description

Locate the one and only _UIViewRoot_ custom
action instance by walking up the tag tree until you find a
_UIComponentTagBase_ instance that has no parent. If the _getCreated()_
method of this instance returns _true,_ check the binding attribute.

If binding is set, call _binding.getValue()_
to obtain a reference to the _PhaseListener_ instance. If there is no
exception thrown, and _binding.getValue()_ returned a non-null object
that implements _javax.faces.event.PhaseListener_ , register it by
calling _addPhaseListener()._ If there was an exception thrown, rethrow
the exception as a _JspException._

If the listener instance could not be
created, check the _type_ attribute _._ If the _type_ attribute is set,
instantiate an instance of the specified class, and register it by
calling _addPhaseListener()_ . If the binding attribute was also set,
store the listener instance by calling _binding.setValue()_ . If there
was an exception thrown, rethrow the exception as a _JspException._

=== <f:selectItem>

Add a child _UISelectItem_ component to the
_UIComponent_ associated with the closest parent _UIComponent_ custom
action.

=== Syntax

=== Syntax 1: Directly Specified Value

{empty}<f:selectItem
[id=”componentIdOrImmediateExpression”]

 [binding=” _componentReference”]_

{empty} [itemDisabled=”\{true|false}”]

 itemValue=” _itemValue”_

 itemLabel=” _itemLabel”_

 [itemDescription=” _itemDescription”]_ />

=== Syntax 2: Indirectly Specified Value

{empty}<f:selectItem
[id=”componentIdOrImmediateExpression”]

 [binding=” _componentReference”]_

 value=” _selectItemValue”/>_

===  Body Content

empty

=== Attributes

[width="100%",cols="25%,25%,25%,25%",options="header",]
|===
|Name |Expr
|Type |Description
|binding |VE
| _ValueExpression_
| _ValueExpression_ expression to a backing
bean property bound to the component instance for the UIComponent
created by this custom action.

| _id_ | _NONE_
| _String_
|Component identifier of a _UISelectItem_
component.

| _itemDescription_
| _VE_ | _String_
|Description of this option (for use in
development tools).

|itemDisabled |VE
|boolean |Flag
indicating whether the option created by this component is disabled.

|itemLabel |VE
|String |Label to
be displayed to the user for this option.

|itemValue |VE
|Object |Value to
be returned to the server if this option is selected by the user.

|value |VE
|javax.faces.model.SelectItem
|Value binding pointing at a SelectItem
instance containing the information for this option.

|escape |VE
|boolean
|ValueExpression pointing to a boolean that
tells whether or not the label of this selectItem should be escaped per
HTML rules. Default is true.
|===

=== Constraints

{empty}[P1-start f:selectItem constraints]
Must be nested inside a _UIComponent_ custom action that creates a
_UISelectMany_ or _UISelectOne_ component instance.[P1-end]

=== Description

Locate the closest parent _UIComponent_
custom action instance by calling
_UIComponentClassicTagBase.getParentUIComponentClassicTagBase()_ . If
the _getCreated()_ method of this instance returns _true_ , create a new
_UISelectItem_ component, and attach it as a child of the associated
_UIComponent_ .

[P1-start f:selectItem implementation] The
implementation class for this action must meet the following
requirements:

Must extend _javax.faces.UIComponentELTag_ .

The _getComponentType()_ method must return “
_SelectItem_ ”.

{empty}The _getRendererType()_ method must
return _null_ .[P1-end]

=== <f:selectItems>

Add a child _UISelectItems_ component to the
_UIComponent_ associated with the closest parent _UIComponent_ custom
action.

=== Syntax

{empty}<f:selectItems
[id=”componentIdOrImmediateExpression”]

 [binding=” _componentReference”]_

 value=” _selectItemsValue”_ />

===  Body Content

empty

=== Attributes

[width="100%",cols="25%,25%,25%,25%",options="header",]
|===
|Name |Expr
|Type |Description
|binding |VE
| _ValueExpression_
| _ValueExpression_ expression to a backing
bean property bound to the component instance for the UIComponent
created by this custom action.

| _id_ | _NONE_
| _String_
|Component identifier of a _UISelectItem_
component.

| _value_ |VE
|javax.faces.model.SelectItem, see
description for specific details a|
Value binding expression pointing at one of
the following instances:

an individual javax.faces.model.SelectItem

a java language array of
javax.faces.model.SelectItem

a java.util.Collection of
javax.faces.model.SeleccItem

A java.util.Map where the keys are converted
to Strings and used as labels, and the corresponding values are
converted to Strings and used as values for newly created
javax.faces.model.SelectItem instances. The instances are created in the
order of the iterator over the keys provided by the Map.

|===

=== Constraints

Must be nested inside a _UIComponent_ custom
action that creates a _UISelectMany_ or _UISelectOne_ component
instance.

=== Description

Locate the closest parent _UIComponent_
custom action instance by calling
_UIComponentClassicTagBase.getParentUIComponentClassicTagBase()_ . If
the _getCreated()_ method of this instance returns _true_ , create a new
_UISelectItems_ component, and attach it as a child of the associated
_UIComponent_ .

[P1-start f:selectItems implementation]The
implementation class for this action must meet the following
requirements:

Must extend _javax.faces.UIComponentELTag_ .

The _getComponentType()_ method must return “
_javax.faces.SelectItems_ ”.

{empty}The _getRendererType()_ method must
return _null_ . [P1-end]

=== [[a5015]]<f:setPropertyActionListener>

Tag implementation that creates a special
_ActionListener_ instance and registers it on the _ActionSource_
associated with our most immediate surrounding instance of a tag whose
implementation class is a subclass of _UIComponentTag_ . This tag
creates no output to the page currently being created. This tag is
useful for pushing a specific value into a managed bean on page submit.

=== Syntax

<f:setPropertyActionListener target=”Value
Expression” value=”value Expression”/>

=== Body Content

empty.

=== Attributes

[width="100%",cols="25%,25%,25%,25%",options="header",]
|===
|Name |Expr
|Type |Description
| _value_ | _VE_
| _ValueExpression_
|The _ValueExpression_ from which the value
is taken.

|target | _VE_
| _ValueExpression_
|The _ValueExpression_ into which the
evaluated value from the “ _value_ ” attribute is stored when the
listener executes.
|===

=== Constraints

Must be nested inside a _UIComponent_ custom
action.

The corresponding _UIComponent_
implementation class must implement _ActionSource_ , and therefore
define a public _addActionListener()_ method that accepts an
_ActionListener_ parameter.

The tag implementation must only create and
register the _ActionListener_ instance the first time the component for
this tag is created

When the listener executes:

Call _getValue()_ on the " _value_ "
_ValueExpression_ .

If value of the "value" expression is null,
call _setValue()_ on the "target" _ValueExpression_ with the null value.

If the value of the "value" expression is not
null, call _getType()_ on the "value" and "target" _ValueExpressions_ to
determine their property types.

Coerce the value of the "value" expression to
the "target" expression value type following the Expression Language
coercion rules. Call _setValue()_ on the "target" _ValueExpression_ with
the resulting value.

If either conversion or the execution of
setValue() fails throw an AbortProcessingException.

This tag creates no output to the page
currently being created. It is used solely for the side effect of
_ActionListener_ creation and addition.

{empty}[P1-start f:setPropertyActionListener
constraints]If this tag is not nested inside a _UIComponent_ custom
action, or the _UIComponent_ implementation class does not correctly
implement _ActionSource_ , or the specified listener class does not
implement _javax.faces.event.ActionListener_ , throw a _JspException_ .
[P1-end]

=== Description

Locate the closest parent _UIComponent_
custom action instance by calling
_UIComponentClassicTagBase.getParentUIComponentClassicTagBase()_ . If
the _getCreated()_ method of this instance returns _true_ return
_SKIP_BODY_ .

Create an instance of _ActionListener_ that
implements _StateHolder_ and stores the _target_ and _value_
_ValueExpression_ instances as instance variables included in the state
saving contract. The _processAction()_ method of the listener must call
_getValue()_ on the _value_ _ValueExpression_ and convert the value
before passing the result to a call to _setValue()_ on the _target_
_ValueExpression_ .

=== <f:subview>

Container action for all JSF core and
component custom actions used on a nested page included via
_<jsp:include>_ or any custom action that dynamically includes another
page from the same web application, such as JSTL’s _<c:import>_ .

=== Syntax

[width="100%",cols="100%",]
|===
a|
<f:subview id=”
_componentIdOrImmediateExpression_ ”

 [binding=” _componentReference”]_

 [rendered=”\{true|false}”]>

 Nested template text and custom actions

</f:subview>

|===

=== Body Content

JSP. May contain any combination of template
text, other JSF custom actions, and custom actions from other custom tag
libraries.

=== Attributes

[width="100%",cols="25%,25%,25%,25%",options="header",]
|===
|Name |Expr
|Type |Description
|binding |VE
| _ValueExpression_
| _ValueExpression_ expression to a backing
bean property bound to the component instance for the UIComponent
created by this custom action.

| _id_ | _NONE_
| _String_
|Component identifier of a
_UINamingContainer_ component

|rendered |VE
|Boolean |Whether
or not this subview should be rendered.
|===

=== Constraints

[P1-start f:subview constraints] Must be
nested inside a _<f:view>_ custom action (although this custom action
might be in a page that is including the page containing the
_<f:subview>_ custom action.

Must not contain an _<f:view>_ custom action.

Must have an _id_ attribute whose value is
unique within the scope of the parent naming container. If this
constraint is not met, the action taken regarding id uniqueness in
section link:JSF.html#a4549[See UIComponent Custom Action
Implementation Requirements] must be taken

{empty}May be placed in a parent page (with
_<jsp:include>_ or _<c:import>_ nested inside), or within the nested
page. [P1-end]

=== Description

Locate the closest parent _UIComponent_
custom action instance by calling
_UIComponentClassicTagBase.getParentUIComponentClassicTagBase()_ . If
the _getCreated()_ method of this instance returns _true_ , create a new
_UINamingContainer_ component, and attach it as a child of the
associated _UIComponent_ . Such a component provides a scope within
which child component identifiers must still be unique, but allows child
components to have the same simple identifier as child components nested
in some other naming container. This is useful in several scenarios:

[width="100%",cols="100%",]
|===
a|
“main.jsp”

<f:view>

 <c:import url=”foo.jsp”/>

 <c:import url=”bar.jsp”/>

</f:view>



“foo.jsp”

<f:subview id=”aaa”>

 ... components and other content ...

</f:subview>



“bar.jsp”

<f:subview id=”bbb”>

 ... components and other content ...

</f:subview>

|===

In this scenario, _<f:subview>_ custom
actions in imported pages establish a naming scope for components within
those pages. Identifiers for _<f:subview>_ custom actions nested in a
single _<f:view>_ custom action must be unique, but it is difficult for
the page author (and impossible for the JSP page compiler) to enforce
this restriction.

[width="100%",cols="100%",]
|===
a|
“main.jsp”

<f:view>

 <f:subview id=”aaa”>

 <c:import url=”foo.jsp”/>

 </f:subview>

 <f:subview id=”bbb”>

 <c:import url=”bar.jsp”/>

 </f:subview>

</f:view>



“foo.jsp”

... components and other content ...



“bar.jsp”

... components and other content ...

|===

In this scenario, the _<f:subview>_ custom
actions are in the including page, rather than the included page. As in
the previous scenario, the “id” values of the two subviews must be
unique; but it is much easier to verify using this style.

It is also possible to use this approach to
include the same page more than once, but maintain unique identifiers:

[width="100%",cols="100%",]
|===
a|
“main.jsp”

<f:view>

 <f:subview id=”aaa”>

 <c:import url=”foo.jsp”/>

 </f:subview>

 <f:subview id=”bbb”>

 <c:import url=”foo.jsp”/>

 </f:subview>

</f:view>



“foo.jsp”

... components and other content ...





|===

In all of the above examples, note that
_foo.jsp_ and _bar.jsp_ may not contain _<f:view>_ .

The implementation class for this action must
meet the following requirements:

[P1-start f:subview implementation] Must
extend _javax.faces.UIComponentELTag_ .

The _getComponentType()_ method must return “
_NamingContainer”._

{empty}The _getRendererType()_ method must
return _null_ . [P1-end]

=== [[a5163]]<f:validateDoubleRange>

Register a _DoubleRangeValidator_ instance on
the _UIComponent_ associated with the closest parent _UIComponent_
custom action.

=== Syntax

=== Syntax 1: Maximum only specified

<f:validateDoubleRange maximum=”543.21”
binding=”VB Expression”/>

=== Syntax 2: Minimum only specified

<f:validateDoubleRange minimum=”123.45”
binding=”VB Expression”/>

=== Syntax 3: Both maximum and minimum are specified

<f:validateDoubleRange maximum=”543.21”
minimum=”123.45” binding=”VB Expression”/>

=== Body Content

empty.

=== Attributes

[width="100%",cols="25%,25%,25%,25%",options="header",]
|===
|Name |Expr
|Type |Description
| _maximum_ | _VE_
| _double_
|Maximum value allowed for this component

| _minimum_ | _VE_
| _double_
|Minimum value allowed for this component

| _binding_ | _VE_
| _ValueExpression_
|A _ValueExpression_ expression that
evaluates to an object that implements _javax.faces.convert.Validator_

|for |VE
| _ValueExpression_
|A _ValueExpression_ expression that
evaluates to String referring to the value of one of the exposed
attached objects within the composite component inside of which this tag
is nested.
|===

=== Constraints

Must be nested inside a _EditableValueHolder_
custom action whose value is (or is convertible to) a double.

Must specify either the _maximum_ attribute,
the _minimum_ attribute, or both.

If both limits are specified, the maximum
limit must be greater than the minimum limit.

{empty}[P1-start f:validateDoubleRange
constraints] If this tag is not nested inside a _UIComponent_ custom
action, or the _UIComponent_ implementation class does not correctly
implement _EditableValueHolder_ throw a _JspException_ . [P1-end]

=== Description

Locate the closest parent _UIComponent_
custom action instance by calling
_UIComponentClassicTagBase.getParentUIComponentClassicTagBase()_ . If
the _getCreated()_ method of this instance returns _true_ , create, call
_createValidator()_ and register the returned _Validator_ instance on
the associated _UIComponent_ .

[P1-start f:validateDoubleRange
implementation] The implementation class for this action must meet the
following requirements:

Must extend
_javax.faces.webapp.ValidatorELTag_ .

The _createValidator()_ method must:

If _binding_ is non-null _,_ create a
_ValueBinding_ by invoking _Application.createValueExpression_ () with
binding as the expression argument, and _Validator.class_ as the
expectedType argument.use the _ValueBinding_ to obtain a reference to
the _Validator_ instance. If there is no exception thrown, and
_ValueExpression.getValue()_ returned a non-null object that implements
_javax.faces.validator.Validator_ , it must then cast the returned
instance to _javax.faces.validator.DoubleRangeValidator_ and configure
its properties based on the specified attributes for this custom action,
and return the configured instance. If there was an exception thrown,
rethrow the exception as a _JspException._

{empty}use the _validatorId_ if the validator
instance could not be created from the _binding_ attribute. Call the
_createValidator()_ method of the _Application_ instance for this
application, passing validator id “javax.faces.DoubleRange”. If the
binding attribute was also set, evaluate the expression into a
_ValueExpression_ and store the validator instance by calling
_setValue()_ on the _ValueExpression_ . It must then cast the returned
instance to _javax.faces.validator.DoubleRangeValidator_ and configure
its properties based on the specified attributes for this custom action,
and return the configured instance. If there was an exception thrown,
rethrow the exception as a _JspException_ . [P1-end]

=== <f:validateLength>

Register a _LengthValidator_ instance on the
_UIComponent_ associated with the closest parent _UIComponent_ custom
action.

=== Syntax

=== Syntax 1: Maximum length only specified

<f:validateLength maximum=”10” binding=”VB
Expression”/>

=== Syntax 2: Minimum only specified

<f:validateLength minimum=”1” binding=”VB
Expression”/>

=== Syntax 3: Both maximum and minimum are specified

<f:validateLength maximum=”10” minimum=”1”
binding=”VB Expression”/>

=== Body Content

empty.

=== Attributes

[width="100%",cols="25%,25%,25%,25%",options="header",]
|===
|Name |Expr
|Type |Description
| _maximum_ | _VE_
| _double_
|Maximum value allowed for this component

| _minimum_ | _VE_
| _double_
|Minimum value allowed for this component

| _binding_ | _VE_
| _ValueExpression_
|A _ValueExpression_ expression that
evaluates to an object that implements _javax.faces.convert.Validator_
|===

=== Constraints

Must be nested inside a _EditableValueHolder_
custom action whose value is (or is convertible to) a double.

Must specify either the _maximum_ attribute,
the _minimum_ attribute, or both.

If both limits are specified, the maximum
limit must be greater than the minimum limit.

{empty}[P1-start f:validateDoubleRange
constraints] If this tag is not nested inside a _UIComponent_ custom
action, or the _UIComponent_ implementation class does not correctly
implement _EditableValueHolder_ throw a _JspException_ . [P1-end]

=== Description

Locate the closest parent _UIComponent_
custom action instance by calling
_UIComponentClassicTagBase.getParentUIComponentClassicTagBase()_ . If
the _getCreated()_ method of this instance returns _true_ , create, call
_createValidator()_ and register the returned _Validator_ instance on
the associated _UIComponent_ .

[P1-start f:validateDoubleRange
implementation] The implementation class for this action must meet the
following requirements:

Must extend
_javax.faces.webapp.ValidatorELTag_ .

The _createValidator()_ method must:

If _binding_ is non-null _,_ create a
_ValueBinding_ by invoking _Application.createValueExpression_ () with
binding as the expression argument, and _Validator.class_ as the
expectedType argument.use the _ValueBinding_ to obtain a reference to
the _Validator_ instance. If there is no exception thrown, and
_ValueExpression.getValue()_ returned a non-null object that implements
_javax.faces.validator.Validator_ , it must then cast the returned
instance to _javax.faces.validator.DoubleRangeValidator_ and configure
its properties based on the specified attributes for this custom action,
and return the configured instance. If there was an exception thrown,
rethrow the exception as a _JspException._

{empty}use the _validatorId_ if the validator
instance could not be created from the _binding_ attribute. Call the
_createValidator()_ method of the _Application_ instance for this
application, passing validator id “javax.faces.DoubleRange”. If the
binding attribute was also set, evaluate the expression into a
_ValueExpression_ and store the validator instance by calling
_setValue()_ on the _ValueExpression_ . It must then cast the returned
instance to _javax.faces.validator.DoubleRangeValidator_ and configure
its properties based on the specified attributes for this custom action,
and return the configured instance. If there was an exception thrown,
rethrow the exception as a _JspException_ . [P1-end]

=== [[a5198]]<f:validateRegex>

Register a _RegexValidator_ instance on the
_UIComponent_ associated with the closest parent _UIComponent_ custom
action.

=== Syntax

<f:validateRegex pattern=”a*b”/>

=== Body Content

empty.

=== Attributes

[width="100%",cols="25%,25%,25%,25%",options="header",]
|===
|Name |Expr
|Type |Description
| _pattern_ | _VE_
| _String_ |The
string to be interpreted as a _java.util.regex.Pattern_

| _binding_ | _VE_
| _ValueExpression_
|A _ValueExpression_ expression that
evaluates to an object that implements _javax.faces.convert.Validator_
|===

=== Constraints

Must be nested inside a _EditableValueHolder_
custom action whose value is a _String_ .

Must specify either the _pattern_ attribute.

{empty}[P1-start f:validateLength
constraints] If this tag is not nested inside a _UIComponent_ custom
action, or the _UIComponent_ implementation class does not correctly
implement _EditableValueHolder_ , throw a _JspException_ . [P1-end]

=== Description

Locate the closest parent _UIComponent_
custom action instance by calling
_UIComponentClassicTagBase.getParentUIComponentClassicTagBase()_ . If
the _getCreated()_ method of this instance returns _true_ , create, call
_createValidator()_ and register the returned _Validator_ instance on
the associated _UIComponent_ .

[P1-start f:validateLength implementation]
The implementation class for this action must meet the following
requirements:

Must extend
_javax.faces.webapp.ValidatorELTag_ .

The _createValidator()_ method must:

If _binding_ is non-null, create a
_ValueExpression_ by invoking _Application.createValueExpression_ ()
with binding as the expression argument, and _Validator.class_ as the
expectedType argument.use the _ValueExpression_ to obtain a reference to
the _Validator_ instance. If there is no exception thrown, and
_ValueExpression.getValue()_ returned a non-null object that implements
_javax.faces.validator.Validator_ , it must then cast the returned
instance to _javax.faces.validator.RegexValidator_ and configure its
properties based on the specified attributes for this custom action, and
return the configured instance. If there was an exception thrown,
rethrow the exception as a _JspException._

{empty}use the _validatorId_ if the validator
instance could not be created from the _binding_ attribute. Call the
_createValidator()_ method of the _Application_ instance for this
application, passing validator id “javax.faces.RegularExpression”. If
the binding attribute was also set, evaluate the expression into a
_ValueExpression_ and store the validator instance by calling
_setValue()_ on the _ValueExpression_ . It must then cast the returned
instance to _javax.faces.validator.RegexValidator_ and configure its
properties based on the specified attributes for this custom action, and
return the configured instance. If there was an exception thrown,
rethrow the exception as a _JspException_ .[P1-end]

=== [[a5223]]<f:validateLongRange>

Register a _LongRangeValidator_ instance on
the _UIComponent_ associated with the closest parent _UIComponent_
custom action.

=== Syntax

=== Syntax 1: Maximum only specified

<f:validateLongRange maximum=”543”
binding=”VB Expression”/>

=== Syntax 2: Minimum only specified

<f:validateLongRange minimum=”123”
binding=”VB Expression”/>

=== Syntax 3: Both maximum and minimum are specified

<f:validateLongRange maximum=”543”
minimum=”123” binding=”VB Expression”/>

=== Body Content

empty.

=== Attributes

[width="100%",cols="25%,25%,25%,25%",options="header",]
|===
|Name |Expr
|Type |Description
| _maximum_ | _VE_
| _long_ |Maximum
value allowed for this component

| _minimum_ | _VE_
| _long_ |Minimum
value allowed for this component

| _binding_ | _VE_
| _ValueExpression_
|A _ValueExpression_ expression that
evaluates to an object that implements _javax.faces.convert.Validator_
|===

=== Constraints

Must be nested inside a _EditableValueHolder_
custom action whose value is (or is convertible to) a long.

Must specify either the _maximum_ attribute,
the _minimum_ attribute, or both.

If both limits are specified, the maximum
limit must be greater than the minimum limit.

{empty}[P1-start f:validateLongeRange
constraints] If this tag is not nested inside a _UIComponent_ custom
action, or the _UIComponent_ implementation class does not correctly
implement _EditableValueHolder_ , throw a _JspException_ . [P1-end]

=== Description

Locate the closest parent _UIComponent_
custom action instance by calling
_UIComponentClassicTagBase.getParentUIComponentClassicTagBase()_ . If
the _getCreated()_ method of this instance returns _true_ , create, call
_createValidator()_ and register the returned _Validator_ instance on
the associated _UIComponent_ .

The implementation class for this action must
meet the following requirements:

Must extend
_javax.faces.webapp.ValidatorELTag_ .

The _createValidator()_ method must:

If _binding_ is non-null, create a
_ValueExpression_ by invoking _Application.createValueExpression_ ()
with binding as the expression argument, and _Validator.class_ as the
expectedType argument. Use the _ValueExpression_ to obtain a reference
to the _Validator_ instance. If there is no exception thrown, and
_ValueExpression.getValue()_ returned a non-null object that implements
_javax.faces.validator.Validator_ , it must then cast the returned
instance to _javax.faces.validator.LongRangeValidator_ and configure its
properties based on the specified attributes for this custom action, and
return the configured instance. If there was an exception thrown,
rethrow the exception as a _JspException._

use the _validatorId_ if the validator
instance could not be created from the _binding_ attribute. Call the
_createValidator()_ method of the _Application_ instance for this
application, passing validator id “javax.faces.LongRange”. If the
binding attribute was also set, evaluate the expression into a
_ValueExpression_ and store the validator instance by calling
_setValue()_ on the _ValueExpression_ . It must then cast the returned
instance to _javax.faces.validator.LongRangeValidator_ and configure its
properties based on the specified attributes for this custom action, and
return the configured instance. If there was an exception thrown,
rethrow the exception as a _JspException._

=== [[a5256]]<f:validator>

Register a named _Validator_ instance on the
_UIComponent_ associated with the closest parent _UIComponent_ custom
action.

=== Syntax

<f:validator validatorId=”validatorId”
binding=”VB Expression”/>

=== Body Content

empty

=== Attributes

[width="100%",cols="25%,25%,25%,25%",options="header",]
|===
|Name |Expr
|Type |Description
| _validatorId_ |
_VE_ | _String_
|Validator identifier of the validator to be
created.

| _binding_ | _VE_
| _ValueExpression_
|A _ValueExpression_ expression that
evaluates to an object that implements _javax.faces.convert.Validator_
|===

=== Constraints

Must be nested inside a _UIComponent_ custom
action whose component class implements _EditableValueHolder_ .

 _validatorId_ and/or binding must be
specified.

{empty}[P1-start f:validator constraints 2]
If this tag is not nested inside a _UIComponent_ custom action, or the
_UIComponent_ implementation class does not correctly implement
_EditableValueHolder_ throw a _JspException_ . [P1-end]

=== Description

Locate the closest parent _UIComponent_
custom action instance by calling
_UIComponentClassicTagBase.getParentUIComponentClassicTagBase()_ . If
the _getCreated()_ method of this instance returns _true_ , create, call
_createValidator()_ and register the returned _Validator_ instance on
the associated _UIComponent_ .

The implementation class for this action must
meet the following requirements:

Must extend
_javax.faces.webapp.ValidatorJspTag_ .

The _createValidator()_ method must:

If _binding_ is non-null, call
_binding.getValue()_ to obtain a reference to the _Validator_ instance.
If there is no exception thrown, and _binding.getValue()_ returned a
non-null object that implements _javax.faces.validator.Validator_ ,
register it by calling _addValidator()._ If there was an exception
thrown, rethrow the exception as a _JspException._

use the _validatorId_ attribute if the
validator instance could not be created from the _binding_ attribute _._
If the _validatorId_ attribute is set, call the _createValidator()_
method of the _Application_ instance for this application, passing
validator id specified by their validatorId attribute. If the binding
attribute was also set, store the validator instance by calling
_binding.setValue()_ . Register the validator instance by calling
_addValidator()._ If there was an exception thrown, rethrow the
exception as a _JspException._

=== [[a5282]]<f:valueChangeListener>

Register a _ValueChangeListener_ instance on
the _UIComponent_ associated with the closest parent _UIComponent_
custom action.

=== Syntax

<f:valueChangeListener
type=”fully-qualified-classname” binding=”VB Expression”/>

=== Body Content

empty.

=== Attributes

[width="100%",cols="25%,25%,25%,25%",options="header",]
|===
|Name |Expr
|Type |Description
| _type_ | _VE_
| _String_ |Fully
qualified Java class name of a _ValueChangeListener_ to be created and
registered

| _binding_ | _VE_
| _ValueExpression_
|A _ValueExpression_ expression that
evaluates to an object that implements
_javax.faces.event.ValueChangeListener_
|===

=== Constraints

Must be nested inside a _UIComponent_ custom
action.

The corresponding _UIComponent_
implementation class must implement _EditableValueHolder_ , and
therefore define a public _addValueChangeListener()_ method that accepts
an _ValueChangeListener_ parameter.

The specified listener class must implement
_javax.faces.event.ValueChangeListener_ .

 _type_ and/or binding must be specified.

[P1-start f:valueChangeListener constraints]
If this tag is not nested inside a _UIComponent_ custom action, or the
_UIComponent_ implementation class does not correctly implement
_EditableValueHolder_ , or the specified listener class does not
implement _javax.faces.event.ValueChangeListener_ , throw a
_JspException_ . [P1-end] Note that if the binding attribute is used,
the scope of the _ValueExpression_ must be chosen carefully so as not to
introduce undesireable results. In general, when using the binding
attribute, do not point to beans in request or narrower scope.

=== Description

Locate the closest parent _UIComponent_
custom action instance by calling
_UIComponentClassicTagBase.getParentUIComponentClassicTagBase()_ . If
the _getCreated()_ method of this instance returns _true_ , check the
binding attribute.

If binding is non-null, call
_binding.getValue()_ to obtain a reference to the _ValueChangeListener_
instance. If there is no exception thrown, and
_ValueExpression.getValue()_ returned a non-null object that implements
_javax.faces.event.ValueChangeListener_ , register it by calling
_addValueChangeListener()._ If there was an exception thrown, rethrow
the exception as a _JspException._

If the listener instance could not be
created, check the _type_ attribute _._ If the _type_ attribute is set,
instantiate an instance of the specified class, and register it by
calling _addValueChangeListener()_ . If the binding attribute was also
set, store the listener instance by calling _binding.setValue()_ . If
there was an exception thrown, rethrow the exception as a
_JspException._

As an alternative to using the binding and/or
type attributes, you may also register a method in a backing bean class
to receive _ValueChangeEvent_ notifications, by using the
_valueChangeListener_ attribute on the corresponding _UIComponent_
custom action.instantiate an instance of the specified class, and
register it by calling _addValueChangeListener()_ .

=== <f:verbatim>

Register a child _UIOutput_ instance on the
_UIComponent_ associated with the closest parent _UIComponent_ custom
action which renders nested body content.

=== Syntax

<f:verbatim [escape=”\{true|false}”
rendered=”\{true|false”]/>

=== Body Content

JSP. However, no UIComponent custom actions,
or custom actions from the JSF Core Tag Library, may be nested inside
this custom action.

=== Attributes

[width="100%",cols="25%,25%,25%,25%",options="header",]
|===
|Name |Expr
|Type |Description
| _escape_ | _VE_
| _boolean_ |If
_true_ , generated markup is escaped in a manner appropriate for the
markup language being rendered. Default value is false.

| _rendered_ |
_VE_ | _boolean_
|Flag indicating whether or not this
component should be rendered (during Render Response Phase), or
processed on any subsequent form submit. Default value is true.
|===

=== Constraints

{empty}[P1-start f:verbatim constraints] Must
be implemented as a _UIComponentBodyTag_ .[P1-end]

=== Description

Locate the closest parent _UIComponent_
custom action instance by calling
_UIComponentClassicTagBase.getParentUIComponentClassicTagBase()_ . If
the _getCreated()_ method of this instance returns _true_ , creates a
new _UIOutput_ component, and add it as a child of the _UIComponent_
associated with the located instance. The _rendererType_ property of
this _UIOutput_ component must be set to “javax.faces.Text”, and the
_transient_ property must be set to _true_ . Also, the value (or value
binding, if it is an expression) of the _escape_ attribute must be
passed on to the renderer as the value the _escape_ attribute on the
_UIOutput_ component.

=== [[a5325]]<f:view>

Container for all JSF core and component
custom actions used on a page.

=== Syntax

[width="100%",cols="100%",]
|===
a|
{empty}<f:view [locale=” _locale_ ”
renderKitId=”alternate”]

{empty} [beforePhase=”methodExpression”]

 [afterPhase”methodExpression”]>

 Nested template text and custom actions

</f:view>

|===

=== Body Content

JSP. May contain any combination of template
text, other JSF custom actions, and custom actions from other custom tag
libraries.

=== Attributes

[width="100%",cols="25%,25%,25%,25%",options="header",]
|===
|Name |Expr
|Type |Description
| _renderKitId_ |
_VE_ | _String_
|The identifier for the render kit to use for
rendering this page.

| _locale_ | _VE_
| _String or Locale_
|Name of a Locale to use for localizing this
page (such as en_uk), or value binding expression that returns a
_Locale_ instance

| _beforePhase_
|ME |String
| _MethodExpression_ expression that points
to a method whose signature is that of javax.faces.event.
_PhaseListener.beforePhase()_

| _afterPhase_ |ME
|String |
_MethodExpression_ expression that points to a method whose signature is
that of javax.faces.event. _PhaseListener.afterPhase()_
|===

=== Constraints

[P1-start f:view constraints] Any JSP-created
response using actions from the JSF Core Tag Library, as well as actions
extending _javax.faces.webapp.UIComponentELTag_ from other tag
libraries, must be nested inside an occurrence of the _<f:view>_ action.

JSP page fragments included via the standard
_<%@ include %>_ directive need not have their JSF actions embedded in a
_<f:view>_ action, because the included template text and custom actions
will be processed as part of the outer page as it is compiled, and the
_<f:view>_ action on the outer page will meet the nesting requirement.

If the _renderKitId_ attribute is present,
its value is stored in _UIViewRoot._ If the _renderKitId_ attribute is
not present, then the default render kit identifier as returned by
_Application.getDefaultRenderKitId()_ is stored in _UIViewRoot_ if it is
not _null._ Otherwise, the render kit identifier as specified by the
constant _RenderKitFactory.HTML_BASIC_RENDER_KIT_ is stored in
_UIViewRoot._ Specifying a _renderKitId_ for the current view also
affects all subsequent views, unless overridden by another use of the
_renderKitId_ attribute. Please refer to link:JSF.html#a3871[See
ViewHandler] for more information.

If the _locale_ attribute is present, its
value overrides the _Locale_ stored in _UIViewRoot_ , normally set by
the _ViewHandler, and the doStartTag() method must store it by calling
UIViewRoot.setLocale()_ .

{empty}The _doStartTag()_ method must call
_javax.servlet.jsp.jstl.core.Config.set()_ , passing the
_ServletRequest_ instance for this request, the constant
_javax.servlet.jsp.jstl.core.Config.FMT_LOCALE_ , and the _Locale_
returned by calling _UIViewRoot.getLocale()_ . [P1-end]

=== Description

Provides the JSF implementation a convenient
place to perform state saving during the render response phase of the
request processing lifecycle, if the implementation elects to save state
as part of the response.

The implementation class for this action must
meet the following requirements:

Must extend _javax.faces.UIComponentELTag_ .

The _getComponentType()_ method must return
“ViewRoot”.

The _getRendererType()_ method must return
_null_ .

Please refer to the javadocs for
_javax.faces.application.StateManager_ for details on what the tag
handler for this tag must do to implement state saving.

=== 

image:SF-40.png[image]

[[a5363]]Standard HTML RenderKit Tag Library

All JSF implementations must provide a tag
library containing actions that correspond to each valid combination of
a supported component class (see link:JSF.html#a1823[See
Standard User Interface Components]”) and a _Renderer_ from the Standard
HTML RenderKit (see link:JSF.html#a4314[See Standard HTML
RenderKit Implementation]) that supports that component type. [P1-start
html_basic taglib requirements] The tag library descriptor for this tag
library must meet the following requirements:

Must declare a tag library version (
_<tlib-version>_ ) value of _1.2_ .

Must declare a URI ( _<uri>_ ) value of
_http://java.sun.com/jsf/html_ .

{empty}Must be included in the _META-INF_
directory of a JAR file containing the corresponding implementation
classes, suitable for inclusion with a web application, such that the
tag library descriptor will be located automatically by the algorithm
described in Section 7.3 of the _JavaServer Pages Specification_
(version 1.2).[P1-end]

[P1-start html_basic return values]The custom
actions defined in this tag library must specify the following return
values for the _getComponentType()_ and _getRendererType()_ methods,
respectively:.

=== Standard HTML RenderKit Tag Library

getComponentType()

getRendererType()

custom action name

javax.faces.Column

{empty}(null)link:#a9101[18]

column

javax.faces.HtmlCommandButton

javax.faces.Button

commandButton

javax.faces.HtmlCommandLink

javax.faces.Link

commandLink

javax.faces.HtmlDataTable

javax.faces.Table

dataTable

javax.faces.HtmlForm

javax.faces.Form

form

javax.faces.HtmlGraphicImage

javax.faces.Image

graphicImage

javax.faces.HtmlInputHidden

javax.faces.Hidden

inputHidden

javax.faces.HtmlInputSecret

javax.faces.Secret

inputSecret

javax.faces.HtmlInputText

javax.faces.Text

inputText

javax.faces.HtmlInputTextarea

javax.faces.Textarea

inputTextarea

javax.faces.HtmlMessage

javax.faces.Message

message

javax.faces.HtmlMessages

javax.faces.Messages

messages

javax.faces.HtmlOutputFormat

javax.faces.Format

outputFormat

javax.faces.HtmlOutputLabel

javax.faces.Label

outputLabel

javax.faces.HtmlOutputLink

javax.faces.Link

outputLink

javax.faces.Output

javax.faces.Body

body

javax.faces.Output

javax.faces.Head

head

javax.faces.Output

javax.faces.resource.Script

outputScript

javax.faces.Output

javax.faces.resource.Stylesheet

outputStylesheet

javax.faces.HtmlOutputText

javax.faces.Text

outputText

javax.faces.HtmlPanelGrid

javax.faces.Grid

panelGrid

javax.faces.HtmlPanelGroup

javax.faces.Group

panelGroup

javax.faces.HtmlSelectBooleanCheckbox

javax.faces.Checkbox

selectBooleanCheckbox

javax.faces.HtmlSelectManyCheckbox

javax.faces.Checkbox

selectManyCheckbox

javax.faces.HtmlSelectManyListbox

javax.faces.Listbox

selectManyListbox

javax.faces.HtmlSelectManyMenu

javax.faces.Menu

selectManyMenu

javax.faces.HtmlSelectOneListbox

javax.faces.Listbox

selectOneListbox

javax.faces.HtmlSelectOneMenu

javax.faces.Menu

selectOneMenu

javax.faces.HtmlSelectOneRadio

javax.faces.Radio

selectOneRadio

Note, to avoid confusion between JSP and
Facelets, any Renderers that are only supported in Facelets are
specified in link:JSF.html#a6029[See Standard HTML RenderKit Tag
Library].

[P1-end] [P1-start html_basic taglibrary
requirements 2]The tag library descriptor for this tag library (and the
corresponding tag handler implementation classes) must meet the
following requirements:

The attributes for the tags, both in the TLD
and in the associated tag handlers, must conform exactly to the type,
name, and description given in the VDLDocs for the html_basic tag
library.

If the type of the attribute is
_javax.el.ValueExpression_ , the TLD for the attribute must contain a
_<deferred-value>_ with a nested _<type>_ element, inside of which is
nested the expected type, as given in the VDLDocs. The JavaBeans setter
method in the tag handler for the tag must be of type
_javax.el.ValueExpression_ .

If the type of the attribute is
_javax.el.MethodExpression_ , the TLD for the attribute must contain a
_<deferred-method>_ with a nested _<method-signature>_ , inside of which
is the method signature for that _MethodExpression_ , as given in the
VDLDocs. The actual name of the method in the signature declaration is
immaterial and unspecified. The JavaBeans setter method in the tag
handler for the tag must be of type _javax.el.MethodExpression_ .

Any attributes listed in the VDLDocs with a
_request-time_ value of _true_ must specify an _<rtexprvalue>_ of _true_
in the TLD.

The following action must be taken to handle
the value of the _converter_ property. If _isLiteralText()_ on the
_converter_ property returns _true_ , get the value of the property and
treat it as a _converterId_ by passing it as the argument to the
_createConverter()_ method of the _Application_ instance for this
webapp, then pass the created _Converter_ to the _setConverter()_ method
of the component for this tag. If _isLiteralText()_ on the _converter_
property returns _false_ , call _setValueExpression()_ on the component,
passing “converter” as the name of the _ValueExpression_ and the
_ValueExpression_ instance as the value.

For a non- _null_ _action_ attribute on
custom actions related to _ActionSource2_ components ( _commandButton_ ,
_commandLink_ ), the _setProperties()_ method of the tag handler
implementation class must pass the value of the action attribute, which
is a _MethodExpression_ , to the component’s _setActionExpression()_
method.

For other non- _null_ attributes that
correspond to _MethodExpression_ attributes on the underlying components
( _actionListener_ , _validator_ , _valueChangeListener_ ), the
_setProperties()_ method of the tag handler implementation class must
store that instance as the value of the corresponding component
property.

For any non- _null_ _id_ , _scope_ , or _var_
attribute, the _setProperties()_ method of the tag handler
implementation class must simply set the value of the corresponding
component attribute.

For all other non- _null_ attributes, the
_setProperties()_ of the tag handler implementation class method must:

If the _attribute.isLiteralText()_ returns
_true_ , set the corresponding attribute on the underlying component
(after performing any necessary type conversion).

{empty}Otherwise, call the
_setValueExpression()_ method on the underlying component, passing the
attribute name and the _ValueExpression‘_ instance as
parameters.[P1-end]





=== 

image:SF-41.png[image]

[[a5476]]Facelets and its use in Web Applications

image:SF-42.png[image]

As of version 2 of this specification,
JavaServer Faces implementations must support (although JSF-based
applications need not utilize) using Facelets as the view declaration
language for JSF pages. Facelets technology was created by JSR-252 EG
Member Jacob Hookom.

=== 

image:SF-43.png[image]

Non-normative Background

To aid implementors in providing a spec
compliant runtime for Facelets, this section provides a non-normative
background to motivate the discussion of the Facelets feature. Facelets
is a replacement for JSP that was designed from the outset with JSF in
mind. New features introduced in version 2 and later are only exposed to
page authors using Facelets. JSP is retained for backwards
compatibility.

=== Differences between JSP and Facelets

Facelets was the first non-JSP view
declaration language designed for JavaServer Faces. As such, Facelets
was able to provide a simpler and more powerful programming model to JSF
developers than that provided by JSP, largely by leveraging JSF as much
as possible without carrying backwards compatibility with JSP. The
following table lists some of the differences between Facelets and JSP



=== Comparison of Facelets and JSP

Feature Name

JSP

Facelets

Pages are compiled to...

A Servlet that gets executed each time the
page renders. The UIComponent hierarchy is built by the presence of
custom tags in the page.

An abstract syntax tree that, when executed,
builds a UIComponent hierarchy.

Handling of tag attributes

All tag attributes must be declared in a TLD
file. Conformance instances of components in a page with the expected
attributes can be enforced with a taglibrary validator.

Tag attributes are completely dynamic and
automatically map to properties, attributes and ValueExpressions on
UIComponent instances

Page templating

Not supported, must go outside of core JSP

Page templating is a core feature of Facelets

Performance

Due to the common implementation technique of
compiling a JSP page to a Servlet, performance can be slow

Facelets is simpler and faster than JSP

EL Expressions

Expressions in template text cause unexpected
behavior when used in JSP

Expressions in template text operate as
expected.

JCP Standard

Yes, the specification is separate from the
implementation for JSP

No, the specification is defined by and is
one with the implementation.

=== Differences between Pre JSF 2.0 Facelets and Facelets in JSF 2.0

The work of taking a snapshot of a version of
Facelets and producing the specification for Facelets in JSF 2.0
consists of extracting the parts of Facelets that are intended to be
“public” and leaving the rest as implementation details. A decision was
made early in this process to strive for backwards compatibility between
the latest popular version of Facelets and Facelets in JSF 2.0. The sole
determinant to backwards compatibility lies in the answer to the
question, “is there any Java code in the application, or in libraries
used by the application, that extends from or depends on any class in
package _com.sun.facelets_ and/or its sub-packages?”

If the answer to this question is “yes”,
Facelets in JSF 2.0 is _not_ backwards compatibile with Facelets and
such an application _must_ continue to bundle the Facelets jar file
along with the application, continue to set the Facelets configuration
parameters, and also set the
_javax.faces.DISABLE_FACELET_JSF_VIEWHANDLER_ _<context-param>_ to
_true_ . Please see link:JSF.html#a6088[See Application
Configuration Parameters] for details on this option. Any code that
extends or depends on any class in package _com.sun.facelets_ and/or its
sub-packages must be modified to depend on the appropriate classes in
package _javax.faces.webapp.vdl_ and/or its sub-packages.

If the answer to this question is “no”,
Facelets in JSF 2.0 _is_ backwards compatible with pre-JSF 2.0 Facelets
and such an application _must not_ continue to bundle the Facelets jar
file along with the application, and _must not_ continue to set the
Facelets configuration parameters.

Thankfully, most applications that use
Facelets fall into the latter category, or, if they fall in the former,
their dependence will easily be migrated to the new public classes.

Facelets in JSF 2.0 provides tag libraries
that are compatible with the following libraries already found in pre
JSF 2.0 Facelets.

=== Taglibs in pre JSF 2.0 Facelets that are available in Facelets in JSF 2.0

Common prefix

Namespace URI

h

http://java.sun.com/jsf/html

f

http://java.sun.com/jsf/core

c

http://java.sun.com/jsp/jstl/core

fn

http://java.sun.com/jsp/jstl/functions

ui

http://java.sun.com/jsf/facelets

Naturally, new features built on Facelets in
JSF 2.0 are not available in pre JSF 2.0 Facelets and will only work in
JSF 2.0 or later.

=== [[a5526]]Resource Library Contracts Background

JSF defines a system called “resource library
contracts” for applying facelet templates to an entire application in a
re-usable and interchangeable manner. The feature is built on top of the
resource library facility described in link:JSF.html#a836[See
Libraries of Localized and Versioned Resources]. A configurable set of
Facelet VDL views in the application will be able to declare themselves
to be template-clients of any template in a resource library contract.
Facelet VDL views in the application can also make use of resources
contained in a resource library contract, but the feature has ample
value when only used with templates.

=== Non-normative Example

Consider this resource library contract,
called _siteLayout_ .

[width="100%",cols="100%",]
|===
|siteLayout/ +
topNav_template.xhtml +
leftNav_foo.xhtml +
styles.css +
script.js +
background.png
|===

This simple example takes advantage of
several conventions built into the feature, most notably the default
application of all available contracts in the application to all views
in the application. It is possible to customize how resource library
contracts are applied to the application, including using several
different contracts in the same or different parts of the application.
Such customizing is accomplished by including a
_<resource-library-contracts>_ element within the _<application>_
element of the _faces-config.xml_ (or similar) file. Because this
example is designed with the convention in mind, it does not need a
_faces-config.xml_ file.

The _siteLayout_ contract offers two
templates: _topNav_template.xhtml_ and _leftNav_foo.xhtml_ . For
discussion, these are known as “declared templates”. When used by a
template client, they will lay out the template client’s contents with a
navigation menu on the top or the left side of the page, respectively.
In _siteLayout_ , each of the templates has _<ui:insert>_ tags named
“title”, “content”, and “nav”. For discussion, these are knows as
“declared insertion points”. Furthermore, each of the templates uses the
CSS styles declared in _styles.css_ , some scripts defined in
_script.js_ , and the background image _background.png_ . For
discussion, these are known as “declared resources”. In order to use a
resource library contract, one must know its declared templates, their
declared insertion points, and, optionally, their declared resources. No
constraint is placed on the naming and arrangement of declared
templates, insertion points, or resources, but all three concepts
together can informally be thought of as the declaration of the resource
library contract. The contract declaration of _siteLayout_ can be stated
as follows.

 _siteLayout_ provides two declared
templates, _topNav_template.xhtml_ and _leftNav_foo.xhtml_ . Each
templates offers declared insertion points “title”, “content”, and
“nav”.

In this case, the css, script, and image are
left out of the contract declaration but this distinction is completely
arbitrary. The important content of _topNav_template.xhtml_ is shown
next.

[width="100%",cols="100%",]
|===
a|
<?xml version='1.0' encoding='UTF-8' ?>

<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml"

 xmlns:ui="http://java.sun.com/jsf/facelets"

 xmlns:h="http://java.sun.com/jsf/html">

<h:head>

 <h:outputStylesheet id="default"
name="default.css" <h:outputStylesheet name="cssLayout.css" />

 <title><ui:insert
name="title"></ui:insert></title>

</h:head>

<h:body>

 <div id="top" class="top">

 <p>Top Navigation Menu</p>

 <ui:insert name="nav">Nav
content</ui:insert>

 </div>

 <div id="content" class="center_content">

 <ui:insert
name="content">Content</ui:insert>

 </div>

</h:body>

</html>

|===



This example packages the entire _siteLayout_
directory and its contents into the _META-INF/contracts_ entry of a JAR
file named _siteLayout.jar_ . The simplest possible way to use
_siteLayout_ is to drop _siteLayout.jar_ into _WEB-INF/lib_ and apply
the knowledge of the resource library contract declaration to the
facelet views in the app.

Consider this simple web app, called
_useContract_ , the file layout for which is shown next. The example is
shown using a simplified maven war packaging.

[width="100%",cols="100%",]
|===
|useContract/ +
pom.xml +
src/main/webapp/ +
/WEB-INF/lib/siteLayout.jar +
index.xhtml +
page2.xhtml
|===

Notice the absence of a _faces-config.xml_
file. Because this example is content to let all the contracts in
_siteLayout.jar_ be applied to all views in the app, this file is not
necessary. The two pages are shown next.

index.xhtml.

[width="100%",cols="100%",]
|===
|<!DOCTYPE HTML> +
<html xmlns=”http://www.w3.org/1999/xhtml” +
xmlns:ui=”http://java.sun.com/jsf/facelets” +
xmlns:h=”http://java.sun.com/jsf/html”> +
<body> +
<ui:composition template=”/topNav_template.xhtml”> +
<ui:define name=”title”>#\{msgs.contactsWindowTitle}</ui:define> +
<ui:define name=”content”> +
<h:commandButton value=”next” action=”page2” /> +
</ui:define> +
<ui:define name=”nav”>#\{msgs.contactsNavMessage}</ui:define> +
</ui:composition> +
</body> +
</html>
|===

page2.xhtml

[width="100%",cols="100%",]
|===
|<!DOCTYPE HTML> +
<html xmlns=”http://www.w3.org/1999/xhtml” +
xmlns:ui=”http://java.sun.com/jsf/facelets” +
xmlns:h=”http://java.sun.com/jsf/html”> +
<body> +
<ui:composition template=”/leftNav_foo.xhtml”> +
<ui:define name=”title”>Hard coded title</ui:define> +
<ui:define name=”content”> +
<h:commandButton value=”back” action=”index” /> +
</ui:define> +
<ui:define name=”nav”>Hard coded nav</ui:define> +
</ui:composition> +
</body> +
</html>
|===

To complete the example, the execution of the
_useContract_ app is illustrated.

When _useContract.war_ is deployed, the
runtime will discover that _siteLayout.jar_ is a resource library
contract and make its contents available for template clients.

When the user agent visits
_http://localhost:8080/useContract/faces/index.xhtml_ , because the
_siteLayout_ resource library contract provides _/topNav_template.xhtml_
, that file will be loaded as the template. Likewise, when the _next_
button is pressed, _/leftNav_foo.xhtml_ , also from _siteLayout_ ,will
be loaded as the template.

Now, consider there is an alternate
implementation of the _siteLayout_ contract, packaged as
_newSiteLayout.jar_ . This implementation doesn’t change the contract
declaration, but completely changes the arrangement and style of the
views. As long as the contract declaration does not change,
_useContract_ can take advantage of _newSiteLayout_ simply by replacing
one JAR in _WEB-INF/lib_ .

=== Non-normative Feature Overview

The normative requirements of the feature are
stated in the context of the part of the specification impacted. This
section gives the reader a non-normative overview of the feature that
touches on all the parts of the specification that intersect with this
feature.

 _Design Time_

At design time, the developer has packaged
any resource library contracts to be used in the application in the
right place in the web application, or JAR file classpath. _This
behavior is normatively specified in link:JSF.html#a872[See
Resource Library Contracts]._

 _Startup Time_

At startup time, the runtime will discover
the set of resource library contracts available for this application. If
there is one or more _<resource-library-contracts>_ element, only those
contracts explicitly named will be made available for use in the
application. If there is no such element, all of the discovered
contracts are made available for use in the application. _This behavior
is normatively specified in link:JSF.html#a6215[See Resource
Library Contracts] and in the XML schema for the application
configuration resources._

 _Facelet Processing Time_

The specification for
_ViewDeclarationLanguage.createView()_ requires a call to
_ViewDeclarationLanguage.calculateResourceLibraryContracts()_ , passing
the current _viewId_ . This method will examine the data structure
assembled at startup and return a _List<String>_ representing the
resource library contracts eligible for use in this view. This value is
set as the value of the _resourceLibraryContracts_ property on the
_FacesContext_ . _This behavior is normatively specified in
link:JSF.html#a4016[See ViewDeclarationLanguage.createView()]._

The specification of the tag handler for
_<f:view>_ is the one other place where the _resourceLibraryContracts_
property may be set. _This behavior is normatively specified in the tag
handler for <f:view>._

In any _<ui:composition>_ or _<ui:decorate>_
tag reached from that view, it is valid to use any of the templates in
any of the listed contracts as the value of the _template_ attribute.
This behavior happens naturally as a side effect of the requirements of
_ResourceHandler.createViewResource()_ , where the implementation of
that method is required to first consult the _resourceLibraryContracts_
property of the current _FacesContext_ . If the value of the property is
non- _null_ and non empty, the implementation must first look for the
named view resource within each of the contracts in the list, and return
the first matching one found. Otherwise, the implementation just returns
the matching resource, if found. _This behavior is normatively specified
in the javadoc for ResourceHandler.createViewResource()._

 _View Rendering Time_

When the view is being rendered, any
resources that reside in a resource library contract will have
additional metadata so that a subsequent request from the user agent is
able to quickly find the resource inside the named contract. _This
behavior is normatively specified in the javadoc for
Resource.getRequestPath()._

 _User-Agent Rendering Time_

By the point in time that the User-Agent is
rendering the view, all of the work related to resource library
contracts will have been completed, but it is worth mentioning that any
resources in the page that originate from within resource library
contracts will be correctly fetched.

=== [[a5581]]HTML5 Friendly Markup

Prior to version 2.2 of this specification,
the view authoring model relied entirely on the concept of a JSF UI
component in a view as a means to encapsulate arbitrarily complex web
user interface code behind a simple UI component tag in a page. For
example, the act of including _<my:datePicker value=”#\{user.dob}” />_
in a view could cause a large amount of HTML, CSS, JavaScript, and
images to be delivered to the user agent. This abstraction is very
appropriate when the view author is content to delegate the work of
designing the user experience for such components to a component author.
As web designer skills have become more widespread, the need has arisen
to expose the hitherto hidden complexity so the view author has near
total control on the user experience of each individual element in the
view. The HTML5 Friendly Markup feature addresses this requirement, as
well as providing access to the loosened attribute syntax also present
in HTML5.

This feature is only available to views
written in Facelets. It is not available to views written in JSP.

=== Non-normative Feature Overview

The normative requirements of the feature are
stated in the context of the part of the specification impacted. This
section gives the reader a non-normative overview of the feature that
touches on all the parts of the specification that intersect with this
feature. There are two main aspects to the feature, pass through
attributes and pass through elements.

 _Pass Through Attributes_

For any given JSF component tag in a view,
the set of available attributes that component supports is determined by
a combination of the _UIComponent_ and _Renderer_ for that tag. In some
cases the value of the attribute is interpreted by the _UIComponent_ or
_Renderer_ (for example, the _columns_ attribute of _h:panelGrid_ ) and
in others the value is passed straight through to the user agent (for
example, the _lang_ attribute of _h:inputText_ ). In both cases, the
_UIComponent/Renderer_ has a priori knowledge of the set of allowable
attributes. _Pass Through Attributes_ allows the view author to list
arbitrary name value pairs that are passed straight through to the user
agent without interpretation by the _UIComponent/Renderer_ . _This
behavior is normatively specified in the “Rendering Pass Through
Attributes” section of the overview of the standard HTML_BASIC render
kit._

The view author may specify pass through
attributes in three ways.

Nesting the _<f:passThroughAttribute>_ tag
within a _UIComponent_ tag. For example, +
_<h:inputText value=”#\{user.name}”> +
<f:passThroughAttribute name=”data-sermon” value=”#\{pastor.message}”
/> +
</h:inputText>_

Nesting the _<f:passThroughAttributes>_ tag
within a _UIComponent_ tag, For example, +
_<h:inputText value=”#\{user.name”> +
<f:passThroughAttributes value=”#\{service.nameValuePairs}” /> +
</h:inputText> +
_ The EL expression must point to a _Map<String, Object>_ . If the value
is a _ValueExpresison_ call _getValue()_ the value first. Whether the
value is a _ValueExpression_ or not, the value must have its
_toString()_ called on it.

Prefixing the attribute with the shortname
assigned to the _http://java.sun.com/jsf/passthrough_ XML namespace. For
example +
_<html xmlns:p=”http://java.sun.com/jsf/passthrough” +
xmlns:h=”http://java.sun.com/jsf/html”> +
<h:inputText p:foo=”\{bar.baz}” value=”#\{user.name}” /> +
</html>_

 _This behavior is normatively specified in
the VDLdoc for <f:passthroughAttribute>, <f:passThroughAttributes> tags
in the “Faces Core” tag library, and the “Pass Through Attributes” tag
library._

 _Pass Through Elements_

This feature circumvents the traditional
component abstraction model of JSF, allowing the page author nearly
complete control of the rendered markup, without sacrificing any of the
server side lifecycle offered by JSF. This is accomplished by means of
enhancements to the Facelet _TagDecorator_ API. This API describes a
mapping from the common markup elements to target tags in the HTML_BASIC
RenderKit such that the actual markup specified by the view author is
what gets rendered, but the server side component is an actual component
from the HTML_BASIC RenderKit. A special _Renderer_ is provided to cover
cases when none of the mappings specified in _TagDecorator_ fit the
incoming markup. To allow further flexibility, the existing Facelets
TagDecorator mechanism allows complete control of the mapping process.
_This behavior is normatively specified in the javadocs for class
javax.faces.view.facelets.TagDecorator and in the section “Rendering
Pass Through Attributes” in the “General Notes On Encoding” in the
Standard HTML_BASIC RenderKit._

An example will illustrate the mapping
process.

[width="100%",cols="100%",]
|===
|<!DOCTYPE HTML> +
<html xmlns=”http://www.w3.org/1999/xhtml” +
xmlns:jsf=”http://java.sun.com/jsf”> +
<body> +
<input type=”number” pattern=”[0-9]*” jsf:value=”#\{my.age}” /> +
</body> +
</html>
|===

As required in
link:JSF.html#a5608[See Specification of the
ViewDeclarationLanguage Implementation for Facelets for JSF 2.0]
_TagDecorator_ is called during the facelet processing. Because the
_<input>_ element has an attribute from the _http://java.sun.com/jsf_
namespace, the system treats the element as a pass through element. The
table listed in the javadocs for _TagDecorator_ is consulted and it is
determined that this component should act as an _<h:inputText>_
component for the purposes of postback processing. However, the
rendering is entirely taken from the markup in the facelet view. Another
example illustrates the special _Renderer_ that is used when no mapping
can be found in the table in the javadocs for _TagDecorator_ .

[width="100%",cols="100%",]
|===
|<!DOCTYPE HTML> +
<html xmlns=”http://www.w3.org/1999/xhtml” +
xmlns:jsf=”http://java.sun.com/jsf”> +
<body> +
<meter jsf:id="meter2" min="#\{bean.min}" max="#\{bean.max}" +
value="350">350 degrees</meter> +
</body> +
</html>
|===

As in the preceding example, the
_TagDecorator_ mechanism is activated but it is determined that this
component should act as a _<jsf:element>_ component for the purposes of
postback processing. _The behavior of the <jsf:element> is normatively
specified in the VDLdoc for that tag. The behavior of the
javax.faces.passthrough.Element renderer is normatively specified in the
RenderKitDoc for that renderer._

=== 

image:SF-43.png[image]

Java Programming Language Specification for Facelets
in JSF 2.0

The subsections within this section specify
the Java API requirements of a Facelets implementation. Adherence to
this section and the next section, which specifies the XHTML
specification for Facelets in JSF 2.0, will ensure applications and JSF
component libraries that make use of Facelets are portable across
different implementations of JavaServer Faces.

The original Facelet project did not separate
the API and the implementation into separate jars, as is common practice
with JCP specifications. Thus, a significant task for integrating
Facelets into JSF 2 was deciding which classes to include in the public
Java API, and which to keep as an implementation detail.

There were two guiding principles that
influenced the task of integrating Facelets into JSF 2.

The original decision in JSF 1.0 to allow the
ViewHandler to be pluggable enabled the concept of a View Declaration
Language for JSF. The two most popular ones were Facelets and
JSFTemplating. The new integration should preserve this pluggability,
since it is still valuable to be able to replace the View Declaration
Language.

After polling users of Facelets, the expert
group decided that most of them were only using the markup based API and
were not extending from the Java classes provided by the Facelet
project. Therefore, we decided to keep the Java API for Facelets in JSF
2 as small as possible, only exposing classes where absolutely
necessary.

The application of these principles produced
the classes in the package _javax.faces.view.facelets_ . Please consult
the Javadocs for that package, and the classes within it, for additional
normative specification _._

=== [[a5608]]Specification of the ViewDeclarationLanguage Implementation for Facelets for JSF 2.0

As normatively specified in the javadocs for
_ViewDeclarationLanguageFactory.getViewDeclarationLanguage()_ , a JSF
implementation must guarantee that a valid and functional
_ViewDeclarationLanguage_ instance is returned from this method when the
argument is a refrence to either a JSP view, a Faces XML View or a
Facelets View. This section describes the specification for the Facelets
implementation.

[width="100%",cols="100%",]
|===
a|
public void buildView(FacesContext context,

 UIViewRoot root)

 throws IOException



|===

The argument _root_ will have been created
with a call to either _createView()_ or
_ViewMetadata.createMetadataView()_ . If the root already has
non-metadata children, the view must still be re-built, but care must be
taken to ensure that the existing components are correctly paired up
with their VDL counterparts in the VDL page. The implementation must
examine the _viewId_ of the argument root, which must resolve to an
entity written in Facelets for JSF 2 markup language. Because Facelets
for JSF 2.0 views are written in XHTML, an XML parser is well suited to
the task of processing such an entity. Each element in the XHTML view
falls into one of the following categories, each of which corresponds to
an instance of a Java object that implements
_javax.faces.view.facelets.FaceletHandler_ , or a subinterface or
subclass thereof, and an instance of
_javax.faces.view.facelets.TagConfig_ , or a subinterface or subclass
thereof, which is passed to the constructor of the object implementing
_FaceletHandler_ .

When constructing the _TagConfig_
implementation to be passed to the _FaceletHandler_ implementation, the
runtime must ensure that the instance returned from _TagConfig.getTag()_
has been passed through the tag decoration process as described in the
javadocs for _javax.faces.view.facelets.TagDecorator_ prior to the
_TagConfig_ being passed to the _FaceletHandler_ implementation.

The mapping between the categories of
elements in the XHTML view and the appropriate sub-interface or subclass
of _FaceletHandler_ is specified below. Each _FaceletHandler_ instance
must be traversed and its _apply()_ method called in the same
depth-first order as in the other lifecycle phase methods in jsf. Each
_FaceletHandler_ instance must use the _getNextHandler()_ method of the
_TagConfig_ instance passed to its constructor to perform the traversal
starting from the root _FaceletHandler_ .

Standard XHTML markup elements

These are declared in the XHTML namespace
_http://www.w3.org/1999/xhtml_ . Such elements should be passed through
as is to the rendered output.

These elements correspond to instances of
_javax.faces.view.facelets.TextHandler_ . See the javadocs for that
class for the normative specification.

Markup elements that represent _UIComponent_
instance in the view.

These elements can come from the Standard
HTML Renderkit namespace _http://java.sun.com/jsf/html_ , or from the
namespace of a custom tag library (including composite components) as
described in link:JSF.html#a5638[See Facelet Tag Library
mechanism].

These elements correspond to instances of
_javax.faces.view.facelets.ComponentHandler_ . See the javadocs for that
class for the normative specification.

Markup elements that take action on their
parent or children markup element(s). Usually these come from the JSF
Core namespace _http://java.sun.com/jsf/core_ , but they can also be
provided by a custom tag library.

Such elements that represent an attached
object must correspond to an appropriate subclass of
_javax.faces.view.facelets.FaceletsAttachedObjectHandler_ . The
supported subclasses are specified in the javadocs.

Such elements that represent a facet
component must correspond to an instance of
_javax.faces.component.FacetHandler_ .

Such elements that represent an attribute
that must be pushed into the parent _UIComponent_ element must
correspond to an instance of
_javax.facelets.view.facelets.AttributeHandler_ .

Markup Elements that indicate facelet
templating, as specified in the VDL Docs for the namespace
_http://java.sun.com/jsf/facelets_ .

Such elements correspond to an instance of
_javax.faces.view.facelets.TagHandler_ .

Markup elements from the Facelet version of
the JSTL namespaces _http://java.sun.com/jsp/jstl/core_ or
_http://java.sun.com/jsp/jstl/functions_ , as specified in the VDL Docs
for those namespaces.

Such elements correspond to an instance of
_javax.faces.view.facelets.TagHandler_ .

=== 

image:SF-43.png[image]

XHTML Specification for Facelets for JSF 2.0

=== [[a5632]]General Requirements

[P1-start_facelet_xhtml]Facelet pages are
authored in XHTML. The runtime must support all XHTML pages that conform
to the XHTML-1.0-Transitional DTD, as described at
_http://www.w3.org/TR/xhtml1/#a_dtd_XHTML-1.0-Transitional_ .

The runtime must ensure that EL expressions
that appear in the page without being the right-hand-side of a tag
attribute are treated as if they appeared on the right-hand-side of the
_value_ attribute of an _<h:outputText />_ element in the
_http://java.sun.com/jsf/html_ namespace. This behavior must happen
regardless of whether or not the _http://java.sun.com/jsf/html_
namespace has been declared in the page.

=== [[a5635]]DOCTYPE and XML Declaration

When processing Facelet VDL files, the system
must ensure that at most one XML declaration and at most one DOCTYPE
declaration appear in the rendered markup, if and only if there is
corresponding markup in the Facelet VDL files for those elements. If
multiple occurrences of XML declaration and DOCTYPE declaration are
encountered when processing Facelet VDL files, the “outer-most”
occurrence is the one that must be rendered. If an XML declaration is
present, it must be the very first markup rendered, and it must precede
any DOCTYPE declaration (if present). The output of the XML and DOCTYPE
declarations are subject to the configuration options listed in the
table titled “Valid <process-as> values and their implications on the
processing of Facelet VDL files” in link:JSF.html#a7061[See The
facelets-processing element].

{empty}[P1-end_facelet_xhtml]

=== [[a5638]]Facelet Tag Library mechanism

Facelets leverages the XML namespace
mechanism to support the concept of a “tag library” analogous to the
same concept in JSP. However, in Facelets, the role of the tag handler
java class is greatly reduced and in most cases is unnecessary. The tag
library mechanism has two purposes.

Allow page authors to access tags declared in
the supplied tag libraries declared in link:JSF.html#a5691[See
Standard Facelet Tag Libraries], as well as accessing third-party tag
libraries developed by the application author, or any other third party

Define a framework for component authors to
group a collection of custom _UIComponent_ s into a tag library and
expose them to page authors for use in their pages.

[P1_start_facelet_taglib_decl]The runtime
must support the following syntax for making the tags in a tag library
available for use in a Facelet page.

[width="100%",cols="100%",]
|===
a|
<html xmlns="http://www.w3.org/1999/xhtml"

 xmlns: _prefix_ =" _namespace_uri_ ">

|===

Where _prefix_ is a page author chosen
arbitrary string used in the markup inside the _<html>_ tag to refer to
the tags declared within the tag library and _namespace_uri_ is the
string declared in the _<namespace>_ element of the facelet tag library
descriptor. For example, declaring
_xmlns:h="http://java.sun.com/jsf/html"_ within the _<html>_ element in
a Facelet XHTML page would cause the runtime to make all tags declared
in link:JSF.html#a6029[See Standard HTML RenderKit Tag Library]
to be available for use in the page using syntax like: _<h:inputText />_
.

The unprefixed namespace, also known as the
root namespace, must be passed through without modification or check for
validity. The passing through of the root namespace must occur on any
non-prefixed element in a facelet page. For example, the following
markup declaration:.

[width="100%",cols="100%",]
|===
a|
<html xmlns="http://www.w3.org/1999/xhtml" +
xmlns: _h_ =" _http://java.sun.com/jsf/html_ "> +
<math xmlns="http://www.w3.org/1998/Math/MathML"> +
<msup> +
<msqrt> +
<mrow> +
<mi>a</mi> +
<mo>+</mo> +
 +
<mi>b</mi> +
</mrow> +
</msqrt> +
<mn>27</mn> +
</msup>

</math>



|===

would be rendered as

[width="100%",cols="100%",]
|===
a|
<html xmlns="http://www.w3.org/1999/xhtml"> +
<math xmlns="http://www.w3.org/1998/Math/MathML"> +
<msup> +
<msqrt> +
<mrow> +
<mi>a</mi> +
<mo>+</mo> +
 +
<mi>b</mi> +
</mrow> +
</msqrt> +
<mn>27</mn> +
</msup>

</math>



|===

{empty}[P1_end_facelet_taglib_decl]

[P1_start_facelet_taglib_discovery]The run
time must support two modes of discovery for Facelet tag library
descriptors

{empty}Via declaration in the web.xml, as
specified in link:JSF.html#a6088[See Application Configuration
Parameters]

Via auto discovery by placing the tag library
discriptor file within a jar on the web application classpath, naming
the file so that it ends with “ _.taglib.xml_ ”, without the quotes, and
placing the file in the _META-INF_ directory in the jar file.

{empty}The discovery of tag library files
must happen at application startup time and complete before the
application is placed in service. Failure to parse, process and
otherwise interpret any of the tag library files discovered must cause
the application to fail to deploy and must cause an informative error
message to be logged.[P1_end_facelet_taglib_discovery]

The specification for how to interpret a
facelet tag library descriptor is included in the documentation elements
of the schema for such files, see link:JSF.html#a7134[See XML
Schema Definition For Facelet Taglib].



=== [[a5661]]Requirements specific to composite components

The text in this section makes use of the
terms defined in link:JSF.html#a1619[See Composite Component
Terms]. When such a term appears in this section, it will be in
_emphasis font face_ .

=== [[a5663]]Declaring a composite component library for use in a Facelet page

[P1_start_composite_library_decl]The runtime
must support the following two ways of declaring a _composite component
library_ .

If a facelet taglibrary is declared in an
XHTML page with a namespace starting with the string “
_http://java.sun.com/jsf/composite/_ ” (without the quotes), the
remainder of the namespace declaration is taken as the name of a
resource library as described in link:JSF.html#a836[See
Libraries of Localized and Versioned Resources], as shown in the
following example:

[width="100%",cols="100%",]
|===
a|
<html xmlns="http://www.w3.org/1999/xhtml"

 xmlns: _ez_ ="
_http://java.sun.com/jsf/composite/_ ezcomp">

|===

The runtime must look for a resource library
named _ezcomp_ . If the substring following “
_http://java.sun.com/jsf/composite/_ ” contains a “ _/_ ” character, or
any characters not legal for a library name the following action must be
taken. If _application.getProjectStage()_ is _Development_ an
informative error message must be placed in the page and also logged.
Otherwise the message must be logged only.

{empty}As specified in facelet taglibrary
schema, the runtime must also support the _<composite-library-name>_
element. The runtime must interpret the contents of this element as the
name of a resource library as described in
link:JSF.html#a836[See Libraries of Localized and Versioned
Resources]. If a facelet tag library descriptor file is encountered that
contains this element, the runtime must examine the _<namespace>_
element in that same tag library descriptor and make it available for
use in an XML namespace declaration in facelet
pages.[P1_end_composite_library_decl]

=== [[a5670]]Creating an instance of a _top level component_

[P1_start_top_level_component_creation]If,
during the process of building the view, the facelet runtime encounters
an element in the page using the prefix for the namespace of a composite
component library, the runtime must create a _Resource_ instance with a
library property equal to the library name derived in
link:JSF.html#a5663[See Declaring a composite component library
for use in a Facelet page]and call the variant of
_application.createComponent()_ that takes a _Resource_ .

{empty}After causing the _top level
component_ to be instantiated, the runtime must create a _UIComponent_
with component-family of _javax.faces.Panel_ and renderer-type
_javax.faces.Group_ to be installed as a facet of the _top level
component_ under the facet name _UIComponent.COMPOSITE_FACET_NAME_
.[P1_end_top_level_component_creation]

=== Populating a _top level component_ instance with children

{empty}[P1_start_top_level_component_population]As
specified in link:JSF.html#a1545[See How does one make a
composite component?] the runtime must support the use of _composite:_
tag library in the _defining page_ pointed to by the _Resource_ derived
as specified in link:JSF.html#a5670[See Creating an instance of
a top level component]. [P1_start_top_level_component_population]The
runtime must ensure that all _UIComponent_ children in the _composite
component definition_ within the _defining page_ are placed as children
of the _UIComponent.COMPOSITE_FACET_NAME_ facet of the _top level
facet._ [P1_end_top_level_component_population]

Please see the tag library documentation for
the _<composite:insertChildren>_ and _<composite:insertFacet>_ tags for
details on these two tags that are relevant to populating a _top level
component_ instance with children.

Special handling is required for attributes
declared on the _composite component tag_ instance in the _using page_ .
[P1_start_composite_component_tag_attributes]The runtime must ensure
that all such attributes are copied to the attributes map of the _top
level component_ instance in the following manner.

Obtain a reference to the _ExpressionFactory_
, for discussion called _expressionFactory_ .

Let the value of the attribute in the _using
page_ be _value_ .

If _value_ is “id” or “binding” without the
quotes, skip to the next attribute.

If the value of the attribute starts with
“#\{“ (without the quotes) call
_expressionFactory.createValueExpression(elContext, value,
Object.class)_

If the value of the attribute does not start
with “ _#\{_ “, call _expressionFactory.createValueExpression(value,
Object.class)_

{empty}If there already is a key in the _map_
for _value_ , inspect the type of the value at that key. If the type is
_MethodExpression_ take no action.
[P1_end_composite_component_tag_attributes]

For code that handles tag attributes on
_UIComponent_ XHTML elements special action must be taken regarding
composite components. [P1_start_composite_component_method_expression]If
the type of the attribute is a _MethodExpression_ , the code that takes
the value of the attribute and creates an actual _MethodExpression_
instance around it must take the following special action. Inspect the
value of the attribute. If the EL expression string starts with the _cc_
implicit object, is followed by the special string “ _attrs_ ” (without
the quotes), as specified in link:JSF.html#a2908[See Composite
Component Attributes ELResolver], and is followed by a single remaining
expression segment, let the value of that remaining expression segment
be _attrName_ . In this case, the runtime must guarantee that the actual
_MethodExpression_ instance that is created for the tag attribute have
the following behavior in its _invoke()_ method.

Obtain a reference to the current composite
component by calling _UIComponent.getCurrentCompositeComponent()_ .

Look in the attribute of the component for a
key under the value _attrName_ .

There must be a value and it must be of type
_MethodExpression_ . If either of these conditions are _false_ allow the
ensuing exception to be thrown.

{empty}Call _invoke()_ on the discovered
_MethodExpression_ , passing the arguments passed to our _invoke()_
method.[P1_end_composite_component_method_expression]

[P1_start_composite_component_retargeting]Once
the composite component has been populated with children, the runtime
must ensure that _ViewHandler.retargetAttachedObjects()_ and then
_ViewHandler.retargetMethodExpressions()_ is called, passing the _top
level component_ .[P1_end_composite_component_retargeting] The actions
taken in these methods set the stage for the tag attribute behavior and
the special _MethodExpression_ handling behavior described previously.

[P1_start_nested_composite_components]The
runtime must support the inclusion of composite components within the
_composite component definition_ . [P1_end_nested_composite_components].

=== 

image:SF-43.png[image]

[[a5691]]Standard Facelet Tag Libraries

This section specifies the tag libraries that
must be provided by an implementation.

=== JSF Core Tag Library

This tag library must be equivalent to the
one specified in link:JSF.html#a4636[See JSF Core Tag Library].

For all of the tags that correspond to
attached objects, the Facelets implementation supportes an additional
attribute, _for_ , which is intended for use when the attached object
tag exists within a composite component. If present, this attribute
refers to the value of one of the exposed attached objects within the
composite component inside of which this tag is nested.

The following additional tags apply to the
Facelet Core Tag Library only.

=== <f:ajax>

This tag serves two roles depending on its
placement. If this tag is nested within a single component, it will
associate an Ajax action with that component. If this tag is placed
around a group of components it will associate an Ajax action with all
components that support the “events” attribute. In there is an outer

=== Syntax

<f:ajax [event=”Literal”] [execute=”Literal |
Value Expression”] [render=”Literal | Value Expression”]
[onevent=”Literal | Value Expression”] [onerror=”Literal | Value
Expression”] | [listener=”Method Expression”] [disabled=”Literal|Value
Expression”] [immediate=”Literal|ValueExpression]/>

=== Body Content

empty.

=== Attributes

The following optional attributes are
available:

=== 

Name

Expr

Type

Description

event

String

String

A String identifying the type of event the
Ajax action will apply to. If specified, it must be one of the events
supported by the component the Ajax behavior is being applied to. If not
specified, the default event is determined for the component. The
default event is “action” for ActionSource components and “valueChange”
for EditableValueHolder components.

execute

VE

Collection<String>

If a literal is specified, it must be a space
delimited String of component identifiers and/or one of the keywords
outlined in link:JSF.html#a6884[See Keywords]. If not
specified, then @this is the default. If a ValueExpression is specified,
it must refer to a property that returns a Collection of Strings. Each
String in the Collection must not contain spaces.

render

VE

Collection<String>

If a literal is specified, it must be a space
delimited String of component identifiers and/or one of the keywords
outlined in link:JSF.html#a6884[See Keywords]. If not
specified, then @none is the default . If a ValueExpression is
specified, it must refer to a property that returns a Collection of
Strings. Each String in the Collection must not contain spaces.

onevent

VE

String

The name of a JavaScript function that will
handle events

onerror

VE

String

The name of a JavaScript function that will
handle errors.

disabled

VE

boolean

“false” indicates the Ajax behavior script
should be rendered; “true” indicates the Ajax behavior script should not
be rendered. “false” is the default.

listener

ME

MethodExpression

The listener method to execute when Ajax
requests are processed on he server.

immediate

VE

boolean

If “true” behavior events generated from this
behavior are broadcast during Apply Request Values phase. Otherwise, the
events will be broadcast during Invoke Aplications phase.

=== Specifying “execute”/”render” Identifiers

{empty}The String value for identifiers
specified for execute and render may be specified as a search expression
as outlined in the JavaDocs for UIComponent.findComponent.
[P1_start_execrenderIds]The implementation must resolve these
identifiers as specified for UIComponent.findComponent.[P1_end]

=== Constraints

This tag may be nested within any of the
standard HTML components. It may also be nested within any custom
component that implements the ClientBehaviorHolder interface. Refer to
link:JSF.html#a1707[See Component
Behavior Model] for more information about this interface.
[P1_start_ajaxtag_events]A TagAttibuteException must be thrown if an
“event” attribute value is specified that does not match the events
supported by the component type. [P1_end_ajaxtag_events] For example:

[width="100%",cols="100%",]
|===
a|
<h:commandButton ..>

<f:ajax event=”valueChange”/>

</h:commandButton id=”button1” ...>

|===

{empty}An attempt is made to apply a
“valueChange” Ajax event to an “action” component. This is invalid and
the Ajax behavior will not be applied. [P1_start_bevent]The event
attribute that is specified, must be one of the events returned from the
ClientBehaviorHolder component implementation of
ClientBehaviorHolder.getEventNames. If an event is not specified the
value returned from the component implementation of
ClientBehaviorHolder.getDefaultEventName must be used. If the event is
still not determined, a TagAttributeException must be thrown.[P1_end]

This tag may also serve to “ajaxify” regions
of a page by nesting a group of components within it:

[width="100%",cols="100%",]
|===
a|
<f:ajax>

<h:panelGrid>

<h:inputText id=”text1”/>

<h:commandButton id=”button1”/>

</h:panelGrid>

</f:ajax>

|===

From this example, “text1” and “button1” will
have ajax behavior applied to them. The default events for these
components would cause Ajax requests to fire. For “text1” a
“valueChange” event would apply and for “button1” an “action” event
would apply. <h:panelGrid> has no default event so in this case a
behavior would not be applied.

[width="100%",cols="100%",]
|===
a|
<f:ajax event=”click”>

<h:panelGrid id=”grid1”>

<h:inputText id=”text1”/>

<h:commandButton id=”button1”>

<f:ajax event=”mouseover”/>

</h:commandButton>

</h:panelGrid>

</f:ajax>

|===

From this example, “grid1” and “text1” would
have ajax behavior applied for an “onclick” event. “button1” would have
ajax behavior applied for both “mouseover” and “onclick” events. The
“oncick” event is a supported event type for PanelGrid components.

[width="100%",cols="100%",]
|===
a|
<f:ajax>

<h:commandButton id=”button1”>

<f:ajax/>

</h:commandButton>

</f:ajax>

|===

For this example, the inner <f:ajax/> would
apply to “button1”. The outer (wrapping) <f:ajax> would not be applied,
since it is the same type of submitting behavior (AjaxBehavior) and the
same event type (action).

[width="100%",cols="100%",]
|===
a|
<f:ajax event=”click”>

<h:inputText id=”text1”>

<f:ajax event=”click”/>

</h:inputText>

</f:ajax>

|===

For this example, since the event types are
the same, the inner <f:ajax> event overrides the outer one.



[width="100%",cols="100%",]
|===
a|
<f:ajax event=”action”>

<h:commandButton id=”button1”>

<b:greet event=”action”/>

</h:commandButton>

</f:ajax>

|===

Here, there is a custom behavior “greet”
attached to “button1”. the outer <f:ajax> Ajax behavior will also get
applied to “button1”. But it will be applied *after* the “greet”
behavior.

=== Description

Enable one or more components in the view to
perform Ajax operations. This tag handler must create an instance of
javax.faces.component.behavior.AjaxBehavior instance using the tag
attribute values. If this tag is nested within a single
ClientBehaviorHolder component:

If the event attribute is not specified,
determine the event by calling the component’s getDefaultEventName
method. If that returns null, throw an exception.

If the event attribute is specified, ensure
that it is a valid event - that is one of the events contained in the
Collection returned from getEventNames method. If it does not exist in
this Collection, throw an exception.

Add the AjaxBehavior to the component by
calling the addBehavior method, passing the event and AjaxBehavior
instance.

If this tag is wrapped around component
children add the AjaxBehavior instance to the data structure holding the
behaviors for that component. As subsequent child components that
implement the BehaviorHolder interface are evaluated, this AjaxBehavior
instance must be added as a Behavior to the component. Please refer to
the Javadocs for the core tag handler AjaxHandler for additional
requirements.

=== Examples

Apply Ajax to “button1” and “text1”:

[width="100%",cols="100%",]
|===
a|
<f:ajax>

<h:form>

<h:commandButton id=”button1” ...>

<h:inputText id=”text1” ..>

</h:form>

</f:ajax>

|===

Apply Ajax to “text1”:

[width="100%",cols="100%",]
|===
a|
<f:ajax event=”valueChange”>

<h:form>

<h:commandButton id=”button1” ...>

<h:inputText id=”text1” ..>

</h:form>

</f:ajax>

|===

Apply Ajax to “button1”:

[width="100%",cols="100%",]
|===
a|
<f:ajax event=”action”>

<h:form>

<h:commandButton id=”button1” ...>

<h:inputText id=”text1” ..>

</h:form>

</f:ajax>

|===

Override default Ajax action. “button1” is
associated with the Ajax “execute=’cancel’” action:[[a5815]]

[width="100%",cols="100%",]
|===
a|
<f:ajax event=”action” execute=”reset”>

<h:form>

<h:commandButton id=”button1” ...>

<f:ajax execute=”cancel”/>

</h:commandButton>

<h:inputText id=”text1” ..>

</h:form>

</f:ajax>

|===

=== <f:event>

Allow JSF page authors to install
_ComponentSystemEventListener_ instances on a component in a page.
Because this tag is closely tied to the event system, please see section
link:JSF.html#a1393[See Declarative Listener Registration] for
the normative specification.

=== <f:metadata>

Register a facet on the parent component,
which must be the _UIViewRoot_ . This must be a child of the _<f:view>_
. This tag must reside within the top level XHTML file for the given
viewId, not in a template. The implementation must ensure that the
direct child of the facet is a _UIPanel_ , even if there is only one
child of the facet. The implementation must set the id of the _UIPanel_
to be the value of the _UIViewRoot.METADATA_FACET_NAME_ symbolic
constant.

=== [[a5828]]<f:validateBean>

Register a BeanValidator instance on the
parent EditableValueHolder UIComponent or the EditableValueHolder
UIComponent whose client id matches the value of the "for" attribute
when used within a composite component. If neither criteria is
satisfied, save the validation groups in an attribute on the parent
UIComponent to be used as defaults inherited by any BeanValidator in
that branch of the component tree. Don't save the validation groups
string if it is null or empty string. If the validationGroups attribute
is not defined on this tag when used in an EditableValueHolder, or the
value of the attribute is empty string, attempt to inherit the
validation groups from the nearest parent component on which a set of
validation groups is stored. If no validation groups are inherited,
assume the Default validation group, javax.validation.groups.Default. If
the BeanValidator is one of the default validators, then this tag simply
specializes the validator by providing the list of validation groups to
be used. There are two usage patterns for this tag, both shown below.
The tags surrounding and nested within the _<f:validateBean>_ tag, as
well as the attributes of the tag itself, are show for illustrative
purposes only.

Syntax

 _<h:inputText value=”#\{model.property}”> +
<f:validateBean validationGroups= +
"javax.validation.groups.Default,app.validation.groups.Order"/> +
</h:inputText>_

or

 _<h:form> +
<f:validateBean> +
<h:inputText value=”#\{model.property}” /> +
<h:selectOneRadio value=”#\{model.radioProperty}” > ...
</h:selectOneRadio> +
_ <!-- other input components here --> +
</f:validateBean> +
</h:form>

=== Body Content

Empty in the case when the Bean Validator is
to be registered on a parent component.

Filled with input components when the Bean
Validator is to be set on all of the ensclosing input components.

Attributes

[width="100%",cols="25%,25%,25%,25%",options="header",]
|===
|Name |Exp
|Type |Description
|binding |VE
|ValueExpression
|A ValueExpression that evaluates to an
object that implements javax.faces.validate.BeanValidator

|disabled |VE
|Boolean |A flag
which indicates whether this validator, or a default validator with the
id "javax.faces.Bean", should be permitted to be added to this component

|validationGroups
|VE |String
|A comma-delimited of type-safe validation
groups that are passed to the Bean Validation API when validating the
value
|===

Constraints

Must be nested in an EditableValueHolder or
nested in a composite component and have a for attribute. Otherwise, it
simply defines enables or disables the validator as a default for the
branch of the component tree under the parent component and/or sets the
validation group defaults for the branch. No exception is thrown if one
of the first two conditions are not met, unlike other standard
validators.

Description

Must use or extend the
_javax.faces.view.facelets.ValidatorHandler_ class

If not within an EditableValueHolder or
composite component, store the validation groups as defaults for the
current branch of the component tree, but only if the value is a
non-empty string.

If the disabled attribute is true, the
validator should not be added. In addition, the validatorId, if present,
should be added to an exclusion list on the parent component to prevent
a default validator with the same id from being registered on the
component.

The createValidator() method must:

If binding is non-null, create a
ValueExpression by invoking Application.createValueExpression() with
binding as the expression argument, and Validator.class as the
expectedType argument. Use the ValueExpression to obtain a reference to
the Validator instance. If there is no exception thrown, and
ValueExpression.getValue() returned a non-null object that implements
javax.faces.validator.Validator, it must then cast the returned instance
to javax.faces.validator.BeanValidator, configure its properties based
on the specified attributes, and return the configured instance. If
there was an exception thrown, rethrow the exception as a TagException.

Use the validatorId if the validator instance
could not be created from the binding attribute. Call the
createValidator() method of the Application instance for this
application, passing validator id "javax.faces.Bean". If the binding
attribute was also set, evaluate the expression into a ValueExpression
and store the validator instance by calling setValue() on the
ValueExpression. It must then cast the returned instance to
javax.faces.validator.BeanValidator, configure its properties based on
the specified attributes, and return the configured instance. If there
was an exception thrown, rethrow the exception as a TagException.

=== [[a5857]]<f:validateRequired>

Register a RequiredValidator instance on the
parent EditableValueHolder UIComponent or the EditableValueHolder
UIComponent whose client id matches the value of the "for" attribute
when used within a composite component.

Syntax

<f:validateRequired/>

=== Body Content

empty



Attributes

[width="100%",cols="25%,25%,25%,25%",options="header",]
|===
|Name |Exp
|Type |Description
|binding |VE
|ValueExpression
|A ValueExpression that evaluates to an
object that implements javax.faces.validate.RequiredValidator

|disabled |VE
|Boolean |A flag
which indicates whether this validator, or a default validator with the
id "javax.faces.Required", should be permitted to be added to this
component
|===



Constraints

Must be nested in an EditableValueHolder or
nested in a composite component and have a for attribute (Facelets
only). Otherwise, it simply enables or disables the use of the validator
as a default for the branch of the component tree under the parent. No
exception is thrown if one of the first two conditions are not met,
unlike other standard validators.



Description

Must use or extend the
_javax.faces.view.facelets.ValidatorHandler_ class

If the disabled attribute is true, the
validator should not be added. In addition, the validatorId, if present,
should be added to an exclusion list on the parent component to prevent
a default validator with the same id from being registered on the
component

The createValidator() method must:

If binding is non-null, create a
ValueExpression by invoking Application.createValueExpression() with
binding as the expression argument, and Validator.class as the
expectedType argument. Use the ValueExpression to obtain a reference to
the Validator instance. If there is no exception thrown, and
ValueExpression.getValue() returned a non-null object that implements
javax.faces.validator.Validator, it must then cast the returned instance
to javax.faces.validator.RequiredValidator, configure its properties
based on the specified attributes, and return the configured instance.
If there was an exception thrown, rethrow the exception as a
TagException..

Use the validatorId if the validator instance
could not be created from the binding attribute. Call the
createValidator() method of the Application instance for this
application, passing validator id "javax.faces.Required". If the binding
attribute was also set, evaluate the expression into a ValueExpression
and store the validator instance by calling setValue() on the
ValueExpression. It must then cast the returned instance to
javax.faces.validator.RequiredValidator, configure its properties based
on the specified attributes, and return the configured instance. If
there was an exception thrown, rethrow the exception as a TagException.

=== <f:validateWholeBean>

Support multi-field validation by enabling
class-level bean validation on CDI based backing beans.

Syntax

 _<!-- one or more components validated by
<f:validateBean /> +
precede this tag in the tree, with each one using the same +
validationGroups value and referencing properties on the same +
model object --> +
 +
<f:validateWholeBean value=_ " _#\{model}_ " _ +
validationGroups=_ " _fully.qualified.class.Name_ " _/>_

=== Body Content

empty



Attributes

[width="100%",cols="25%,25%,25%,25%",options="header",]
|===
|Name |Exp
|Type |Description
|disabled |VE
|Boolean |A flag
which indicates whether this validator, or a default validator with the
id "javax.faces.Required", should be permitted to be added to this
component

|validationGroups
|VE |String
|A comma-delimited of type-safe validation
groups that are passed to the Bean Validation API when validating the
value

|value |VE
|Object |A
ValueExpression referencing the bean to be validated.
|===



Constraints

This tag must be placed in the component tree
after all of the fields that are to be included in the multi-field
validation. If this precondition is not met, the results of applying
this tag are unspecified.

Description

See the VDLDoc for _<f:validateWholeBean />_
for the normative specification and a usage example.

=== [[a5904]]<f:websocket>

This tag registers a websocket push
connection at the client side by rendering the necessary scripts. Push
messages can be sent from server side via _javax.faces.push.PushContext_
interface which is injected into a using class with the
_@javax.faces.push.Push_ CDI qualifier.

=== 

image:SF-44.png[image]

<f:websocket> is desgined for push from server to client

image:SF-44.png[image]

Although W3C WebSocket supports two-way
communication, the <f:websocket> push is designed for one-way
communication, from server to client. In case you intend to send some
data from client to server, continue using JSF ajax the usual way. This
has among others the advantage of maintaining the JSF view state, the
HTTP session and, critically, all security constraints on business
service methods.

=== Syntax

 _<f:websocket [binding=_ " _ValueExpression_
" _] [id=_ " _Literal|ValueExpression_ " _] +
channel=_ " _Literal_ " _[scope=_ " _Literal_ " _] [user=_ "
_Literal|ValueExpression_ " _] +
[onopen=_ " _Literal|ValueExpression_ " _] [onmessage=_ "
_Literal|ValueExpression_ " _] +
[onclose=_ " _Literal|ValueExpression_ " _] [connected=_ "
_Literal|ValueExpression_ " _] +
[rendered=_ " _Literal|ValueExpression_ " _] />_

=== Body Content

Empty, or one or more _<f:ajax>_ tags with
the _event_ attribute set to exactly the push message content.

=== Attributes

The following required attribute must be set:

=== 

Name

Expr

Type

Description

channel

String

String

The name of the websocket channel. It may not
be an EL expression and it may only contain alphanumeric characters,
hyphens, underscores and periods. All open websockets on the same
channel name will receive the same push notification from the server.

The following optional attributes are
available:

=== 

[width="100%",cols="25%,25%,25%,25%",options="header",]
|===
|Name |Exp
|Type |Description
|id |VE
|String |Component
identifier of the _UIWebSocket_ component to be created.

|scope |String
|String |The scope
of the websocket channel. It may not be an EL expression and allowed
values are _application_ , _session_ and _view_ , case insensitive. When
the value is _application_ , then all channels with the same name
throughout the application will receive the same push message. When the
value is _session_ , then only the channels with the same name in the
current user session will receive the same push message. When the value
is _view_ , then only the channel in the current view will receive the
push message. The default scope is _application_ . When the _user_
attribute is specified, then the default scope is _session_ .

|user |VE
|Serializable |The
user identifier of the websocket channel, so that user-targeted push
messages can be sent. It must implement Serializable and preferably have
low memory footprint. Suggestion: use #\{request.remoteUser} or
#\{someLoggedInUser.id}. All open websockets on the same channel and
user will receive the same push message from the server.

|onopen |VE
|String |The
JavaScript event handler function that is invoked when the websocket is
opened. The function will be invoked with one argument: the channel
name.

|onmessage |VE
|String |The
JavaScript event handler function that is invoked when a push message is
received from the server. The function will be invoked with three
arguments: the push message, the channel name and the raw MessageEvent
itself.

|onclose |VE
|String |The
JavaScript event handler function that is invoked when the websocket is
closed. The function will be invoked with three arguments: the close
reason code, the channel name and the raw CloseEvent itself. Note that
this will also be invoked on errors and that you can inspect the close
reason code if an error occurred and which one (i.e. when the code is
not 1000). See also RFC 6455 section 7.4.1 and
javax.websocket.CloseReason.CloseCodes API for an elaborate list of all
close codes.

|connected |VE
|Boolean |Whether
to (auto)connect the websocket or not. Defaults to true. It's
interpreted as a JavaScript instruction whether to open or close the
websocket push connection. This attribute is implicitly re-evaluated on
every ajax request by a PreRenderViewEvent listener on the UIViewRoot.
You can also explicitly set it to false and then manually control in
JavaScript by jsf.push.open(clientId) and jsf.push.close(clientId).

|rendered |VE
|Boolean |Whether
to render the websocket scripts or not. Defaults to true. This attribute
is implicitly re-evaluated on every ajax request by a PreRenderViewEvent
listener on the UIViewRoot. If the value changes to false while the
websocket is already opened, then the websocket will implicitly be
closed.

|binding |VE
|UIComponent
|Value binding expression to a backing bean
property bound to the component instance for the UIComponent created by
this tag.
|===

=== Configuration

First, enable the websocket endpoint using
the context parameter:

[width="100%",cols="100%",]
|===
|<context-param> +
<param-name>javax.faces.ENABLE_WEBSOCKET_ENDPOINT</param-name> +
<param-value>true</param-value> +
</context-param>
|===

In case your server is configured to run a
WebSocket container on a different TCP port than the HTTP container,
then you can use the optional javax.faces.WEBSOCKET_ENDPOINT_PORT
integer context parameter in web.xml to explicitly specify the port.

[width="100%",cols="100%",]
|===
|<context-param> +
<param-name>javax.faces.WEBSOCKET_ENDPOINT_PORT</param-name> +
<param-value>8000</param-value> +
</context-param>
|===

=== Usage (client)

Declare <f:websocket> tag in the JSF view
with at least a channel name and an onmessage JavaScript listener
function. The channel name may not be an EL expression and it may only
contain alphanumeric characters, hyphens, underscores and periods.

Here's an example which refers an existing
JavaScript listener function.

[width="100%",cols="100%",]
|===
a|
<f:websocket channel="someChannel" +
onmessage="someWebsocketListener" /> +
 +
function someWebsocketListener(message, channel, event) \{

 console.log(message);

}



|===

Here’s an example which declares an inline
JavaScript listener function.

[width="100%",cols="100%",]
|===
|<f:websocket channel="someChannel" +
onmessage="function(m)\{console.log(m);}" />
|===

The onmessage JavaScript listener function
will be invoked with three arguments:

 message: the push message as JSON object.

channel: the channel name.

event: the raw MessageEvent instance.

When successfully connected, the websocket is
by default open as long as the document is open, and it will
auto-reconnect at increasing intervals when the connection is
closed/aborted as result of e.g. a network error or server restart. It
will not auto-reconnect when the very first connection attempt already
fails. The websocket will be implicitly closed once the document is
unloaded.

=== Usage (server)

On the Java programming side, you can inject
a PushContext via @Push annotation on the given channel name in any
CDI/container managed artifact, such as @Named, @WebServlet, wherever
you'd like to send a push message and then invoke
PushContext.send(Object) with any Java object representing the push
message.

[width="100%",cols="100%",]
|===
|@Inject @Push +
private PushContext someChannel; +
 +
public void sendMessage(Object message) \{ +
someChannel.send(message); +
}
|===

By default the name of the channel is taken
from the name of the variable into which injection takes place.

The channel name can be optionally specified
via the channel attribute. The example below injects the push context
for channel name foo into a variable named bar.

[width="100%",cols="100%",]
|===
|@Inject @Push(channel="foo") +
private PushContext bar;
|===

The message object will be encoded as JSON
and be delivered as message argument of the onmessage JavaScript
listener function associated with the channel name. It can be a plain
vanilla String, but it can also be a collection, map and even a Java
bean.

=== Scopes and Users

By default the websocket is application
scoped, i.e. any view/session throughout the web application having the
same websocket channel open will receive the same push message. The push
message can be sent by all users and the application itself.

The optional scope attribute can be set to
session to restrict the push messages to all views in the current user
session only. The push message can only be sent by the user itself and
not by the application.

[width="100%",cols="100%",]
|===
|<f:websocket channel="someChannel"
scope="session" ... />
|===

The scope attribute can also be set to view
to restrict the push messages to the current view only. The push message
will not show up in other views in the same session even if it's the
same URL. The push message can only be sent by the user itself and not
by the application..

[width="100%",cols="100%",]
|===
|<f:websocket channel="someChannel"
scope="view" ... />
|===

The scope attribute may not be an EL
expression and allowed values are _application_ , _session_ and _view_ ,
case insensitive.

Additionally, the optional user attribute can
be set to the unique identifier of the logged-in user, usually the login
name or the user ID. This way the push message can be targeted to a
specific user and can also be sent by other users and the application
itself. The value of the user attribute must at least implement
Serializable and have a low memory footprint, so an entire user entity
is not recommended.

E.g. when you're using container managed
authentication or a related framework/library:.

[width="100%",cols="100%",]
|===
|<f:websocket channel="someChannel" +
user="#\{request.remoteUser}" ... />
|===

Or when you have a custom user entity
accessible via EL, such as as #\{someLoggedInUser} which has an id
property representing its identifier:.

[width="100%",cols="100%",]
|===
|<f:websocket channel="someChannel" +
user="#\{someLoggedInUser.id}" ... />
|===

When the user attribute is specified, then
the scope defaults to session and cannot be set to application.

On the server side, the push message can be
targeted to the user specified in the user attribute via
PushContext.send(Object, Serializable). The push message can be sent by
all users and the application itself..

[width="100%",cols="100%",]
|===
|@Inject @Push +
private PushContext someChannel; +
 +
public void sendMessage(Object message, User recipientUser) \{ +
Long recipientUserId = recipientUser.getId(); +
someChannel.send(message, recipientUserId); +
}
|===

Multiple users can be targeted by passing a
Collection holding user identifiers to PushContext.send(Object,
Collection)..

[width="100%",cols="100%",]
|===
|public void sendMessage(Object message,
Group recipientGroup) \{ +
Collection<Long> recipientUserIds = +
recipientGroup.getUserIds(); +
someChannel.send(message, recipientUserIds); +
}
|===

=== Conditionally Connecting

You can use the optional connected attribute
to control whether to auto-connect the websocket or not..

[width="100%",cols="100%",]
|===
|<f:websocket ...
connected="#\{bean.pushable}" />
|===

The _connected_ attribute defaults to true
and is interpreted as a JavaScript instruction whether to open or close
the websocket push connection. If the value is an EL expression and it
becomes false during an ajax request, then the push connection will
explicitly be closed during _oncomplete_ of that ajax request.

You can also explicitly set it to false and
manually open the push connection in client side by invoking
jsf.push.open(clientId), passing the component's client ID..

[width="100%",cols="100%",]
|===
|<h:commandButton ...
onclick="jsf.push.open('foo')"> +
<f:ajax ... /> +
</h:commandButton> +
<f:websocket id="foo" channel="bar" scope="view" ... +
connected="false" />
|===

In case you intend to have an one-time push
and don’t expect more messages, you can optionally explicitly close the
push connection from client side by invoking jsf.push.close(clientId),
passing the component’s client ID. For example, in the onmessage
JavaScript listener function as below:.

[width="100%",cols="100%",]
|===
|function someWebsocketListener(message) \{ +
// ... +
jsf.push.close('foo'); +
}
|===

=== Events (client)

The optional onopen JavaScript listener
function can be used to listen on open of a websocket in client side.
This will be invoked on the very first connection attempt, regardless of
whether it will be successful or not. This will not be invoked when the
websocket auto-reconnects a broken connection after the first successful
connection.

[width="100%",cols="100%",]
|===
|<f:websocket ...
onopen="websocketOpenListener" /> +
 +
function websocketOpenListener(channel) \{ +
// ... +
}
|===

The _onopen_ JavaScript listener function
will be invoked with one argument:

channel: the channel name, useful in case you
intend to have a global listener.

The optional onclose JavaScript listener
function can be used to listen on a normal or abnormal close of a
websocket. This will be invoked when the very first connection attempt
fails, or the server has returned close reason code 1000 (normal
closure) or 1008 (policy violated), or the maximum reconnect attempts
has been exceeded. This will not be invoked when the websocket can make
an auto-reconnect attempt on a broken connection after the first
successful connection

[width="100%",cols="100%",]
|===
|<f:websocket ...
onclose="websocketCloseListener" /> +
 +
function websocketCloseListener(code, channel, event) \{ +
if (code == -1) \{ +
// Websockets not supported by client. +
} else if (code == 1000) \{ +
// Normal close (as result of expired session or view). +
} else \{ +
// Abnormal close reason (as result of an error). +
} +
}
|===

The _onclose_ JavaScript listener function
will be invoked with three arguments:

code: the close reason code as integer. If
this is -1, then the websocket is simply not supported by the client. If
this is 1000, then it was normally closed. Otherwise, if this is not
1000, then there may be an error. See also RFC 6455 section 7.4.1 and
javax.websocket.CloseReason.CloseCodes API for an elaborate list of all
close codes.

channel: the channel name.

event: the raw CloseEvent instance.

When a session or view scoped socket is
automatically closed with close reason code 1000 by the server (and thus
not manually by the client via jsf.push.close(clientId)), then it means
that the session or view has expired.

=== Events (server)

When a session or view scoped socket is
automatically closed with close reason code 1000 by the server (and thus
not manually by the client via jsf.push.close(clientId)), then it means
that the session or view has expired.

[width="100%",cols="100%",]
|===
a|
@ApplicationScoped +
public class WebsocketObserver \{ +
 +
public void onOpen(@Observes @Opened WebsocketEvent event) \{ +
String channel = event.getChannel(); +
// Returns <f:websocket channel>. +
Long userId = event.getUser(); +
// Returns <f:websocket user>, if any. +
// ... +
} +
 +
public void onClose(@Observes @Closed WebsocketEvent event) \{ +
String channel = event.getChannel(); +
// Returns <f:websocket channel>. +
Long userId = event.getUser();

 // Returns <f:websocket user>, if any. +
CloseCode code = event.getCloseCode(); +
// Returns close reason code. +
// ... +
}

|===

=== Security Considerations

If the socket is declared in a page which is
only restricted to logged-in users with a specific role, then you may
want to add the URL of the push handshake request URL to the set of
restricted URLs.



The push handshake request URL is composed of
the URI prefix /javax.faces.push/, followed by channel name. In the
example of container managed security which has already restricted an
example page /user/foo.xhtml to logged-in users with the example role
USER on the example URL pattern /user/* in web.xml like below,

[width="100%",cols="100%",]
|===
|<security-constraint> +
<web-resource-collection> +
<web-resource-name>Restrict access to role USER. +
</web-resource-name> +
<url-pattern>/user/*</url-pattern> +
</web-resource-collection> +
<auth-constraint> +
<role-name>USER</role-name> +
</auth-constraint> +
</security-constraint>
|===

and the page /user/foo.xhtml in turn contains
a <f:websocket channel="foo">, then you need to add a restriction on
push handshake request URL pattern of _/javax.faces.push/foo_ as shown
next.

[width="100%",cols="100%",]
|===
|<security-constraint> +
<web-resource-collection> +
<web-resource-name>Restrict access to role USER. +
</web-resource-name> +
<url-pattern>/user/*</url-pattern> +
<url-pattern>/javax.faces.push/foo</url-pattern> +
</web-resource-collection> +
<auth-constraint> +
<role-name>USER</role-name> +
</auth-constraint> +
</security-constraint>
|===

As extra security, particularly for those
public channels which can’t be restricted by security constraints, the
<f:websocket> will register all so previously declared channels in the
current HTTP session, and any incoming websocket open request will be
checked whether they match these channels in the current HTTP session.
In case the channel is unknown (e.g. randomly guessed or spoofed by end
users or manually reconnected after the session is expired), then the
websocket will immediately be closed with close reason code
CloseCodes.VIOLATED_POLICY (1008). Also, when the HTTP session gets
destroyed, all session and view scoped channels which are still open
will explicitly be closed from server side with close reason code
CloseCodes.NORMAL_CLOSURE (1000). Only application scoped sockets remain
open and are still reachable from server end even when the session or
view associated with the page in client side is expired.

=== Ajax Support

In case you’d like to perform complex UI
updates depending on the received push message, then you can nest
<f:ajax> inside <f:websocket>. Here’s an example:

[width="100%",cols="100%",]
|===
|<h:panelGroup id="foo"> +
... (some complex UI here) ... +
</h:panelGroup> +
 +
<h:form> +
<f:websocket channel="someChannel" scope="view"> +
<f:ajax event="someEvent" +
listener="#\{bean.pushed}" render=":foo" /> +
</f:websocket> +
</h:form>
|===

Here, the push message simply represents the
ajax event name. You can use any custom event name.

[width="100%",cols="100%",]
|===
|someChannel.send("someEvent");
|===

An alternative is to combine <f:websocket>
with <h:commandScript>. The <f:websocket onmessage> can reference
exactly the <h:commandScript name>. For example,

[width="100%",cols="100%",]
|===
|<h:panelGroup id="foo"> +
... (some complex UI here) ... +
</h:panelGroup> +
<f:websocket channel="someChannel" scope="view" +
onmessage="pushed" /> +
<h:form> +
<h:commandScript name="pushed" +
action="#\{bean.pushed}" render=":foo" /> +
</h:form>
|===

If you pass a Map<String,V> or a JavaBean as
push message object, then all entries/properties will transparently be
available as request parameters in the command script method
#\{bean.pushed}.

=== [[a6029]]Standard HTML RenderKit Tag Library

This tag library must be equivalent to the
one specified in link:JSF.html#a5363[See Standard HTML RenderKit
Tag Library].

The following additional renderers are added
to the ones defined in the other section.



=== Renderers Unique to Facelets

[width="100%",cols="34%,33%,33%",options="header",]
|===
|getComponentType()
|getRendererType()
|custom action name
|javax.faces.Command
|javax.faces.Script
|commandScript

|javax.faces.Script
|javax.faces.Websocket
|does not apply
|===

=== [[a6043]]Facelet Templating Tag Library

This tag library is the specified version of
the ui: tag library found in pre JSF 2.0 Facelets. The specification for
this library can be found in the VDLDocs for the _ui:_ library.

=== [[a6045]]Composite Component Tag Library

This tag library is used to declare composite
components. The specification for this tag library can be found in the
VDLDocs for the _composite:_ library.

=== [[a6047]]JSTL Core and Function Tag Libraries

Facelets exposes a subset of the JSTL Core
tag library and the entirety of the JSTL Function tag library. Please
see the VDLDocs for the JSTL Core and JSTL Functions tag libraries for
the normative specification.

=== 

image:SF-43.png[image]

Assertions relating to the construction of the view
hierarchy

[P1-start processListenerForAnnotation] When
the VDL calls for the creation of a _UIComponent_ instance, after
calling _Application.createComponent()_ to instantiate the component
instance, and after calling _setRendererType()_ on the newly
instantiated component instance, the following action must be taken.

Obtain the _Renderer_ for this component. If
no _Renderer_ is present, ignore the following steps.

Call _getClass()_ on the _Renderer_ instance
and inspect if the _ListenerFor_ annotation is present. If so, inspect
if the _Renderer_ instance implements _ComponentSystemEventListener_ .
If neither of these conditions are _true_ , ignore the following steps.

Obtain the value of the _systemEventClass()_
property of the _ListenerFor_ annotation on the _Renderer_ instance.

Call _subscribeToEvent()_ on the
_UIComponent_ instance from which the _Renderer_ instance was obtained,
using the _systemEventClass_ from the annotation as the second argument,
and the _Renderer_ instance as the third argument.

{empty}[P1-end]





=== 

image:SF-45.png[image]

[[a6060]]Using JSF in Web Applications

image:SF-46.png[image]

This specification provides JSF implementors
significant freedom to differentiate themselves through innovative
implementation techniques, as well as value-added features. However, to
ensure that web applications based on JSF can be executed unchanged
across different JSF implementations, the following additional
requirements, defining how a JSF-based web application is assembled and
configured, must be supported by all JSF implementations.

=== 

image:SF-47.png[image]

Web Application Deployment Descriptor

JSF-based applications are _web applications_
that conform to the requirements of the _Java Servlet Specification_
(version 2.3 or later), and also use the facilities defined in this
specification. Conforming web applications are packaged in a _web
application archive_ (WAR), with a well-defined internal directory
structure. A key element of a WAR is the _web application deployment
descriptor_ , an XML document that describes the configuration of the
resources in this web application. This document is included in the WAR
file itself, at resource path _/WEB-INF/web.xml_ .

Portable JSF-based web applications must
include the following configuration elements, in the appropriate
portions of the web application deployment descriptor. Element values
that are rendered in italics __ represent values that the application
developer is free to choose. Element values rendered in bold represent
values that must be utilized exactly as shown.

Executing the request processing lifecycle
via other mechanisms is also allowed (for example, an MVC-based
application framework can incorporate calling the correct phase
implementations in the correct order); however, all JSF implementations
must support the functionality described in this chapter to ensure
application portability.

=== [[a6066]]Servlet Definition

JSF implementations must provide request
processing lifecycle services through a standard servlet, defined by
this specification. [P1-start-servlet]This servlet must be defined, in
the deployment descriptor of an application that wishes to employ this
portable mechanism, as follows:

[width="100%",cols="100%",]
|===
a|
<servlet>

 <servlet-name> faces-servlet-name
</servlet-name>

 <servlet-class>

 _javax.faces.webapp.FacesServlet_

 </servlet-class>

</servlet>

|===

{empty}The servlet name, denoted as
_faces-servlet-name_ above, may be any desired value; however, the same
value must be used in the servlet mapping (see
link:JSF.html#a6076[See Servlet Mapping]).[P1-end]

In addition to _FacesServlet_ , JSF
implementations may support other ways to invoke the JavaServer Faces
request processing lifecycle, but applications that rely on these
mechanisms will not be portable.

=== [[a6076]]Servlet Mapping

All requests to a web application are mapped
to a particular servlet based on matching a URL pattern (as defined in
the _Java Servlet Specification_ ) against the portion of the request
URL after the context path that selected this web application.
[P1-start-mapping]JSF implementations must support web application that
define a _<servlet-mapping>_ that maps any valid _url-pattern_ to the
_FacesServlet_ . [P1-end]Prefix or extension mapping may be used. When
using prefix mapping, the following mapping is recommended, but not
required:

[width="100%",cols="100%",]
|===
a|
<servlet-mapping>

 <servlet-name> faces-servlet-name
</servlet-name>

 <url-pattern>/faces/*</url-pattern>

</servlet-mapping>

|===

When using extension mapping the following
mapping is recommended, but not required:

[width="100%",cols="100%",]
|===
a|
<servlet-mapping>

 <servlet-name> faces-servlet-name
</servlet-name>

 <url-pattern>*.faces</url-pattern>

</servlet-mapping>

|===

In addition to _FacesServlet_ , JSF
implementations may support other ways to invoke the JavaServer Faces
request processing lifecycle, but applications that rely on these
mechanisms will not be portable.

=== [[a6088]]Application Configuration Parameters

Servlet containers support application
configuration parameters that may be customized by including
_<context-param>_ elements in the web application deployment descriptor.
[P1-start-configParams]All JSF implementations are required to support
the following application configuration parameter names:


_javax.faces.ALWAYS_PERFORM_VALIDATION_WHEN_REQUIRED_IS_TRUE_ -- See the
javadocs for the constant
_javax.faces.component.UIInput.ALWAYS_PERFORM_VALIDATION_WHEN_REQUIRED_IS_TRUE_
for the specification of this feature.

 _javax.faces.CLIENT_WINDOW_MODE_ -- The
context-param that controls the operation of the _ClientWindow_ feature.
See the javadocs for the constant
_javax.faces.lifecycle.ClientWindow.CLIENT_WINDOW_MODE_PARAM_NAME_ for
the specification of this feature.

 _javax.faces.CONFIG_FILES_ --
Comma-delimited list of context-relative resource paths under which the
JSF implementation will look for application configuration resources
(see link:JSF.html#a6254[See Application Configuration Resource
Format]), before loading a configuration resource named “
_/WEB-INF/faces-config.xml_ ” (if such a resource exists). If “
_/WEB-INF/faces-config.xml_ ” is present in the list, it must be
ignored.


_javax.faces.DATETIMECONVERTER_DEFAULT_TIMEZONE_IS_SYSTEM_TIMEZONE_ --
If this param is set, and calling _toLowerCase().equals("true")_ on a
_String_ representation of its value returns _true_ ,
_Application.createConverter()_ must guarantee that the default for the
timezone of all _javax.faces.convert.DateTimeConverter_ instances must
be equal to _TimeZone.getDefault()_ instead of “GMT”.

 _javax.faces.DEFAULT_SUFFIX_ -- Allow the
web application to define an alternate suffix for JSP pages containing
JSF content. See the javadocs for the symbolic constant
_ViewHandler.DEFAULT_SUFFIX_PARAM_NAME_ for the complete specification.
__


_javax.faces.DISABLE_FACELET_JSF_VIEWHANDLER_ -- If this param is set,
and calling _toLowerCase().equals("true")_ on a _String_ representation
of its value returns _true_ , the default _ViewHandler_ must behave as
specified in the latest 1.2 version of this specification. Any behavior
specified in link:JSF.html#a4010[See Default
ViewDeclarationLanguage Implementation] and implemented in the default
_ViewHandler_ that pertains to handling requests for pages authored in
the JavaServer Faces View Declaration Language must not be executed by
the runtime. +
For backward compatibility with previous versions of Facelets, the value
_DISABLE_FACELET_JSF_VIEWHANDLER_ must be supported.

 _javax.faces.DISABLE_FACESSERVLET_TO_XHTML
--_ If this param is set, and calling _toLowerCase().equals("true")_ on
a _String_ representation of its value returns _true_ , the default
mapping of the _FacesServlet_ to _*.xhtml_ must not take effect.

 _javax.faces.FACELETS_LIBRARIES_ -- If this
param is set, the runtime must interpret it as a semicolon (;) separated
list of paths, starting with “/” (without the quotes). The runtime must
interpret each entry in the list as a path relative to the web
application root and interpret the file found at that path as a facelet
tag library, conforming to the facelet taglibrary schema and expose the
tags therein according to link:JSF.html#a5638[See Facelet Tag
Library mechanism]. The runtime must also consider the
_facelets.LIBRARIES_ param name as an alias to this param name for
backwards compatibility with existing facelets tag libraries.

 _javax.faces.FACELETS_BUFFER_SIZE_ -- The
buffer size to set on the response when the _ResponseWriter_ is
generated. By default the value is 1024. A value of -1 will not assign a
buffer size on the response. This should be increased if you are using
development mode in order to guarantee that the response isn't partially
rendered when an error is generated. The runtime must also consider the
_facelets.BUFFER_SIZE_ param name as an alias to this param name for
backwards compatibility with existing facelets tag libraries.

 _javax.faces.FACELETS_DECORATORS_ -- A
semicolon (;) delimitted list of class names of type
_javax.faces.view.facelets.TagDecorator_ , with a no-argument
constructor. These decorators will be loaded when the first request for
a Facelets VDL view hits the _ViewHandler_ for page compilation.The
runtime must also consider the _facelets.DECORATORS_ param name as an
alias to this param name for backwards compatibility with existing
facelets tag libraries.

 _javax.faces.FACELETS_REFRESH_PERIOD_ --
When a page is requested, what interval in seconds should the compiler
check for changes. If you don't want the compiler to check for changes
once the page is compiled, then use a value of -1. Setting a low refresh
period helps during development to be able to edit pages in a running
application.The runtime must also consider the _facelets.REFRESH_PERIOD_
param name as an alias to this param name for backwards compatibility
with existing facelets tag libraries.

 _javax.faces.FACELETS_RESOURCE_RESOLVER_ --
If this param is set, the runtime must interpret its value as a fully
qualified classname of a java class that extends
_javax.faces.view.facelets.ResourceResolver_ and has a zero argument
public constructor or a one argument public constructor where the type
of the argument is _ResourceResolver_ . If this param is set and its
value does not conform to those requirements, the runtime must log a
message and continue. If it does conform to these requirements and has a
one-argument constructor, the default _ResourceResolver_ must be passed
to the constructor. If it has a zero argument constructor it is invoked
directly. In either case, the new _ResourceResolver_ replaces the old
one. The runtime must also consider the _facelets.RESOURCE_RESOLVER_
param name as an alias to this param name for backwards compatibility
with existing facelets tag libraries.

Related to this param is the corresponding
annotation, _javax.faces.view.facelets.FaceletsResourceResolver_ . The
presence of this annotation must be ignored if the corresponding param
has been specified. If present, this annotation must be attached to a
class that extends _javax.faces.view.facelets.ResourceResolver_ . If
more than one class in the application has this annotation, an
informative error message with logging level SEVERE must be logged
indicating this case. Exactly one of the classes with the annotation
must be taken to be the _ResourceResolver_ for the application and any
other classes with the annotation must be ignored. See
link:JSF.html#a6435[See Ordering of Artifacts] for the means to
put application configuration resources in order such that the chosen
class can be defined. The same rules regarding decoration of the
instance as listed above must apply to the annotated class.

 _javax.faces.FACELETS_SKIP_COMMENTS_ -- If
this param is set, and calling _toLowerCase().equals("true")_ on a
_String_ representation of its value returns _true_ , the runtime must
ensure that any XML comments in the Facelets source page are not
delivered to the client. The runtime must also consider the
_facelets.SKIP_COMMENTS_ param name as an alias to this param name for
backwards compatibility with existing facelets tag libraries.

 _javax.faces.FACELETS_SUFFIX_ -- Allow the
web application to define an alternate suffix for Facelet based XHTML
pages containing JSF content. See the javadocs for the symbolic constant
_ViewHandler.FACELETS_SUFFIX_PARAM_NAME_ for the complete specification.

 _javax.faces.FACELETS_VIEW_MAPPINGS_ -- If
this param is set, the runtime must interpret it as a semicolon (;)
separated list of strings that is used to forcibly declare that certain
pages in the application must be interpreted as using Facelets,
regardless of their extension. The runtime must also consider the
_facelets.VIEW_MAPPINGS_ param name as an alias to this param name for
backwards compatibility with existing facelets applications. See the
javadocs for the symbolic constant
_ViewHandler.FACELETS_VIEW_MAPPINGS_PARAM_NAME_ for the complete
specification.

 _javax.faces.FULL_STATE_SAVING_VIEW_IDS_ --
The runtime must interpret the value of this parameter as a comma
separated list of view IDs, each of which must have their state saved
using the state saving mechanism specified in JSF 1.2.


_javax.faces.INTERPRET_EMPTY_STRING_SUBMITTED_VALUES_AS_NULL_ -- If this
param is set, and calling _toLowerCase().equals("true")_ on a _String_
representation of its value returns _true_ , any implementation of
_UIInput.validate()_ must take the following additional action.

If the
_javax.faces.INTERPRET_EMPTY_STRING_SUBMITTED_VALUES_AS_NULL_ context
parameter value is _true_ (ignoring case), and UIInput.
_getSubmittedValue()_ returns a zero-length _String_ call
_UIInput.setSubmittedValue(null)_ and continue processing using null as
the current submitted value

 _javax.faces.LIFECYCLE_ID_ -- Lifecycle
identifier of the _Lifecycle_ instance to be used when processing JSF
requests for this web application. If not specified, the JSF default
instance, identified by _LifecycleFactory.DEFAULT_LIFECYCLE_ , must be
used.

 _javax.faces.PARTIAL_STATE_SAVING_ --The
ServletContext init parameter consulted by the runtime to determine if
the partial state saving mechanism should be used. +
If undefined, the runtime must determine the version level of the
application.

For applications versioned at 1.2 and under,
the runtime must not use the partial state saving mechanism.

For applications versioned at 2.0 and above,
the runtime must use the partial state saving mechanism.

If this parameter is defined, and the
application is versioned at 1.2 and under, the runtime must not use the
partial state saving mechanism. Otherwise, If this param is defined, and
calling toLowerCase().equals("true") on a _String_ representation of its
value returns true, the runtime must use partial state mechanism.
Otherwise the partial state saving mechanism must not be used.

 _javax.faces.PROJECT_STAGE_ -- A human
readable string describing where this particular JSF application is in
the software development lifecycle. Valid values are “ _Development_ ”,
“ _UnitTest_ ”, “ _SystemTest_ ”, or “ _Production_ ”, corresponding to
the enum constants of the class _javax.faces.application.ProjectStage_ .
It is also possible to set this value via JNDI. See the javadocs for
_Application.getProjectStage()._

 _javax.faces.SEPARATOR_CHAR_ --The context
param that allows the character used to separate segments in a
_UIComponent_ clientId to be set on a per-application basis.

 _javax.faces.SERIALIZE_SERVER_STATE_ --If
this param is set, and calling _toLowerCase().equals("true")_ on a
_String_ representation of its value returns _true_ , and the
_javax.faces.STATE_SAVING_METHOD_ is set to “server” (as indicated
below), the server state must be guaranteed to be Serializable such that
the aggregate state implements _java.io.Serializable_ . The intent of
this parameter is to ensure that the act of writing out the state to an
_ObjectOutputStream_ would not throw a _NotSerializableException_ , but
the runtime is not required verify this before saving the state.

 _javax.faces.STATE_SAVING_METHOD_ -- The
location where state information is saved. Valid values are “server”
(typically saved in _HttpSession_ ) and “client (typically saved as a
hidden field in the subsequent form submit). If not specified, the
default value “server” must be used. When examining the parameter value,
the runtime must ignore case.

 _javax.faces.VALIDATE_EMPTY_FIELDS_ -- If
this param is set, and calling _toLowerCase().equals("true")_ on a
_String_ representation of its value returns _true_ , all submitted
fields will be validated. This is necessary to allow the model validator
to decide whether _null_ or empty values are allowable in the current
application. If the value is _false_ , _null_ or empty values will not
be passed to the validators. If the value is the string _“auto”_ , the
runtime must check if JSR-303 Beans Validation is present in the current
environment. If so, the runtime must proceed as if the value _“true”_
had been specified. If JSR-303 Beans Validation is not present in the
current environment, the runtime most proceed as if the value _“false”_
had been specified. If the param is not set, the system must behave as
if the param was set with the value _“auto”_ .


_javax.faces.validator.DISABLE_DEFAULT_BEAN_VALIDATOR_ -- If this param
is set, and calling _toLowerCase().equals("true")_ on a _String_
representation of its value returns _true_ , the runtime must not
automatically add the validator with validator-id equal to the value of
the symbolic constant _javax.faces.validator._ VALIDATOR_ID to the list
of default validators. Setting this parameter to _true_ will have the
effect of disabling the automatic installation of Bean Validation to
every input component in every view in the application, though manual
installation is still possible.


_javax.faces.validator.ENABLE_VALIDATE_WHOLE_BEAN_ -- If this param is
set, and calling _toLowerCase().equals("true")_ on a _String_
representation of its value returns _true_ , the _<f:validateWholeBean
/>_ __ tag is enabled. If not set or set to false, this tag is a no-op.


_javax.faces.VIEWROOT_PHASE_LISTENER_QUEUES_EXCEPTIONS_ -- If this param
is set, and calling _toLowerCase().equals("true")_ on a _String_
representation of its value returns _true_ , exceptions thrown by
_PhaseListeners_ installed on the _UIViewRoot_ are queued to the
_ExceptionHandler_ instead of being logged and swallowed. If this param
is not set or is set to false, the old behavior prevails.

 _javax.faces.ENABLE_WEBSOCKET_ENDPOINT_ --
Enable WebSocket support. See the javadoc for
_javax.faces.component.UIWebsocket_ .

 _javax.faces.WEBAPP_RESOURCES_DIRECTORY_

If this param is set, the runtime must
interpret its value as a path, relative to the web app root, where
resources are to be located. This param value must not start with a “/”,
though it may contain “/” characters. If no such param exists, or its
value is invalid, the value “resources”, without the quotes, must be
used by the runtime as the value.

 _javax.faces.WEBAPP_CONTRACTS_DIRECTORY_

If this param is set, the runtime must
interpret its value as a path, relative to the web app root, where
resource library contracts are to be located. This param value must not
start with a “/”, though it may contain “/” characters. If no such param
exists, or its value is invalid, the value “contracts”, without the
quotes, must be used by the runtime as the value.

{empty}[P1-end]

JSF implementations may choose to support
additional configuration parameters, as well as additional mechanisms to
customize the JSF implementation; however, applications that rely on
these facilities will not be portable to other JSF implementations.

=== 

image:SF-47.png[image]

Included Classes and Resources

A JSF-based application will rely on a
combination of APIs, and corresponding implementation classes and
resources, in addition to its own classes and resources. The web
application archive structure identifies two standard locations for
classes and resources that will be automatically made available when a
web application is deployed:

 _/WEB-INF/classes_ -- A directory containing
unpacked class and resource files.

 _/WEB-INF/lib_ -- A directory containing JAR
files that themselves contain class files and resources.

In addition, servlet and portlet containers
typically provide mechanisms to share classes and resources across one
or more web applications, without requiring them to be included inside
the web application itself.

The following sections describe how various
subsets of the required classes and resources should be packaged, and
how they should be made available.

=== Application-Specific Classes and Resources

Application-specific classes and resources
should be included in _/WEB-INF/classes_ or _/WEB-INF/lib_ , so that
they are automatically made available upon application deployment.

=== Servlet and JSP API Classes (javax.servlet.*)

These classes will typically be made
available to all web applications using the shared class facilities of
the servlet container. Therefore, these classes should not be included
inside the web application archive.

=== JSP Standard Tag Library (JSTL) API Classes (javax.servlet.jsp.jstl.*)

These classes will typically be made
available to all web applications using the shared class facilities of
the servlet container. Therefore, these classes should not be included
inside the web application archive.

=== JSP Standard Tag Library (JSTL) Implementation Classes

These classes will typically be made
available to all web applications using the shared class facilities of
the servlet container. Therefore, these classes should not be included
inside the web application archive.

=== JavaServer Faces API Classes (javax.faces.*)

These classes will typically be made
available to all web applications using the shared class facilities of
the servlet container. Therefore, these classes should not be included
inside the web application archive.

=== JavaServer Faces Implementation Classes

These classes will typically be made
available to all web applications using the shared class facilities of
the servlet container. Therefore, these classes should not be included
inside the web application archive.

=== [[a6147]]FactoryFinder

 _javax.faces.FactoryFinder_ implements the
standard discovery algorithm for all factory objects specified in the
JavaServer Faces APIs. For a given factory class name, a corresponding
implementation class is searched for based on the following algorithm.
Items are listed in order of decreasing search precedence:

If a default JavaServer Faces configuration
file (/WEB-INF/faces-config.xml) is bundled into the _web application,
and it_ contains a factory entry of the given factory class name, that
factory class is used.

If the JavaServer Faces configuration
resource(s) named by the _javax.faces.CONFIG_FILES_ _ServletContext_
init parameter (if any) contain any factory entries of the given factory
class name, those factories are used, with the last one taking
precedence.

If there are any META-INF/faces-config.xml
resources bundled any JAR files in the _web ServletContext’s resource
paths_ , the factory entries of the given factory class name in those
files are used, with the last one taking precedence.

If a
_META-INF/services/\{factory-class-name}_ resource is visible to the web
application class loader for the calling application (typically as a
result of being present in the manifest of a JAR file), its first line
is read and assumed to be the name of the factory implementation class
to use.

If none of the above steps yield a match, the
JavaServer Faces implementation specific class is used.

If any of the factories found on any of the
steps above happen to have a one-argument constructor, with argument the
type being the abstract factory class, that constructor is invoked, and
the previous match is passed to the constructor. For example, say the
container vendor provided an implementation of _FacesContextFactory_ ,
and identified it in
_META-INF/services/javax.faces.context.FacesContextFactory_ in a jar on
the webapp ClassLoader. Also say this implementation provided by the
container vendor had a one argument constructor that took a
_FacesContextFactory_ instance. The _FactoryFinder_ system would call
that one-argument constructor, passing the implementation of
_FacesContextFactory_ provided by the JavaServer Faces implementation.

If a Factory implementation does not provide
a proper one-argument constructor, it must provide a zero-arguments
constructor in order to be successfully instantiated.

Once the name of the factory implementation
class is located, the web application class loader for the calling
application is requested to load this class, and a corresponding
instance of the class will be created. A side effect of this rule is
that each web application will receive its own instance of each factory
class, whether the JavaServer Faces implementation is included within
the web application or is made visible through the container's
facilities for shared libraries.

[width="100%",cols="100%",]
|===
|public static Object getFactory(String
factoryName);
|===

Create (if necessary) and return a
per-web-application instance of the appropriate implementation class for
the specified JavaServer Faces factory class, based on the discovery
algorithm described above.

{empty}JSF implementations must also include
implementations of the several factory classes. In order to be
dynamically instantiated according to the algorithm defined above, the
factory implementation class must include a public, no-arguments
constructor. [P1-start-factoryNames]For each of the _public static final
String_ fields on the class _FactoryFinder_ whose field names end with
the string “ __FACTORY_ ” (without the quotes), the implementation must
provide an implementation of the corresponding Factory class using the
algorithm described earlier in this section.[P1-end]

=== [[a6160]]FacesServlet

 _FacesServlet_ is an implementation of
_javax.servlet.Servlet_ that accepts incoming requests and passes them
to the appropriate _Lifecycle_ implementation for processing. This
servlet must be declared in the web application deployment descriptor,
as described in link:JSF.html#a6066[See Servlet Definition], and
mapped to a standard URL pattern as described in
link:JSF.html#a6076[See Servlet Mapping].

[width="100%",cols="100%",]
|===
|public void init(ServletConfig config)
throws ServletException;
|===

Acquire and store references to the
_FacesContextFactory_ and _Lifecycle_ instances to be used in this web
application. For the _LifecycleInstance_ , first consult the
_init-param_ set for this _FacesServlet_ instance for a parameter of the
name _javax.faces.LIFECYCLE_ID_ . If present, use that as the
_lifecycleID_ attribute to the _getLifecycle()_ method of
_LifecycleFactory_ . If not present, consult the _context-param_ set for
this web application. If present, use that as the _lifecycleID_
attribute to the _getLifecycle()_ method of _LifecycleFactory_ . If
neither param set has a value for _javax.faces.LIFECYCLE_ID_ , use the
value _DEFAULT_ . As an implementation note, please take care to ensure
that all _PhaseListener_ instances defined for the application are
installed on all lifecycles created during this process.

[width="100%",cols="100%",]
|===
|public void destroy();
|===

Release the _FacesContextFactory_ and
_Lifecycle_ references that were acquired during execution of the
_init()_ method.

[width="100%",cols="100%",]
|===
|public void service(ServletRequest request,
ServletResponse response) throws IOException, ServletException;
|===

For each incoming request, the following
processing is performed:

Using the _FacesContextFactory_ instance
stored during the _init()_ method, call the _getFacesContext()_ method
to acquire a _FacesContext_ instance with which to process the current
request.

Call the _execute()_ method of the saved
_Lifecycle_ instance, passing the _FacesContext_ instance for this
request as a parameter. If the _execute()_ method throws a
_FacesException_ , re-throw it as a _ServletException_ with the
_FacesException_ as the root cause.

Call the _render()_ method of the saved
_Lifecycle_ instance, passing the _FacesContext_ instance for this
request as a parameter. If the _render()_ method throws a
_FacesException_ , re-throw it as a _ServletException_ with the
_FacesException_ as the root cause.

Call the _release_ () method on the
_FacesContext_ instance, allowing it to be returned to a pool if the JSF
implementation uses one.

[P1-start-servletParams]The FacesServlet
implementation class must also declare two static public final String
constants whose value is a context initialization parameter that affects
the behavior of the servlet:

 _CONFIG_FILES_ATTR_ -- the context
initialization attribute that may optionally contain a comma-delimited
list of context relative resources (in addition to
_/WEB-INF/faces-config.xml_ which is always processed if it is present)
to be processed. The value of this constant must be “
_javax.faces.CONFIG_FILES_ ”.

{empty} _LIFECYCLE_ID_ATTR_ -- the lifecycle
identifier of the _Lifecycle_ instance to be used for processing
requests to this application, if an instance other than the default is
required. The value of this constant must be “
_javax.faces.LIFECYCLE_ID_ ”.[P1-end]

=== [[a6175]]UIComponentELTag


_[P1-start-uicomponenteltag]UIComponentELTag_ is an implementation of
_javax.servlet.jsp.tagext.BodyTag_ , and must be the base class for any
JSP custom action that corresponds to a JSF _UIComponent_ .[P1-end] See
link:JSF.html#a4406[See Integration with JSP], and the Javadocs
for _UIComponentELTag_ , for more information about using this class as
the base class for your own _UIComponent_ custom action classes.

=== FacetTag

JSP custom action that adds a named facet
(see link:JSF.html#a968[See Facet Management]) to the
UIComponent associated with the closest parent UIComponent custom
action. See link:JSF.html#a4843[See <f:facet>].

=== ValidatorTag

JSP custom action (and convenience base
class) that creates and registers a _Validator_ instance on the
_UIComponent_ associated with the closest parent _UIComponent_ custom
action. See link:JSF.html#a5163[See <f:validateLength>],
link:JSF.html#a5198[See <f:validateRegex>],
link:JSF.html#a5223[See <f:validateLongRange>], and
link:JSF.html#a5256[See <f:validator>].

=== 

image:SF-47.png[image]

[[a6182]]Deprecated APIs in the webapp package

Faces depends on version JSP 2.1 or later,
and the JSP tags in Faces expose properties that leverage concepts
specific to that release of JSP. Importantly, most Faces JSP tag
attributes are either of type _javax.el.ValueExpression_ or
_javax.el.MethodExpression_ . For backwards compatability with existing
Faces component libraries that expose themselves as JSP tags, the
existing classes relating to JSP have been deprecated and new ones
introduced that leverage the EL API.

===  _AttributeTag_

{empty}[P1-start-attributetag]The faces
implementation must now provide this class.[P1-end]

===  _ConverterTag_

This has been replaced with _ConverterELTag_

===  _UIComponentBodyTag_

All component tags now implement _BodyTag_ by
virtue of the new class _UIComponentClassicTagBase_ implementing
_BodyTag_ . This class has been replaced by _UIComponentELTag_ .

===  _UIComponentTag_

This component has been replaced by
_UIComponentELTag_ .

===  _ValidatorTag_

This component has been replaced by
_ValidatorELTag_ .

=== 

image:SF-47.png[image]

[[a6195]]Application Configuration Resources

This section describes the JSF support for
portable application configuration resources used to configure
application components.

=== Overview

JSF defines a portable configuration resource
format (as an XML document) for standard configuration information.
Please see the Javadoc overview for a link, titled “faces-config XML
Schema Documentation” to the XML Schema Definition for such documents.

One or more such application resources will
be loaded automatically, at application startup time, by the JSF
implementation. The information parsed from such resources will augment
the information provided by the JSF implementation, as described below.

In addition to their use during the execution
of a JSF-based web application, configuration resources provide
information that is useful to development tools created by Tool
Providers. The mechanism by which configuration resources are made
available to such tools is outside the scope of this specification.

=== [[a6201]]Application Startup Behavior

Implementations may check for the presence of
a _servlet-class_ definition of class _javax.faces.webapp.FacesServlet_
in the web application deployment descriptor as a means to abort the
configuration process and reduce startup time for applications that do
not use JavaServer Faces Technology.

At application startup time, before any
requests are processed, the [P1-start-startup]JSF implementation must
process zero or more application configuration resources, located as
follows

Make a list of all of the application
configuration resources found using the following algorithm:

Check for the existence of a context
initialization parameter named _javax.faces.CONFIG_FILES_ . If it
exists, treat it as a comma-delimited list of context relative resource
paths (starting with a “/”), and add each of the specified resources to
the list. If this parameter exists, skip the searching specified in the
next bullet item in this list.

Search for all resources that match either “
_META-INF/faces-config.xml_ ” or end with “ _.faces-config.xml_ ”
directly in the “ _META-INF_ ” directory. Each resource that matches
that expression must be considered an application configuration
resource.

Using the _java.util.ServiceLoader_ , locate
all implementations of the
_javax.faces.ApplicationConfigurationResourceDocumentPopulator_ service.
For each implementation, create a fresh _org.w3c.dom.Document_ instance,
configured to be in the XML namespace of the application configuration
resource format, and invoke the implementation’s
_populateApplicationConfigurationResource()_ method. If no exception is
thrown, add the document to the list, otherwise log a message and
continue.

{empty}Let this list be known as
_applicationConfigurationResources_ for discussion. Also, check for the
existence of a web application configuration resource named “
_/WEB-INF/faces-config.xml_ ”, and refer to this as
_applicationFacesConfig_ for discussion, but do not put it in the list.
When parsing the application configuration resources, the implementation
must ensure that _applicationConfigurationResources_ are parsed before
_applicationFacesConfig_ .[P1-end]

Please see link:JSF.html#a6435[See
Ordering of Artifacts] for details on the ordering in which the
decoratable artifacts in the application configuration resources in
_applicationConfigurationResources_ and _applicationFacesConfig_ must be
processed.

This algorithm provides considerable
flexibility for developers that are assembling the components of a
JSF-based web application. For example, an application might include one
or more custom _UIComponent_ implementations, along with associated
_Renderer_ s, so it can declare them in an application resource named “
_/WEB-INF/faces-config.xml_ ” with no need to programmatically register
them with _Application_ instance. In addition, the application might
choose to include a component library (packaged as a JAR file) that
includes a “ _META-INF/faces-config.xml_ ” resource. The existence of
this resource causes components, renderers, and other JSF implementation
classes that are stored in this library JAR file to be automatically
registered, with no action required by the application.

Perform the actions specified in
link:JSF.html#a6228[See Faces Flows].

Perform the actions specified in
link:JSF.html#a6215[See Resource Library Contracts].

{empty}[P1-start-PostConstructApplicationEvent]The
runtime must publish the
_javax.faces.event.PostConstructApplicationEvent_ immediately after all
application configuration resources have been processed.[P1-end]

[P1-start-startupErrors]XML parsing errors
detected during the loading of an application resource file are fatal to
application startup, and must cause the application to not be made
available by the container. JSF implementations that are part of a Java
EE technology-compliant implementation are required to validate the
application resource file against the XML schema for structural
correctness. [P1-end]The validation is recommended, but not required for
JSF implementations that are not part of a Java EE technology-compliant
implementation.

=== [[a6215]]Resource Library Contracts

[P1-start-ResourceLibraryContractScanning]If
the parsing of the application configuration resources completed
successfully, scan the application for resource library contracts. Any
resource library contract as described in
link:JSF.html#a872[See Resource Library Contracts] must be
discovered at application startup time. The complete set of discovered
contracts has no ordering semantics and effectively is represented as a
_Set<String>_ where the values are just the names of the resource
libraries. If multiple sources in the application configuration
resources contained _<resource-library-contracts>_ , they are all merged
into one element. Duplicates are resolved in as specified in
link:JSF.html#a6435[See Ordering of Artifacts]. If the
application configuration resources produced a
_<resource-library-contracts>_ element, create an implementation private
data structure (called the “resource library contracts data structure”)
containing the mappings between viewId patterns and resource library
contracts as listed by the contents of that element.

The _<resource-library-contracts>_ element is
contained with in the _<application>_ element and contains one or more
_<contract-mapping>_ elements. Each _<contract-mapping>_ element must
one or more _<url-pattern>_ elements and one or more _<contract>_
elements.

The value of the _<url-pattern>_ element may
be any of the following.

The literal string *, meaning all views
should have these contracts applied.

An absolute prefix mapping, relative to the
web app root, such as _/directoryName/*_ meaning only views matching
that prefix should have these contracts applied.

An exact fully qualified file path, relative
to the web app root, such as _/directoryName/fileName.xhtml_ , meaning
exactly that view should have the contracts applied.

See link:JSF.html#a4030[See
ViewDeclarationLanguage.calculateResourceLibraryContracts()] for the
specification of how the values of the _<url-pattern>_ are to be
processed.

The value of the _<contracts>_ element is a
comma separated list of resource library contract names. A resource
library contract name is the name of a directory within the _contracts_
directory of the web app root, or the _contracts_ directory within the
_META-INF/contracts_ JAR entry.

Only the contracts explicitly mentioned in
the _<resource-library-contracts>_ element are included in the data
structure. If the information from the application configuration
resources refers to a contract that is not available to the application,
an informative error message must be logged.

If the application configuration resources
did not produce a _<resource-library-contracts>_ element, the data
structure should be populated as if this were the contents of the
_<resource-library-contracts>_ element:

[width="100%",cols="100%",]
|===
|<resource-library-contracts> +
<contract-mapping> +
<url-pattern>*</url-pattern> +
<contracts>”all available contracts”</contracts> +
</contract-mapping> +
</resource-library-contracts>
|===

Where “all available contracts” is replaced
with a comma separated list of all the contracts discovered in the
startup scan. In the case where there is no
_<resource-library-contracts>_ element in the application configuration
resources, ordering of contracts is unspecified, which may lead to
unexpected behavior in the case of multiple contracts that have the same
contract declaration.

=== [[a6228]]Faces Flows

[P1-start-FacesFlowScanning]If the parsing of
the application configuration resources completed successfully, any XML
based flow definitions in the application configuration resources will
have been successfully discovered as well. The discovered flows must be
exposed as thread safe immutable application scoped instances of
_javax.faces.flow.Flow_ , and made accessible to the runtime via the
_FlowHandler_ . If flows exist in the application, but the
_javax.faces.CLIENT_WINDOW_MODE_ context-param was not specified, the
runtime must behave as if the value “url” (without the quotes) was
specified for this context-param.

=== Defining Flows

Flows are defined using the
_<flow-definition>_ element. This element must have an _id_ attribute
which uniquely identifies the flow within the scope of the Application
Configuration Resource file in which the element appears. To enable
multiple flows with the same _id_ to exist in an application, the
_<faces-config><name>_ element is taken to be the _definingDocumentId_
of the flow. If no _<name>_ element is specified, the empty string is
taken as the value for _definingDocumentId_ . Please see
link:JSF.html#a3840[See FlowHandler] for an overview of the flow
feature. Note that a number of conventions exist to make defining flows
simpler. These conventions are specified in
link:JSF.html#a6236[See Packaging Flows in Directories].

{empty}[P1-end]

=== Packaging Faces Flows in JAR Files

[P1-start-FacesFlowJarPackaging] The runtime
must support packaging Faces Flows in JAR files as specified in this
section. Any flows packaged in a jar file must have its flow definition
included in a _faces-config.xml_ file located at the
_META-INF/faces-config.xml_ JAR entry. This ensures that such flow
definitions are included in the application configuration resources. Any
view nodes included in the jar must be located within sub entries of the
_META-INF/flows/<flowName>_ JAR entry, where _<flowName>_ is a JAR
directory entry whose name is identical to that of a flow id in the
corresponding _faces-config.xml_ file. If there are _@FlowScoped_ beans
or beans with _@FlowDefinition_ in the JAR, there must be a JAR entry
named _META-INF/beans.xml_ . This ensures that such beans and
definitions are discovered by the runtime at startup. None of the flow
definition conventions specified in link:JSF.html#a6236[See
Packaging Flows in Directories] apply when a flow is packaged in a JAR
file. In other words, the flow must be explicitly declared in the JAR
file’s _faces-config.xml_ .

{empty}[P1-end]

=== [[a6236]]Packaging Flows in Directories

The view nodes of a flow need not be
collected in any specific directory structure, but there is a benefit in
doing so: flow definition conventions.
[P1-start-FacesFlowDirectoryPackaging] If the _javax.faces.CONFIG_FILES_
context parameter includes references to files of the form
_/<flowName>/<flowName>-flow.xml_ or
_/WEB-INF/<flow-Name>/<flowName>-flow.xml_ , and if such files exist in
the current application (even if they are zero length), they are treated
as flow definitions. Flow definitions defined in this way must not be
nested any deeper in the directory structure than one level deep from
the web app root or the _WEB-INF_ directory.

The following conventions apply to flows
defined in this manner. Any flow definition in the corresponding
_-flow.xml_ file will override any of the conventions in the case of a
conflict.

Every vdl file in that directory is a view
node of that flow.

The start node of the flow is the view whose
name is the same as the name of the flow.

Navigation among any of the views in the
directory is considered to be within the flow.

The flow defining document id is the empty
string.

In the case of a zero length flow definition
file, the following also applies:

There is one return node in the flow, whose
id is the id of the flow with the string “ _-return_ ” (without the
quotes) appended to it. For example, if _flowId_ is _shopping_ , the
return node id is _shopping-return_ .

The from-outcome of the return node is a
string created with the following formula: +
_"/" + flowId + "-return"_ .

For each directory packaged flow definition,
the runtime must synthesize an instance of _javax.faces.flow.Flow_ that
represents the union of the flow definition from the
_/<flowName>/<flowName>-flow.xml_ file for that directory, and any of
the preceding naming conventions, with precedence being given to the
_-flow.xml_ file. Such _Flow_ instances must be added to the
_FlowHandler_ before the _PostConstructApplicationEvent_ is published.

{empty}[P1-end]

=== [[a6248]]Application Shutdown Behavior

{empty}When the JSF runtime is directed to
shutdown by its container, the following actions must be taken.
[p1-start-application-shutdown]

Ensure that calls to
_FacesContext.getCurrentInstance()_ that happen during application
shutdown return successfully, as specified in the Javadocs for that
method.

Publish the
_javax.faces.event.PreDestroyApplicationEvent_ .

Call _FactoryFinder.releaseFactories()_ .

{empty}[p1-end]

=== [[a6254]]Application Configuration Resource Format

{empty}Application configuration resources
that are written to run on JSF 2.3 must include the following schema
declaration and must conform to the schema shown in
link:JSF.html#a7037[See Appendix A - JSF Metadata]

[width="100%",cols="100%",]
|===
a|
<faces-config

 xmlns="http://xmlns.jcp.org/xml/ns/javaee"


xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"


xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee
http://xmlns.jcp.org/xml/ns/javaee/web-facesconfig_2_3.xsd"

 version="2.3">



|===

[P1-start-schema]Application configuration
resources that are written to run on JSF 2.2 must include the following
schema declaration and must conform to the schema shown in
link:JSF.html#a7037[See Appendix A - JSF Metadata]:

[width="100%",cols="100%",]
|===
a|
<faces-config

 xmlns="http://xmlns.jcp.org/xml/ns/javaee"


xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"


xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee
http://xmlns.jcp.org/xml/ns/javaee/web-facesconfig_2_2.xsd"

 version="2.2">



|===

Note that the “hostname” of the _xmlns_ and
_xsi:schemaLocation_ attributes has changed from “java.sun.com” to
“xmlns.jcp.org”. The “xmlns.jcp.org” hostname must be used when using
_version=_ "2.2" and _web-facesconfig_2_2.xsd_ . It is not valid to use
this hostname with versions prior to 2.2. Likewise, it is not valid to
use the “java.sun.com” hostname when using _version=_ "2.2" and
_web-facesconfig_2_2.xsd_ .

Application configuration resources that are
written to run on JSF 2.1 must include the following schema declaration:

[width="100%",cols="100%",]
|===
a|
<faces-config

 xmlns="http://java.sun.com/xml/ns/javaee"


xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"


xsi:schemaLocation="http://java.sun.com/xml/ns/javaee
http://java.sun.com/xml/ns/javaee/web-facesconfig_2_1.xsd"

 version="2.1">



|===

Application configuration resources that are
written to run on JSF 2.0 must include the following schema declaration:

[width="100%",cols="100%",]
|===
a|
<faces-config

 xmlns="http://java.sun.com/xml/ns/javaee"


xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"


xsi:schemaLocation="http://java.sun.com/xml/ns/javaee
http://java.sun.com/xml/ns/javaee/web-facesconfig_2_0.xsd"

 version="2.0">



|===

Application configuration resources that are
written to run on JSF 1.2 Application configuration resources must
include the following schema declaration and must conform to the schema
referenced in the schemalocation URI shown below:

[width="100%",cols="100%",]
|===
a|
<faces-config version="1.2"
xmlns="http://java.sun.com/xml/ns/javaee"


xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"


xsi:schemaLocation="http://java.sun.com/xml/ns/javaee


http://java.sun.com/xml/ns/javaee/web-facesconfig_1_2.xsd">

|===

Application configuration resources that are
written to run on JSF 1.1 implementations must use the DTD declaration
and include the following DOCTYPE declaration:

[width="100%",cols="100%",]
|===
a|
<!DOCTYPE faces-config PUBLIC

 “-//Sun Microsystems, Inc.//DTD JavaServer
Faces Config 1.1//EN”


“http://java.sun.com/dtd/web-facesconfig_1_1.dtd”>

|===

{empty}Application configuration resources
that are written to run on JSF 1.0 implementations must use the DTD
declaration for the 1.0 DTD contained in the binary download of the JSF
reference implementation. They must also use the following DOCTYPE
declaration:[P1-end]

[width="100%",cols="100%",]
|===
a|
<!DOCTYPE faces-config PUBLIC

 “-//Sun Microsystems, Inc.//DTD JavaServer
Faces Config 1.0//EN”


“http://java.sun.com/dtd/web-facesconfig_1_0.dtd”>

|===

=== [[a6297]]Configuration Impact on JSF Runtime

[width="100%",cols="100%",]
|===
a|
<!DOCTYPE faces-config PUBLIC

 “-//Sun Microsystems, Inc.//DTD JavaServer
Faces Config 1.1//EN”


“http://java.sun.com/dtd/web-facesconfig_1_1.dtd”>

|===

The following XML
elementslink:#a9102[19] in application configuration resources
cause registration of JSF objects into the corresponding factories or
properties. It is an error if the value of any of these elements cannot
be correctly parsed, loaded, set, or otherwise used by the
implementation.

/faces-config/component -- Create or replace
a component type / component class pair with the _Application_ instance
for this web application.

/faces-config/converter -- Create or replace
a converter id / converter class or target class / converter class pair
with the _Application_ instance for this web application.

/faces-config/render-kit -- Create and
register a new _RenderKit_ instance with the _RenderKitFactory_ , if one
does not already exist for the specified _render-kit-id_ .

/faces-config/render-kit/renderer -- Create
or replace a component family + renderer id / renderer class pair with
the _RenderKit_ associated with the render-kit element we are nested in.

/faces-config/validator -- Create or replace
a validator id / validator class pair with the _Application_ instance
for this web application.

For components, converters, and validators,
it is legal to replace the implementation class that is provided (by the
JSF implementation) by default. This is accomplished by specifying the
standard value for the _<component-type>_ , _<converter-id>_ , or
_<validator-id>_ that you wish to replace, and specifying your
implementation class. To avoid class cast exceptions, the replacement
implementation class must be a subclass of the standard class being
replaced. For example, if you declare a custom _Converter_
implementation class for the standard converter identifier
_javax.faces.Integer_ , then your replacement class must be a subclass
of _javax.faces.convert.IntegerConverter_ .

For replacement _Renderer_ s, your
implementation class must extend _javax.faces.render.Renderer_ .
However, to avoid unexpected behavior, your implementation should
recognize all of the render-dependent attributes supported by the
Renderer class you are replacing, and provide equivalent decode and
encode behavior.

The following XML elements cause the
replacement of the default implementation class for the corresponding
functionality, provided by the JSF implementation. See
link:JSF.html#a6336[See Delegating Implementation Support] for
more information about the classes referenced by these elements:

/faces-config/application/action-listener --
Replace the default _ActionListener_ used to process _ActionEvent events
with an_ instance with the class specified. The contents of this element
must be a fully qualified Java class name that, when instantiated, is an
_ActionListener_ .

/faces-config/application/navigation-handler
-- Replace the default _NavigationHandler_ instance with the one
specified. The contents of this element must be a fully qualified Java
class name that, when instantiated, is a _NavigationHandler_ .

/faces-config/application/property-resolver
-- Replace the default _PropertyResolver_ instance with the one
specified. The contents of this element must be a fully qualified Java
class name that, when instantiated, is a _PropertyResolver_ .

/faces-config/application/resource-handler --
Replace the default _ResourceHandler_ instance with the one specified.
The contents of this element must be a fully qualified Java class name
that, when instantiated, is a _ResourceHandler_ .

/faces-config/application/search-expression-handler
-- This element contains the fully qualified class name of the concrete
_javax.faces.component.search.SearchExpressionHandler_ implementation
class that will be used for processing of a search expression.

/faces-config/application/search-keyword-resolver
-- This element contains the fully qualified class name of the concrete
javax.faces.component.search.SearchKeywordResolver implementation class
that will be used during the processing of a search expression keyword.

/faces-config/application/state-manager --
Replace the default _StateManager_ instance with the one specified. The
contents of this element must be a fully qualified Java class name that,
when instantiated, is a _StateManager_ .

/faces-config/application/system-event-listener
-- Instantiate a new instance of the class specified as the content
within a nested _system-event-listener-class_ element, which must
implement _SystemEventListener_ . This instance is referred to as
_systemEventListener_ for discussion. If a _system-event-class_ is
specified as a nested element within _system-event-listener_ , it must
be a class that extends _SystemEvent_ and has a public zero-arguments
constructor. The _Class_ object for _system-event-class_ is obtained and
is referred to as _systemEventClass_ for discussion. If
_system-event-class_ is not specified, _SystemEvent.class_ must be used
as the value of system _EventClass_ . If _source-class_ is specified as
a nested element within _system-event-listener_ , it must be a fully
qualified class name. The _Class_ object for _source-class_ is obtained
and is referred to as _sourceClass_ for discussion. If _source-class_ is
not specified, let _sourceClass_ be _null_ . Obtain a reference to the
_Application_ instance and call _subscribeForEvent(_ _facesEventClass_
_,_ _sourceClass_ _,_ _systemEventListener_ _)_ , passing the arguments
as assigned in the discussion.

/faces-config/application/variable-resolver
-- Replace the default _VariableResolver_ instance with the one
specified. The contents of this element must be a fully qualified Java
class name that, when instantiated, is a _VariableResolver_ .

/faces-config/application/view-handler --
Replace the default _ViewHandler_ instance with the one specified. The
contents of this element must be a fully qualified Java class name that,
when instantiated, is a _ViewHandler_ .

The following XML elements cause the
replacement of the default implementation class for the corresponding
functionality, provided by the JSF implementation. Each of the
referenced classes must have a public zero-arguments constructor:

 _/faces-config/factory/application-factory_
-- Replace the default _ApplicationFactory_ instance with the one
specified. The contents of this element must be a fully qualified Java
class name that, when instantiated, is an _ApplicationFactory_ .


_/faces-config/factory/client-window-factory_ -- Replace the default
_ClientWindowFactory_ instance with the one specified. The contents of
this element must be a fully qualified Java class name that, when
instantiated, is a _ClientWindowFactory_ .


_/faces-config/factory/exception-handler-factory_ -- Replace the default
_ExceptionHandlerFactory_ instance with the one specified. The contents
of this element must be a fully qualified Java class name that, when
instantiated, is a _ExceptionHandlerFactory_ .


_/faces-config/factory/faces-context-factory_ -- Replace the default
_FacesContextFactory_ instance with the one specified. The contents of
this element must be a fully qualified Java class name that, when
instantiated, is a _FacesContextFactory_ .

 _/faces-config/factory/flash-factory_ --
Replace the default _FlashFactory_ instance with the one specified. The
contents of this element must be a fully qualified Java class name that,
when instantiated, is a _FlashFactory_ .

 _/faces-config/factory/flow-handler-factory_
-- Replace the default _FlowHandlerFactory_ instance with the one
specified. The contents of this element must be a fully qualified Java
class name that, when instantiated, is a _FlowHandlerFactory_ .

 _/faces-config/factory/lifecycle-factory_ --
Replace the default _LifecycleFactory_ instance with the one specified.
The contents of this element must be a fully qualified Java class name
that, when instantiated, is a _LifecycleFactory_ .

 _/faces-config/factory/render-kit-factory_
-- Replace the default _RenderKitFactory_ instance with the one
specified. The contents of this element must be a fully qualified Java
class name that, when instantiated, is a _RenderKitFactory_ .


_/faces-config/factory/search-expression-context-kit-factory_ -- This
element contains the fully qualified class name of the concrete
_SearchExpressionContextFactory_ implementation class that will be
called when
_FactoryFinder.getFactory(SEARCH_EXPRESSION_CONTEXT_FACTORY)_ is called.


_/faces-config/factory/view-declaration-language-factory_ -- Replace the
default _ViewDeclarationLanguageFactory_ instance with the one
specified. The contents of this element must be a fully qualified Java
class name that, when instantiated, is a
_ViewDeclarationLanguageFactory_ .

The following XML elements cause the addition
of event listeners to standard JSF implementation objects, as follows.
Each of the referenced classes must have a public zero-arguments
constructor.

/faces-config/lifecycle/phase-listener --
Instantiate a new instance of the specified class, which must implement
_PhaseListener_ , and register it with the _Lifecycle_ instance for the
current web application.

In addition, the following XML elements
influence the runtime behavior of the JSF implementation, even though
they do not cause registration of objects that are visible to a
JSF-based application.

/faces-config/managed-bean -- Make the
characteristics of a managed bean with the specified _managed-bean-name_
available to the default _VariableResolver_ implementation.

/faces-config/navigation-rule -- Make the
characteristics of a navigation rule available to the default
_NavigationHandler_ implementation.

=== [[a6336]]Delegating Implementation Support

[P1-decoratable_artifacts]The runtime must
support the decorator design pattern as specified below for the
following artifacts.

 _ActionListener_

 _ApplicationFactory_

ExceptionHandlerFactory

 _FacesContextFactory_

FlashFactory

FlowHandlerFactory

 _LifecycleFactory_

 _NavigationHandler_

PartialViewContext

 _PropertyResolver_

 _RenderKit_

 _RenderKitFactory_

 _ResourceHandler_

ResourceResolver

 _StateManager_

TagHandlerDelegateFactory

 _VariableResolver_

 _ViewHandler_

ViewDeclarationLanguage

VisitContextFactory

[P1_end_decoratable_artifacts]For all of
these artifacts, the decorator design pattern is leveraged, so that if
one provides a constructor that takes a single argument of the
appropriate type, the custom implementation receives a reference to the
implementation that was previously fulfilling the role. In this way, the
custom implementation is able to override just a subset of the
functionality (or provide only some additional functionality) and
delegate the rest to the existing implementation.

The implementation must also support
decoration of a _RenderKit_ instance. At the point in time of when the
_<render-kit>_ element is processed in an application configuration
resources, if the current _RenderKitFactory_ already has a _RenderKit_
instance for the _<render-kit-id>_ within the _<render-kit>_ element,
and the Class whose fully qualified java class name is given as the
value of the _<render-kit-class>_ element within the _<render-kit>_
element has a constructor that takes an _RenderKit_ instance, the
existing _RenderKit_ for that _<render-kit-id>_ must be passed to that
constructor, and the RenderKit resulting from the executing of that
constructor must be passed to _RenderKitFactory.addRenderKit()_ .

For example, say you wanted to provide a
custom _ViewHandler_ that was the same as the default one, but provided
a different implementation of the _calculateLocale()_ method. Consider
this code excerpt from a custom _ViewHandler_ :

[width="100%",cols="100%",]
|===
a|
public class MyViewHandler extends
ViewHandler \{



 public MyViewHandler() \{ }



 public MyViewHandler(ViewHandler handler) \{

 super();

 oldViewHandler = handler;

 }



 private ViewHandler oldViewHandler = null;



 // Delegate the renderView() method to the
old handler

 public void renderView(FacesContext context,
UIViewRoot view)

 throws IOException, FacesException \{

 oldViewHandler.renderView(context, view);

 }



 // Delegate other methods in the same manner



 // Overridden version of calculateLocale()

 public Locale calculateLocale(FacesContext
context) \{

 Locale locale = ... // Custom calculation

 return locale;

 }



}

|===



The second constructor will get called as the
application is initially configured by the JSF implementation, and the
previously registered _ViewHandler_ will get passed to it.

In version 1.2, we added new wrapper classes
to make it easier to override a subset of the total methods of the class
and delegate the rest to the previous instance. We provide wrappers for
_javax.faces.application.ViewHandler_ ,
_javax.faces.application.StateManager_ , and
_javax.faces.context.ResponseWriter_ . For example, you could have a
_faces-config.xml_ file that contains the following:



[width="100%",cols="100%",]
|===
a|
 <application>


<view-handler>com.foo.NewViewHandler</view-handler>


<state-manager>com.foo.NewStateManager</state-manager>

 </application>



|===

Where your implementations for these classes
are simply:

[width="100%",cols="100%",]
|===
a|
package com.foo;



import javax.faces.application.ViewHandler;

import
javax.faces.application.ViewHandlerWrapper;



public class NewViewHandler extends
ViewHandlerWrapper \{



 private ViewHandler oldViewHandler = null;



 public NewViewHandler(ViewHandler
oldViewHandler) \{

 this.oldViewHandler = oldViewHandler;

 }



 public ViewHandler getWrapped() \{

 return oldViewHandler;

 }

}



package com.foo;



import javax.faces.application.StateManager;

import
javax.faces.application.StateManagerWrapper;



public class NewStateManager extends
StateManagerWrapper \{



 private StateManager oldStateManager = null;



 public NewStateManager(StateManager
oldStateManager) \{

 this.oldStateManager = oldStateManager;

 }



 public StateManager getWrapped() \{

 return oldStateManager;

 }

}





|===

This allows you to override as many or as few
methods as you’d like.

=== [[a6435]]Ordering of Artifacts

Because the specification allows the
application configuration resources to be composed of multiple files,
discovered and loaded from several different places in the application,
the question of ordering must be addressed. This section specifies how
application configuration resource authors may declare the ordering
requirements of their artifacts.

link:JSF.html#a6201[See Application
Startup Behavior] defines two concepts:
_applicationConfigurationResources_ and _applicationFacesConfig_ . The
former is an ordered list of all the application configuration resources
except the one at “ _WEB-INF/faces-config.xml_ ”, and the latter is a
list containing only the one at “ _WEB-INF/faces-config.xml_ ”.

An application configuration resource may
have a top level _<name>_ element of type _javaee:java-identifierType_ .
[P1-facesConfigIdStart]If a _<name>_ element is present, it must be
considered for the ordering of decoratable artifacts (unless the
_duplicate name exception_ applies, as described below).

Two cases must be considered to allow
application configuration resources to express their ordering
preferences.

Absolute ordering: an _<absolute-ordering>_
element in the _applicationFacesConfig_

In this case, ordering preferences that would
have been handled by case 2 below must be ignored.

Any _<name>_ element direct children of the
_<absolute-ordering>_ must be interpreted as indicating the absolute
ordering in which those named application configuration resources, which
may or may not be present in _applicationConfigurationResources,_ must
be processed.

The _<absolute-ordering>_ element may contain
zero or one _<others />_ elements. The required action for this element
is described below. If the _<absolute-ordering>_ element does not
contain an _<others />_ element, any application configuration resources
not specifically mentioned within _<name />_ elements must be ignored.

 _Duplicate name exception_ : if, when
traversing the children of _<absolute-ordering>_ _,_ multiple children
with the same _<name>_ element are encountered, only the first such
occurrence must be considered.

If an _<ordering>_ element appears in the
_applicationFacesConfig_ , an informative message must be logged and the
element must be ignored.

Relative ordering: an _<ordering>_ element
within a file in the _applicationConfigurationResources_

An entry in
_applicationConfigurationResources_ may have an _<ordering>_ element. If
so, this element must contain zero or one _<before>_ elements and zero
or one _<after>_ elements. The meaning of these elements is explained
below.

 _Duplicate name exception_ : if, when
traversing the constituent members of
_applicationConfigurationResources,_ multiple members with the same
_<name>_ element are encountered, the application must log an
informative error message including information to help fix the problem,
and must fail to deploy. For example, one way to fix this problem is for
the user to use absolute ordering, in which case relative ordering is
ignored.

If an _<absolute-ordering>_ element appears
in an entry in _applicationConfigurationResources_ , an informative
message must be logged and the element must be ignored.

Consider this abbreviated but illustrative
example. faces-configA, faces-configB and faces-configC are found in
_applicationConfigurationResources_ , while my-faces-config is the
_applicationFacesConfig_ . The principles that explain the ordering
result follow the example code.

faces-configA:.

[width="100%",cols="100%",]
|===
a|
<faces-config>

 <name>A</name>


<ordering><after><name>B</name></after></ordering>

 <application>


<view-handler>com.a.ViewHandlerImpl</view-handler>

 </application>

 <lifecycle>


<phase-listener>com.a.PhaseListenerImpl</phase-listener>

 </lifecycle>

</faces-config>

|===

faces-configB:.

[width="100%",cols="100%",]
|===
a|
<faces-config>

 <name>B</name>

 <application>


<view-handler>com.b.ViewHandlerImpl</view-handler>

 </application>

 <lifecycle>


<phase-listener>com.b.PhaseListenerImpl</phase-listener>

 </lifecycle>

</faces-config>

|===

faces-configC:.

[width="100%",cols="100%",]
|===
a|
<faces-config>

 <name>C</name>

 <ordering><before><others
/></before></ordering>

 <application>


<view-handler>com.c.ViewHandlerImpl</view-handler>

 </application>

 <lifecycle>


<phase-listener>com.c.PhaseListenerImpl</phase-listener>

 </lifecycle>

</faces-config>

|===

my-faces-config:.

[width="100%",cols="100%",]
|===
a|
<faces-config>

 <name>my</name>

 <application>


<view-handler>com.my.ViewHandlerImpl</view-handler>

 </application>

 <lifecycle>


<phase-listener>com.my.PhaseListenerImpl</phase-listener>

 </lifecycle>

</faces-config>

|===

In this example, the processing order for the
_applicationConfigurationResources_ and _applicationFacesConfig_ will
be.

[width="100%",cols="100%",]
|===
a|
 _Implementation Specific Config_

C

B

A

my

|===

{empty}The preceding example illustrates
some, but not all, of the following
principles.[P1-start-decoratableOrdering]

 _<before>_ means the document must be
ordered before the document with the name matching the name specified
within the nested _<name>_ element.

 _<after>_ means the document must be ordered
after the document with the name matching the name specified within the
nested _<name>_ element.

There is a special element _<others />_ which
may be included zero or one time within the _<before>_ or < _after>_
elements, or zero or one time directly within the _<absolute-ordering>_
elements. The _<others />_ element must be handled as follows.

The _<others />_ element represents a set of
application configuration resources. This set is described as the set of
all application configuration resources discovered in the application,
minus the one being currently processed, minus the application
configuration resources mentioned by name in the _<ordering/>_ section.
If this set is the empty set, at the time the application configuration
resources are being processed, the _<others />_ element must be ignored.
__

If the _<before>_ element contains a nested
_<others />_ , the document will be moved to the beginning of the list
of sorted documents. If there are multiple documents stating < _before>_
< _others_ />, they will all be at the beginning of the list of sorted
documents, but the ordering within the group of such documents is
unspecified.

If the _<after>_ element contains a nested
_<others />_ , the document will be moved to the end of the list of
sorted documents. If there are multiple documents requiring _<after>_ <
_others />_ , they will all be at the end of the list of sorted
documents, but the ordering within the group of such documents is
unspecified.

Within a _<before>_ or _<after>_ element, if
an _<others />_ element is present, but is not the only _<name>_ element
within its parent element, the other elements within that parent must be
considered in the ordering process.

If the _<others />_ element appears directly
within the _<absolute-ordering>_ element, the runtime must ensure that
any application configuration resources in
_applicationConfigurationResources_ not explicitly named in the
_<absolute-ordering>_ section are included at that point in the
processing order. __

If a faces-config file does not have an
_<ordering>_ or _<absolute-ordering>_ element the artifacts are assumed
to not have any ordering dependency.

If the runtime discovers circular references,
an informative message must be logged, and the application must fail to
deploy. Again, one course of action the user may take is to use absolute
ordering in the _applicationFacesConfig_ . __

The previous example can be extended to
illustrate the case when _applicationFacesConfig_ contains an ordering
section.

my-faces-config:.

[width="100%",cols="100%",]
|===
a|
<faces-config>

 <name>my</name>

 <absolute-ordering>

 <name>C</name>

 <name>A</name>

 </absolute-ordering>

 <application>


<view-handler>com.my.ViewHandlerImpl</view-handler>

 </application>

 <lifecycle>


<phase-listener>com.my.PhaseListenerImpl</phase-listener>

 </lifecycle>

</faces-config>

|===

In this example, the constructor decorator
ordering for _ViewHandler_ would be C, A, my.

Some additional example scenarios are
included below. All of these apply to the
_applicationConfigurationResources_ relative ordering case, not to the
_applicationFacesConfig_ absolute ordering case.

[width="100%",cols="100%",]
|===
a|
Document A -
<after><others/><name>C</name></after>

Document B - <before><others/></before>

Document C - <after><others/></after>

Document D - no ordering

Document E - no ordering

Document F -
<before><others/><name>B</name></before>

|===

The valid parse order is F, B, D/E, C, A,
where D/E may appear as D, E or E, D

[width="100%",cols="100%",]
|===
a|
Document <no id> - <after><others/></after>

 <before><name>C</name></before>

Document B - <before><others/></before>

Document C - no ordering

Document D - <after><others/></after>

Document E - <before><others/></before>

Document F - no ordering

|===

The complete list of parse order solutions
for the above example is

B,E,F,<no id>,C,D

B,E,F,<no_id>,D,C

E,B,F,<no id>,C,D

E,B,F,<no_id>,D,C

B,E,F,D,<no id>,C

E,B,F,D,<no id>,C

[width="100%",cols="100%",]
|===
a|
Document A - <after><name>B</name></after>

Document B - no ordering

Document C - <before><others/></before>

Doucment D - no ordering

|===

Resulting parse order: C, B, D, A. The parse
order could also be: C, D, B, A.

{empty}[P1-endDecoratableOrdering]

=== [[a6554]]Example Application Configuration Resource

The following example application resource
file defines a custom _UIComponent_ of type _Date_ , plus a number of
_Renderer_ s that know how to decode and encode such a component:

[width="100%",cols="100%",]
|===
a|
<?xml version=”1.0”?>

<faces-config version="1.2"
xmlns="http://java.sun.com/xml/ns/javaee"


xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"


xsi:schemaLocation="http://java.sun.com/xml/ns/javaee


http://java.sun.com/xml/ns/javaee/web-facesconfig_1_2.xsd">

<!-- Define our custom component -->

<component>

 <description>

 A custom component for rendering
user-selectable dates in various formats.

 </description>

 <display-name>My Custom Date</display-name>

 <component-type>Date</component-type>

 <component-class>

 com.example.components.DateComponent

 </component-class>

</component>



<!-- Define two renderers that know how to
deal with dates -->

<render-kit>

 <!-- No render-kit-id, so add them to
default RenderKit -->

 <renderer>

 <display-name>Calendar Widget</display-name>


<component-family>MyComponent</component-family>

 <renderer-type>MyCalendar</renderer-type>

 <renderer-class>

 com.example.renderers.MyCalendarRenderer

 </renderer-class>

 </renderer>

 <renderer>

 <display-name>Month/Day/Year</display-name>

 <renderer-type>MonthDayYear</renderer-type>

 <renderer-class>

 com.example.renderers.MonthDayYearRenderer

 </renderer-class>

 </renderer>

</render-kit>



</faces-config>

|===

Additional examples of configuration elements
that might be found in application configuration resources are in
link:JSF.html#a2477[See Managed Bean Configuration Example] and
link:JSF.html#a3646[See Example NavigationHandler
Configuration].

=== 

image:SF-47.png[image]

[[a6596]]Annotations that correspond to and may take the place
of entries in the Application Configuration Resources

An implementation must support several
annotation types that take may take the place of entries in the
Application Configuration Resources. The implementation requirements are
specified in this section.

=== [[a6598]]Requirements for scanning of classes for annotations

[P1_start-annotation-discovery]If the
_<faces-config>_ element in the _WEB-INF/faces-config.xml_ file contains
_metadata-complete_ attribute whose value is “ _true_ ”, the
implementation must not perform annotation scanning on any classes
except for those classes provided by the implementation itself.
Otherwise, continue as follows.

If the runtime discovers a conflict between
an entry in the Application Configuration Resources and an annotation,
the entry in the Application Configuration Resources takes precedence.

All classes in _WEB-INF/classes_ must be
scanned.

{empty}For every jar in the application's
_WEB-INF/lib_ directory, if the jar contains a “
_META-INF/faces-config.xml_ ” file or a file that matches the regular
expression “ _.*\.faces-config.xml_ ” (even an empty one), all classes
in that jar must be scanned.[P1_end-annotation-discovery]



=== 

image:SF-48.png[image]

Lifecycle Management

image:SF-49.png[image]

In link:JSF.html#a369[See Request
Processing Lifecycle],” the required functionality of each phase of the
request processing lifecycle was described. This chapter describes the
standard APIs used by JSF implementations to manage and execute the
lifecycle. Each of these classes and interfaces is part of the
_javax.faces.lifecycle_ package.

Page authors, component writers, and
application developers, in general, will not need to be aware of the
lifecycle management APIs—they are primarily of interest to tool
providers and JSF implementors.

=== 

image:SF-50.png[image]

[[a6608]]Lifecycle

Upon receipt of each JSF-destined request to
this web application, the JSF implementation must acquire a reference to
the _Lifecycle_ instance for this web application, and call its
_execute()_ and _render()_ methods to perform the request processing
lifecycle. The _Lifecycle_ instance invokes appropriate processing logic
to implement the required functionality for each phase of the request
processing lifecycle, as described in link:JSF.html#a401[See
Standard Request Processing Lifecycle Phases].

[width="100%",cols="100%",]
|===
a|
public void execute(FacesContext context)
throws FacesException;



public void render(FacesContext context)
throws FacesException;

|===

The _execute()_ method performs phases up to,
but not including, the _Render Response_ phase. The _render()_ method
performs the Render Response phase. This division of responsibility
makes it easy to support JavaServer Faces processing in a portlet-based
environment.

As each phase is processed, registered
_PhaseListener_ instances are also notified. The general processing for
each phase is as follows:

From the set of registered _PhaseListener_
instances, select the relevant ones for the current phase, where
“relevant” means that calling _getPhaseId()_ on the _PhaseListener_
instance returns the phase identifier of the current phase, or the
special value _PhaseId.ANY_PHASE_ .

Call the _beforePhase()_ method of each
relevant listener, in the order that the listeners were registered.

If no called listener called the
_FacesContext.renderResponse()_ or _FacesContext.responseComplete()_
method, execute the functionality required for the current phase.

Call the _afterPhase()_ method of each
relevant listener, in the reverse of the order that the listeners were
registered.

If the _FacesContext.responseComplete()_
method has been called during the processing of the current request, or
we have just completed the _Render Response_ phase, perform no further
phases of the request processing lifecycle.

If the _FacesContext.renderResponse()_ method
has been called during the processing of the current request, and we
have not yet executed the _Render Response_ phase of the request
processing lifecycle, ensure that the next executed phase will be
_Render Response_

[width="100%",cols="100%",]
|===
a|
public void addPhaseListener(PhaseListener
listener);



public void removePhaseListener(PhaseListener
listener);

|===

These methods register or deregister a
_PhaseListener_ that wishes to be notified before and after the
processing of each standard phase of the request processing lifecycle.
Implementations should prevent duplicate _PhaseListener_ registrations
and log an exception if an attempt is made. The webapp author can
declare a _PhaseListener_ to be added using the _phase-listener_ element
of the application configuration resources file. Please see
_link:JSF.html#a6635[See PhaseListener]_ .

=== 

image:SF-50.png[image]

[[a6626]]PhaseEvent

This class represents the beginning or ending
of processing for a particular phase of the request processing
lifecycle, for the request encapsulated by the _FacesContext_ instance
passed to our constructor.

[width="100%",cols="100%",]
|===
|public PhaseEvent(FacesContext context,
PhaseId phaseId, Lifecycle lifecycle);
|===

Construct a new _PhaseEvent_ representing the
execution of the specified phase of the request processing lifecycle, on
the request encapsulated by the specified _FacesContext_ instance. The
_Lifecycle_ instance must be the lifecycle used by the current
_FacesServlet_ that is processing the request. It will serve as the
_source_ of the _java.util.EventObject_ from which _PhaseEvent_
inherits.

[width="100%",cols="100%",]
|===
a|
public FacesContext getFacesContext();



public PhaseId getPhaseId();

|===

Return the properties of this event instance.
The specified _FacesContext_ instance will also be returned if
_getSource()_ (inherited from the base _EventObject_ class) is called.

=== 

image:SF-50.png[image]

[[a6635]]PhaseListener

This interface must be implemented by objects
that wish to be notified before and after the processing for a
particular phase of the request processing lifecycle, on a particular
request. Implementations of _PhaseListener_ must be programmed in a
thread-safe manner.

[width="100%",cols="100%",]
|===
|public PhaseId getPhaseId();
|===

The _PhaseListener_ instance indicates for
which phase of the request processing lifecycle this listener wishes to
be notified. If _PhaseId.ANY_PHASE_ is returned, this listener will be
notified for all standard phases of the request processing lifecycle.

[width="100%",cols="100%",]
|===
a|
public void beforePhase(PhaseEvent event);



public void afterPhase(PhaseEvent event);

|===

{empty}The beforePhase() method is called
before the standard processing for a particular phase is performed,
while the afterPhase() method is called after the standard processing
has been completed. The JSF implementation must guarantee that, if
_beforePhase()_ has been called on a particular instance, then
_afterPhase()_ will also be called, regardless of any Exceptions that
may have been thrown during the actual execution of the lifecycle phase.
For example, let’s say there are three PhaseListeners attached to the
lifecycle: _A, B_ , and _C_ , in that order. _A.beforePhase()_ is
called, and executes successfully. _B.beforePhase()_ is called and
throws an exception. [P1-start_publishExceptionBefore] Any exceptions
thrown during the _beforePhase()_ listeners must be caught and published
to the _ExceptionHandler_ , as described
below.[P1-end_publishExceptionBefore] In this example, _C.beforePhase()_
must not be called. Then the actual lifecycle phase executes. Any
exceptions thrown during the execution of the actual phase, that reach
the runtime code that implements the JSF lifecycle phase,
[P1-start_publishExceptionDuring] must be caught and and published to
the _ExceptionHandler_ , as described
below[P1-end_publishExceptionDuring]. When the lifecycle phase exits,
due to an exeception or normal termination, the _afterPhase()_ listeners
must be called in reverse order from the _beforePhase()_ listeners in
the following manner. _C.afterPhase()_ must not be called, since
_C.beforePhase()_ was not called. _B.afterPhase()_ must not be called,
since _B.beforePhase()_ did not execute successfully. _A.afterPhase()_
must be called. [P1-start_publishExceptionAfter]Any exceptions thrown
during the _afterPhase()_ liseteners must be caught and published to the
_ExceptionHandler_ , as described below.[P1-start_publishExceptionAfter]

The previous paragraph detailed several cases
where exceptions should be published to the _Exception_ handler.
[P1-start_publishExceptionSpec] The following action must be taken by
the runtime to implement this requirement as well as an additional
requirent to cause the _ExceptionHandler_ to take action on the
published _Exception_ (s). The specification is shown in pseudocode.
This code does not implement the before/after matching guarantees
specified above and is only intended to describe the specification for
publishing and handling _ExceptionQueuedEvent_ instances that arise from
exceptions being thrown during the execution of a lifecycle phase.
Methods shown in _thisTypeface()_ are not a part of the API and are just
included for discussion.

[width="100%",cols="100%",]
|===
a|
FacesContext facesContext =
FacesContext.getCurrentInstance();

Application app =
facesContext.getApplication();

ExceptionHandler handler =
facesContext.getExceptionHandler();



try \{

 _callBeforePhaseListeners_ ();

} catch (Throwable thrownException) \{

 javax.faces.event.ExceptionEventContext
eventContext =

 new ExceptionEventContext(thrownException,
null,

 facesContext.getPhaseId());


eventContext.getAttributes().put(EventContext.IN_BEFORE_PHASE,

 Boolean.TRUE);

 app.publishEvent(ExceptionQueuedEvent.class,
eventContext);

}



try \{

 _doCurrentPhase_ ();

} catch (Throwable thrownException) \{

 javax.faces.event.ExceptionEventContext
eventContext =

 new ExceptionEventContext(thrownException,
null,

 facesContext.getPhaseId());

 app.publishEvent(ExceptionQueuedEvent.class,
eventContext);

} finally \{

 try \{

 _callAfterPhaseListeners();_

 } catch (Throwable thrownException) \{

 javax.faces.event.ExceptionEventContext
eventContext =

 new ExceptionEventContext(thrownException,
null,

 facesContext.getPhaseId());


eventContext.getAttributes().put(EventContext.IN_AFTER_PHASE,

 Boolean.TRUE);

 app.publishEvent(ExceptionQueuedEvent.class,
eventContext);

 }

 handler.handle();

}

|
|===

body text.

{empty}[P1-end_publishExceptionSpec]

 _PhaseListener_ implementations may affect
the remainder of the request processing lifecycle in several ways,
including:

Calling _renderResponse()_ on the
_FacesContext_ instance for the current request, which will cause
control to transfer to the _Render Response_ phase of the request
processing lifecycle, once processing of the current phase is complete.

Calling responseComplete() on the
FacesContext instance for the current request, which causes processing
of the request processing lifecycle to terminate once the current phase
is complete.

=== 

image:SF-50.png[image]

LifecycleFactory

A single instance of
_javax.faces.lifecycle.LifecycleFactory_ must be made available to each
JSF-based web application running in a servlet or portlet container. The
factory instance can be acquired by JSF implementations or by
application code, by executing:

[width="100%",cols="100%",]
|===
a|
LifecycleFactory factory = (LifecycleFactory)


FactoryFinder.getFactory(FactoryFinder.LIFECYCLE_FACTORY);

|===

The _LifecycleFactory_ implementation class
supports the following methods:

[width="100%",cols="100%",]
|===
|public void addLifecycle(String lifecycleId,
Lifecycle lifecycle);
|===

Register a new _Lifecycle_ instance under the
specified lifecycle identifier, and make it available via calls to the
_getLifecycle_ method for the remainder of the current web application’s
lifetime.

[width="100%",cols="100%",]
|===
|public Lifecycle getLifecycle(String
lifecycleId);
|===

The _LifecycleFactory_ implementation class
provides this method to create (if necessary) and return a _Lifecycle_
instance. All requests for the same lifecycle identifier from within the
same web application will return the same _Lifecycle_ instance, which
must be programmed in a thread-safe manner.

Every JSF implementation must provide a
_Lifecycle_ instance for a default lifecycle identifier that is
designated by the _String_ constant _LifecycleFactory.DEFAULT_LIFECYCLE_
. For advanced uses, a JSF implementation may support additional
lifecycle instances, named with unique lifecycle identifiers.

[width="100%",cols="100%",]
|===
|public Iterator<String> getLifecycleIds();
|===

This method returns an iterator over the set
of lifecycle identifiers supported by this factory. This set must
include the value specified by _LifecycleFactory.DEFAULT_LIFECYCLE_ .

 

=== 

image:SF-51.png[image]

[[a6699]]Ajax Integration

image:SF-52.png[image]

This chapter of the specification describes
how Ajax integrates with the JavaServer Faces framework to create
dynamic web applications. JavaServer Faces 1.2 standardized portions of
the architecture to facilitate building Web 2.0 applications with Ajax.
This chapter describes the resources and JavaScript APIs that are used
to expose the Ajax capabilities of JavaServer Faces to page authors and
component authors. It also describes the necessary ingredients of a
JavaServer Faces Ajax framework, namely, a resource delivery mechanism,
partial tree traversal, partial page update.

=== 

image:SF-53.png[image]

[[a6702]]JavaScript
Resource

There must be a single JavaScript resource
that exists with the resource identifier given by the value of the
constant
_javax.faces.application.ResourceHandler.JSF_SCRIPT_RESOURCE_NAME_ and
it must exist under the resource library given by the value of the
constant
_javax.faces.application.ResourceHandler.JSF_SCRIPT_LIBRARY_NAME,_
following the conventions in _link:JSF.html#a746[See Resource
Handling]._ This resource contains the JavaScript APIs that facilitate
Ajax interaction with JavaServer Faces.

=== [[a6704]]JavaScript Resource Loading

The JavaScript resource can become available
to a JavaServer Faces application using a number of different
approaches.

=== [[a6706]]The Annotation Approach

Component authors can specify that a custom
component or renderer requires the Ajax resource with the use of the
ResourceDependency annotation.

[width="100%",cols="100%",]
|===
a|
@ResourceDependency (name="jsf.js",
library="javax.faces", target="head")

public class MyComponent extends UIOutput...

|===

For more information on this approach refer
to link:JSF.html#a847[See Relocatable
Resources] and
link:JSF.html#a869[See
Resource Rendering Using Annotations].

=== [[a6712]]The Resource API Approach

Component authors can also specify that a
custom component or renderer requires the JavaScript resource by using
the resource APIs. For example, a component or renderer’s encode method
may contain:

[width="100%",cols="100%",]
|===
a|
Resource resource =
context.getApplication().getResourceHandler()

 .createResource(“jsf.js”, “javax.faces”);

...

writer.startElement("script", component);

writer.writeAttribute("type",
"text/javascript", "type");

writer.writeAttribute("src",((resource !=
null)? resource.getRequestPath(): "RES_NOT_FOUND"),”src”);

writer.endElement(“script”);

|===

Script resources are relocatable resources
(see link:JSF.html#a847[See Relocatable
Resources]) which means you can control the rendering location for these
resources by setting the “target” attribute on the resource component:

[width="100%",cols="100%",]
|===
a|
public class MyComponent extends UIOutput \{

...

getAttributes().put(“target”, “head”);

...

}

|===

This attribute must be set before the
component is added to the view. The component or renderer must also
implement the event processing method:

[width="100%",cols="100%",]
|===
a|
public void processEvent(SystemEvent event)
throws AbortProcessingException \{

UIComponent component = (UIComponent)
event.getSource();

FacesContext context =
FacesContext.getCurrentInstance();

if (component.getAttributes().get("target")
!= null) \{

context.getViewRoot().addComponentResource(context,

component);

}

}



|===

When the component is added to the view, an
event will be published. This event handling method will add the
component resource to one of the resource location facets under the view
root so it will be in place before rendering.

=== [[a6738]]The Page D eclaration Language Approach

Page authors can make the Ajax resource
available to the current view using the outputScript tag. For example:

[width="100%",cols="100%",]
|===
a|
<f:view contentType=”text/html”/>

<h:head>

<meta...

<title...

</h:head>

<h:body>

...

<h:outputScript name=”jsf.js”
library=”javax.faces”

target=”body”/>

...

</h:body>

...



|===

=== 

image:SF-53.png[image]

[[a6754]]JavaScript Namespacing

JavaScript objects that are not enclosed
within a namespace are global, which means they run the risk of
interfering, overriding and/or clobbering previously defined JavaScript
objects. This section defines the requirements for implementations
intending to use the JavaServer Faces 2.0 JavaScript API.

[P1-start javascript namespace]Any
implementation that intends to use the JavaServer Faces 2.0 JavaScript
API must define a top level JavaScript object name jsf, whose type is a
JavaScript associative array. Within that top level JavaScript object,
there must be a property named ajax..

[width="100%",cols="100%",]
|===
a|
if (jsf == null || typeof jsf == "undefined")
\{

 var jsf = new Object();

}

if (jsf.ajax == null || typeof jsf.ajax ==
"undefined") \{

 jsf["ajax"] = new Object();

}



|===

{empty}[P1-end]

=== 

image:SF-53.png[image]

[[a6766]]Ajax Interaction

This section of the specification outlines
the Ajax JavaScript APIs that are used to initiate client side
interactions with the JavaServer Faces framework including partial tree
traversal and partial page update. All of the functions in this
JavaScript API will be exposed on a page scoped JavaScript object. Refer
to link:JSF.html#a6841[See JavaScript API]for details
about the individual API
functions.

=== [[a6769]]Sending an Ajax Request

The JavaScript function jsf.ajax.request is
used to send information to the server to control partial view
processing (link:JSF.html#a6831[See Partial
View Processing]) and partial view rendering
(link:JSF.html#a6833[See Partial View
Rendering]). All requests using the jsf.ajax.request function will be
made asynchronously to the server. Refer to
link:JSF.html#a6856[See Initiating an
Ajax Request].

=== [[a6771]]Ajax Request Queueing

{empty}[P1-start-ajaxrequest-queue] All Ajax
requests must be put into a client side request queue before they are
sent to the server to ensure Ajax requests are processed in the order
they are sent. The request that has been waiting in the queue the
longest is the next request to be sent. After a request is sent, the
Ajax request callback function must remove the request from the queue
(also known as dequeuing). If the request completed successfully, it
must be removed from the queue. If there was an error, the client must
be notified, but the request must still be removed from the queue so the
next request can be sent. The next request (the oldest request in the
queue) must be sent. Refer to the jsf.ajax.request JavaScript
documentation for more specifics about the Ajax request queue.[P1-end]

=== [[a6773]]Request Callback Function

The Ajax request callback function is called
when the Ajax request/response interaction is complete.
[P1-start-callback]This function must perform the following actions:

If the return status is >= 200 and < 300,
send a “complete” event following
link:JSF.html#a6792[See Sending Events]. Call
jsf.ajax.response passing the Ajax request object (for example the
XMLHttpRequest instance) and the request context (containing the source
DOM element, onevent event function callback and onerror error function
callback).

If the return status is outside the range
mentioned above, send a “complete” event following
link:JSF.html#a6792[See Sending Events]. Send an
“httpError” error following link:JSF.html#a6806[See
Signaling Errors].

Regardless of whether the request completed
successfully or not:

remove the completed requests (Ajax
readystate 4) from the request queue (dequeue) - specifically the
requests that have been on the queue the longest.

{empty}find the next oldest unprocessed (Ajax
readystate 0) request on the queue, and send it. The implementation must
ensure that the request that is sent does not enter the queue
again.[P1-end]

Refer to
link:JSF.html#a6781[See Receiving
The Ajax Response]. Also refer to the jsf.ajax.request JavaScript
documentation for more specifics about the request callback function.

=== [[a6781]]Receiving The Ajax Response

{empty}The jsf.ajax.response function is
responsible for examining the markup that is returned from the server
and updating the client side DOM. The Ajax request callback function
should call this function when a request completes successfully.
[P1-start-ajaxresponse]The implementation of jsf.ajax.response must
handle the response as outlined in the JavaScript documentation for
jsf.ajax.response. The elements in the response must be processed in the
order they appear in the response.[P1-end]

=== [[a6783]]Monitoring Events On The Client

JavaScript functions can be registered to be
notified during various stages of the Ajax request/response cycle.
Functions can be set up to monitor individual Ajax requests, and
functions can also be set up to monitor all Ajax requests.

=== [[a6785]]Monitoring Events For An Ajax Request

There are two ways to monitor events for a
single Ajax request by registering an event callback function:

By using the <f:ajax> tag with the onevent
attribute.

By using the JavaScript API function
jsf.ajax.request with onevent as an option.

{empty}Refer to
link:JSF.html#UNKNOWN[See <f:ajax>] for details on the use of the
<f:ajax> tag approach. Refer to
link:JSF.html#a6856[See Initiating an
Ajax Request] for details about using the jsf.ajax.request function
approach. [P1-start-event-request]The implementation must ensure the
JavaScript function that is registered for an Ajax request must be
called in accordance with the events outlined in
link:JSF.html#a6936[See Events].[P1-end]

=== [[a6790]]Monitoring Events For All Ajax Requests

{empty}The JavaScript API provides the
jsf.ajax.addOnEvent function that can be used to register a JavaScript
function that will be notified when any Ajax request/response event
occurs. Refer to
link:JSF.html#a6931[See Registering
Callback Functions] for more details. The jsf.ajax.addOnEvent function
accepts a JavaScript function argument that will be notified when events
occur during any Ajax request/response event cycle. [P1-start-event] The
implementation must ensure the JavaScript function that is registered
must be called in accordance with the events outlined in
link:JSF.html#a6936[See Events].[P1-end]

=== [[a6792]]Sending Events

[P1-start-event-send]The implementation must
send events to the runtime as follows:

Construct a data payload for events using the
properties described in link:JSF.html#a6947[See
Event Data Payload].

If an event handler function was registered
with the “onevent” attribute
(link:JSF.html#a6785[See
Monitoring Events For An Ajax Request]) call it passing the data
payload.

{empty}If any event handling functions were
registered with the “addOnEvent” function
(link:JSF.html#a6790[See
Monitoring Events For All Ajax Requests]) call them passing the data
payload.[P1-end]

=== [[a6797]]Handling Errors On the Client

JavaScript functions can be registered to be
notified when Ajax requests complete with error status codes from the
server to give implementations a chance to handle the errors. Functions
can be set up to handle errors from individual Ajax requests and
functions can be setup to handle errors for all Ajax requests.

=== [[a6799]]Handling Errors For An Ajax Request

There are two ways to handle errors for a
single Ajax request by registering an error callback function:

By using the <f:ajax> tag with the onerror
attribute.

By using the JavaScript API function
jsf.ajax.request with onerror as an option.

{empty}Refer to
link:JSF.html#UNKNOWN[See <f:ajax>] for details on the use of the
<f:ajax> tag approach. Refer to
link:JSF.html#a6856[See Initiating an
Ajax Request] for details about using the jsf.ajax.request function
approach. [P1-start-event-request]The implementation must ensure the
JavaScript function that is registered for an Ajax request must be
called in accordance when the request status code from the server is as
outlined in link:JSF.html#a6976[See Errors].[P1-end]

=== [[a6804]]Handling Errors For All Ajax Requests

{empty}The JavaScript API provides the
jsf.ajax.addOnError function that can be used to register a JavaScript
function that will be notified when an error occurs for any Ajax
request/response. Refer to
link:JSF.html#a6931[See Registering
Callback Functions] for more details. The jsf.ajax.addOnError function
accepts a JavaScript function argument that will be notified when errors
occur during any Ajax request/response cycle. [P1-start-event] The
implementation must ensure the JavaScript function that is registered
must be called in accordance with the errors outlined in
link:JSF.html#a6976[See Errors].[P1-end]

=== [[a6806]]Signaling Errors

[P1-start-error-signal]The implementation
must signal errors to the runtime as follows:

Construct a data payload for errors using the
properties described in link:JSF.html#a6988[See
Error Data Payload].

If an error handler function was registered
with the “onerror” attribute
(link:JSF.html#a6799[See
Handling Errors For An Ajax Request]) call it passing the data payload.

If any error handling functions were
registered with the “addOnError” function
(link:JSF.html#a6804[See
Handling Errors For All Ajax Requests]) call them passing the data
payload.

{empty}If the project stage is “development”
(see
link:JSF.html#a7017[See
Determining An Application’s Project Stage]) use JavaScript “alert” to
signal the error(s).[P1-end]

=== [[a6812]]Handling Errors On The Server

JavaServer Faces handles exceptions on the
server as outlined in link:JSF.html#a3253[See ExceptionHandler].
[P1-start-error-server]JavaServer Faces Ajax frameworks must ensure
exception information is written to the response in the format:

[width="100%",cols="100%",]
|===
a|
<partial-response id="j_id1">

<error>

<error-name>...</error-name>

<error-message>...</error-message>

</error>

</partial-response>

|===

Extract the “class” from the “Throwable”
object and write that as the contents of error-name in the response.

Extract the “cause” from the “Throwable”
object if it is available and write that as the contents of
error-message in the response. If “cause” is not available, write the
string returned from “Throwable.getMessage()”.

{empty}Implementations must ensure that an
ExceptionHandler suitable for writing exceptions to the partial response
is installed if the current request required an Ajax response
(PartialViewContext.isAjaxRequest() returns true).[P1-end]

Implementations may choose to include a
specialized ExceptionHandler for Ajax that extends from
javax.faces.context.ExceptionHandlerWrapper, and have the
javax.faces.context.ExceptionHandlerFactory implementation install it if
the environment requires it.

=== 

image:SF-53.png[image]

[[a6825]]Partial
View Traversal

The JavaServer Faces lifecycle, can be viewed
as consisting of an execute phase and a render phase.



image:lifecycle.png[image]

Partial traversal is the technique that can
be used to “visit” one or more components in the view, potentially to
have them pass through the “execute” and/or “render” phases of the
request processing lifecycle. This is a key feature for JSF and Ajax
frameworks and it allows selected components in the view to be processed
and/or rendered. There are a variety of JSF Ajax frameworks available,
and they all perform some variation of partial traversal.

=== [[a6829]]Partial Traversal Strategy

Frameworks use a partial traversal strategy
to perform partial view processing and partial view rendering. This
specification does not dictate the use of a specific partial traversal
strategy. However, frameworks must implement their desired strategy by
implementing the PartialViewContext.processPartial method. Refer to the
JavaDocs for details about this method.

=== [[a6831]]Partial View Processing

{empty}Partial view processing allows
selected components to be processed through the “execute” portion of the
lifecycle. Although the diagram in
link:JSF.html#a6825[See Partial View
Traversal] depicts the “execute” portion as encompassing everything
except the “Render Response Phase”, for the purposas of an ajax request,
the execute portion of the lifecycle is the “Apply Request Values
Phase”, “Update Model Values Phase” and “Process Validations Phase”.
Partial view processing on the server is triggered by a request from the
client. The request does not have to be an Ajax request. The request
contains special parameters that indicate the request is a partial
execute request (not triggered by Ajax) or a partial execute request
that was triggered using Ajax. The client also sends a set of client ids
of the components that must be processed through the execute phase of
the request processing lifecycle. Refer to
link:JSF.html#a6769[See Sending an Ajax
Request] about the request sending details. The FacesContext has methods
for retrieving the PartialViewContext instance for the request. The
PartialViewContext may also be retrieved by using the
PartialViewContextFactory class. The XML schema allows for the
definition of a PartialViewContextFactory using the
“partial-view-context-factory” element. Refer to the partial response
schema in the Javadoc section of the spec for more information on this
element. The PartialViewContext has properties and methods that indicate
the request is a partial request based on the values of these special
request parameters. Refer to the JavaDocs for
javax.faces.context.PartialViewContext and
link:JSF.html#a3229[See Partial View Context]
for the specifics of the PartialViewContext constants and methods that
facilitate partial processing. [P1-start-partialExec]The UIViewRoot
processDecodes, processValidators and processUpdates methods must
determine if the request is a partial request using the
FacesContext.getCurrentInstance().getPartialViewContext().isPartialRequest()
method. If
FacesContext.getCurrentInstance().getPartialViewContext().isPartialRequest()
returns true, then the implementation of these methods must retrieve a
PartialViewContext instance and invoke
PartialViewContext.processPartial. Refer to
link:JSF.html#a427[See Apply Request Values],
link:JSF.html#a436[See
Apply Request Values Partial Processing],
link:JSF.html#a438[See Process Validations],
link:JSF.html#a444[See
Partial Validations Partial Processing], link:JSF.html#a446[See
Update Model Values],
link:JSF.html#a452[See
Update Model Values Partial Processing].[P1-end]

=== [[a6833]]Partial View Rendering

{empty}Partial view rendering on the server
is triggered by a request from the client. It allows one or more
components in the view to perform the encoding process. The request
contains special parameters that indicate the request is a partial
render request. The client also sends a set of client ids of the
components that must be processed by the render phase of the request
processing lifecycle. Refer to
link:JSF.html#a6769[See Sending an Ajax
Request] about the request sending details. The PartialViewContext has
methods that indicate the request is a partial request based on the
values of these special request parameters. Refer to
link:JSF.html#a3225[See
Partial Processing Methods] for the specifics of the FacesContext
constants and methods that facilitate partial processing.
[P1-start-partialRender]The UIViewRoot getRendersChildren and
encodeChildren methods must determine if the request is an Ajax request
using the
FacesContext.getCurrentInstance().getPartialViewContext().isAjaxRequest()
method. If PartialViewContext.isAjaxRequest() returns true, then the
getRendersChildren method must return true and the encodeChildren method
must perform partial rendering using the
PartialViewContext.processPartial implementation. Refer to the JavaDocs
for UIViewRoot.encodeChildren for specific details.[P1-end]

=== [[a6835]]Sending The Response to The Client

The Ajax response (also known as partial
response) is formulated and sent to the client during the Render
Response phase of the request processing lifecycle. The partial response
consists of markup rendered by one or more components. The response
should be in a common format so JavaScript clients can interpret the
markup in a consistent way - an important requirement for component
compatability. The agreed upon format and content type for the partial
response is XML. This means there should be a ResponseWriter suitable
for writing the response in XML. The UIViewRoot.encodeChildren method
delegates to a partial traversal strategy. The partial traversal
strategy implementation produces the partial response. The markup that
is sent to the client must contain elements that the client can
recognize. In addition to the markup produced by server side components,
the response must contain “instructions” for the client to interpret, so
the client will know, for example, that it is to add new markup to the
client DOM, or update existing areas of the DOM. When the response is
sent back to the client, it must contain the view state.
[P1-start-sending-response]Implementations must adhere to the response
format as specified in the JavaScript docs for
jsf.ajax.response.[P1-end] Refer to the XML schema definition in the
link:JSF.html#a7162[See XML Schema Definition for Composite
Components] section. This XML schema is another important area for
component library compatability.

=== [[a6837]]Writing The Partial Response

JavaServer Faces provides
javax.faces.context.PartialResponseWriter to ensure the Ajax response
that is written follows the standard format as specified in
link:JSF.html#a7162[See XML Schema Definition for Composite
Components]. Implementations must take care to properly handle nested
CDATA sections when writing the response. PartialResponseWriter
decorates an existing ResponseWriter implementation by extending
javax.faces.context.ResponseWriterWrapper. Refer to the
javax.faces.context.PartialResponseWriter JavaDocs, and the JavaScript
documentation for the jsf.ajax.response function for more specifics.

 

=== 

image:SF-55.png[image]

[[a6841]]JavaScript
API

image:SF-56.png[image]

This chapter of the specification describes
the JavaScript functions that are used to facilitate Ajax operations in
a JavaServer Faces framework. All of these functions are contained in
the canonical _jsf.js_ file.

=== 

image:SF-57.png[image]

[[a6844]]Collecting
and Encoding View State

In JavaServer Faces 1.2 the
javax.faces.ViewState parameter was standardized to facilitate
“postback” requests to the server in a JavaServer Faces application.
Implementations must use this parameter to save the view state between
requests. Refer to the Javadocs for
javax.faces.render.ResponseStateManager.

Collecting and encoding view state that will
be sent to the server is a common operation used by most JavaServer
Faces Ajax frameworks. When a JavaServer Faces view is rendered, it will
contain a hidden field with the identifier javax.faces.ViewState whose
value contains the state for the current view. JSF Ajax clients collect
additional view state, combine it with the current view state and send
it’s encoded form to the server.

[width="100%",cols="100%",]
|===
|jsf.getViewState(FORM_ELEMENT)
|===

Collect and encode element data for the given
FORM_ELEMENT and return it as the view state that will be sent to the
server. FORM_ELEMENT is the identifier for a DOM form element. All input
elements of type “hidden” should be included in the collection and
encoding process.

Encode the name and value for each input
element of FORM_ELEMENT. Only select elements that have at least one of
their options selected must be included. only checkbox elements that are
checked must be included.

Find the element identified as
javax.faces.ViewState in the specified FORM_ELEMENT and encode the name
and value.

Return a concatenated String of the encoded
input elements and javax.faces.ViewState element.

=== [[a6852]]Use Case

Collect and Encode Elements Of a Form

[width="100%",cols="100%",]
|===
|var viewState = jsf.getViewState(form);
|===

=== 

image:SF-57.png[image]

[[a6856]]Initiating an Ajax Request

[width="100%",cols="100%",]
|===
|jsf.ajax.request(source, |event|, \{
|OPTIONS| });
|===

The jsf.ajax.request function is responsible
for sending an Ajax request to the server. [P1-start-ajaxrequest]The
requirements for this function are as follows:

The request must be sent asynchronously

The request must be sent with method type
POST

The request URL will be the form action
attribute

All requests will be queued with the use of a
client side request queue to help ensure request ordering

{empty}[P1-end]

=== [[a6864]]Usage

Typically, this function is attached as a
JavaScript event handler (such as “onclick”).

[width="100%",cols="100%",]
|===
a|
<ANY_HTML_OR_JSF_ELEMENT

on|EVENT|="jsf.ajax.request(source, event,

\{ |OPTIONS| });" />

|===

The function arguments are as follows:

source is the DOM element that triggered this
Ajax request. [P1-start-source]It must be a DOM element object or a
string identifier for a DOM element. [P1-end]The event argument is the
JavaScript event object. The optional |OPTIONS| argument is a JavaScript
associative object array that may contain the following name/value
pairs:

=== [[a6871]]request OPTIONS

Name

Value

execute

A space delimited list of client identifiers
or one of the keywords (link:JSF.html#a6884[See Keywords]).
These reference the components that will be processed during the
“execute” portion of the request processing lifecycle.

render

A space delimited list of client identifiers
or one of the keywords (link:JSF.html#a6884[See Keywords]).
These reference the components that will be processed during the
“render” portion of the request processing lifecycle.

onevent

A String that is the name of the JavaScript
function to call when an event occurs.

onerror

A String that is the name of the JavaScript
function to call when an error occurs.

params

An object that may include additional
parameters to include in the request.

=== [[a6884]]Keywords

The following keywords can be used for the
value of the “execute” and “render” attributes:

=== Execute / Render Keywords

Keyword

Description

@all

All component identifiers

@none

No identifiers

@this

The element that triggered the request

@form

The enclosing form

=== [[a6897]]Default Values

Values for the execute and render attributes
are not required. When using the JavaScript API, the default values for
execute is @this. The default value for render is @none.

[width="100%",cols="100%",]
|===
a|
<h:commandButton id=”button1” value=”submit”>

onclick="jsf.ajax.request(this,event);" />

is the same as:

<h:commandButton id=”button1” value=”submit”>

onclick="jsf.ajax.request(this,event,

\{execute:’@this’,render:’@this’});" />

|===

[width="100%",cols="100%",]
|===
a|
<h:commandButton id=”button1” value=”submit”>

onclick="jsf.ajax.request(this,event,
\{execute:’@this’});" />

is the same as:

<h:commandButton id=”button1” value=”submit”>

onclick="jsf.ajax.request(this,event,
\{execute:’button1’});" />

|===

Refer to link:JSF.html#UNKNOWN[See
<f:ajax>] for the default values for the execute and render attributes
when they are used with the core “<f:ajax>” tag.

=== [[a6911]]Request Sending Specifics

The mechanics of sending an Ajax request
becomes very important to promote component compatability. Even more
important, is standardizing on the post data that is sent to server
implementations, so they all can expect the same arguments.
[P1-start-ajaxrequest-send]The request header must be set with the name
Faces-Request and the value partial/ajax. Specifics of formulating post
data and sending the request must be followed as outlined in the
JavaScript documentation for the jsf.ajax.request function. The post
data arguments that must be sent are:

[width="100%",cols="50%,50%",]
|===
|Name |Value

|javax.faces.ViewState
|The value of the javax.faces.ViewState
hidden field. This is included when using the jsf.getViewState function.

|javax.faces.partial.ajax
|true

|javax.faces.source
|The identifier of the element that is the
source of this request
|===

{empty}[P1-end]

=== [[a6921]]Use Case

[width="100%",cols="100%",]
|===
a|
<h:commandbutton id="submit" value="submit"

onclick="jsf.ajax.request(this, event,

\{execute:'submit',render:'outtext'}); return
false;" />

|===

This use case assumes there is another
component in the view with the identifier outtext.

=== 

image:SF-57.png[image]

[[a7017]]Processing
The Ajax Response

[width="100%",cols="100%",]
|===
|jsf.ajax.response(request, context);
|===

{empty}The jsf.ajax.response function is
called when a request completes successfully. This typically means that
returned status code is >= 200 and < 300. The jsf.ajax.response function
must extract the XML response from the request argument. The XML
response is expected to follow the format that is outlined in the
JavaScript documentation for this function. The response format is an
“instruction set” telling this function how it should update the DOM.
The context argument contains properties that facilitate event and error
processing such as the source DOM element (the DOM element that
triggered the Ajax request), onevent (the event handling callback for
the request) and onerror (the error handling callback for the request).
[P1-start-ajaxresponse] The specifics details of this function’s
operation must follow the jsf.ajax.response JavaScript
documentation.[P1-end]

=== 

image:SF-57.png[image]

[[a6931]]Registering Callback
Functions

The JavaScript API allows you to register
callback functions for Ajax request/response event monitoring and error
handling. The event callbacks become very useful when monitoring request
connection status. The error callback provides a convenient way for
implementions to trap errors. The handling of the errors is left up to
the implementation. These callback function names can also be set using
the JavaScript API (link:JSF.html#a6871[See request
OPTIONS]), and the core <f:ajax> tag (link:JSF.html#UNKNOWN[See
<f:ajax>]).

=== [[a6933]]Request/Response Event Handling

[width="100%",cols="100%",]
|===
|jsf.ajax.addOnEvent(callback);
|===

The callback argument must be a reference to
an existing JavaScript function that will handle the events. The events
that can be handled are:

=== [[a6936]]Events

Event Name

Description

begin

Occurs immediately before the request is
sent.

complete

Occurs immediately after the request has
completed. For successful requests, this is immediately before
javax.faces.response is called. For unsuccessful requests, this is
immediately before the error handling callback is invoked.

success

Occurs immediately after jsf.ajax.response
has completed.



The callback function has access to the
following “data payload”:.

=== [[a6947]]Event Data Payload

Name

Description/Value

type

“event”

status

{empty}One of the events specified in
link:JSF.html#a6936[See Events]

source

The DOM element that triggered the Ajax
request.

responseCode

Ajax request object ‘status’
(XMLHttpRequest.status); Not present for “begin” event;

responseXML

The XML response
(XMLHttpRequest.responseXML); Not present for “begin” event;

responseText

The text response
(XMLHttpResponse.responseText) Not present for “begin” event;

=== [[a6962]]Use Case

An event listener can be installed from
JavaScript in this manner.

[width="100%",cols="100%",]
|===
a|
function statusUpdate(data) \{

 // do something with data.status or other
parts of data payload

}

...

jsf.ajax.addOnEvent(statusUpdate);



|===

An event listener can be installed from
markup in this manner.

[width="100%",cols="100%",]
|===
a|
<f:ajax ... onevent="statusUpdate" />



|===

=== [[a6973]]Error Handling

[width="100%",cols="100%",]
|===
|jsf.ajax.addOnError(callback);
|===

The callback argument must be a reference to
an existing JavaScript function that will handle errors from the server.

=== [[a6976]]Errors

Error Name

Description

httpError

request status==null or
request.status==undefined or request.status<200 or request.status >=300

serverError

The Ajax response contains an “error”
element.

malformedXML

{empty}The Ajax response does not follow the
proper format. See link:JSF.html#a7162[See XML Schema Definition
for Composite Components]

emptyResponse

There was no Ajax response from the server.

The callback function has access to the
following “data payload”:.

=== [[a6988]]Error Data Payload

Name

Description/Value

type

“error”

status

{empty}One of error names defined
link:JSF.html#a6976[See Errors]

description

Text describing the error

source

The DOM element that triggered the Ajax
request.

responseCode

Ajax request object ‘status’
(XMLHttpRequest.status);

responseXML

The XML response (XMLHttpRequest.responseXML)

responseText

The text response
(XMLHttpResponse.responseTxt)

errorName

The error name taken from the Ajax response
“error” element.

errorMessage

The error messages taken from the Ajax
response “error” element.

=== [[a7009]]Use Case

[width="100%",cols="100%",]
|===
a|
jsf.ajax.addOnError(handleError);

...

var handleError = function handleError(data)
\{

... do something with “data payload” ...

}

|===



=== 

image:SF-57.png[image]

Determining
An Application’s Project Stage

[width="100%",cols="100%",]
|===
|jsf.getProjectStage();
|===

{empty}[P1-start-projStage]This function must
return the constant representing the current state of the running
application in a typical product development lifecycle. The returned
value must be the value returned from the server side method
javax.faces.application.Application.getProjectStage(); Refer to
link:JSF.html#a3455[See ProjectStage Property] for more details
about this property.[P1-end]

=== [[a7020]]Use Case

[width="100%",cols="100%",]
|===
a|
var projectStage =
javax.faces.Ajax.getProjectStage();

if (projectStage == “Production”) \{

.... throw exception

else if (projectStage == “Development”) \{

.... send an alert for debugging

}

|===



=== 

image:SF-57.png[image]

[[a7029]]Script Chaining

[width="100%",cols="100%",]
|===
|jsf.util.chain(source, event, |<script>,
<script>,...|)
|===

This utility function invokes an arbitrary
number of scripts in sequence. If any of the scripts return false,
subsequent scripst will not be executed. The arguments are:

source - The DOM element that triggered this
Ajax request, or an id string of the element to use as the triggering
element.

event - The DOM event that triggered this
Ajax request. A value does not have to be specified for this argument.

The variable number of script arguments
follow the source and event arguments. Refer to the JavaScript API
documentation in the source for more details.

 

=== 

image:SF-58.png[image]

[[a7037]]Appendix A - JSF Metadata

image:SF-59.png[image]

The XML Schema Definition for Application
Configuration Resource files is included in a web browser optimized
format along with the Javadoc. That is the canonical location of the
schemas in the specification.

=== 

image:SF-60.png[image]

[[a7040]]Required Handling of _*-extension_ elements in the
application configuration resources files

As specified in the XML Schema for
Application Configuration Resources, many of the elements in the file
have _*-extension_ elements declared in a similar fashion to this one
for the _faces-config-extension_ :

[width="100%",cols="100%",]
|===
a|
 _<xsd:complexType name =
"faces-config-extensionType">_

 _<xsd:annotation>_

 _<xsd:documentation>_

 _Extension element for faces-config. It may
contain_

 _implementation specific content._

 _</xsd:documentation>_

 _</xsd:annotation>_

 _<xsd:sequence>_

 _<xsd:any namespace="##any"_

 _processContents="lax"_

 _minOccurs="0"_

 _maxOccurs="unbounded" />_

 _</xsd:sequence>_

 _<xsd:attribute name="id" type="xsd:ID"/>_

 _</xsd:complexType>_

|===

This section specifies the required handling
of such elements.

Note that it is normal for an application to
have several application configuration resources files. If multiple such
resource files have conflicting _*-extension_ elements, the last element
processed takes precedence over preceding elements. Processing order can
be controlled as specified in link:JSF.html#a6435[See Ordering
of Artifacts].

===  _faces-config-extension_ handling

If an application configuration resource
contains a _faces-config-extension_ element, the children of the element
must be inspected for containing well-formed XML conforming to the
syntax specified in the following subsection(s). DTD syntax is used for
convenience since the content of a _*-extension_ element may not be
constrained due to its declaration as containing _<xsd:any>_ .

=== [[a7061]]The _facelets-processing_ element

DTD syntax..

[width="100%",cols="100%",]
|===
|<!ELEMENT facelets-processing
(file-extension, process-as) > +
<!ELEMENT file-extension ANY> +
<!ELEMENT process-as ANY> __
|===

The _<facelets-processing>_ element is used
to affect the processing of Facelets VDL files. Therefore, this setting
only applies to those requests that reach the Facelets
_ViewDeclarationLanguage_ implementation, as specified to the runtime
via the _javax.faces.FACELETS_VIEW_MAPPINGS_ and
_javax.faces.DEFAULT_SUFFIX_ _<context-param>_ entries. The
specification defines three processing modes for Facelets files:
Facelets XHTML syntax, XML View syntax, and Facelets JSPX syntax. This
last syntax is intended to ease the migration to Facelets for
applications already using the JSP document syntax (also known as JSPX
syntax). The affect on the processing of files in each of these three
modes is specified in the following table.

=== Valid _<process-as>_ values and their implications on the processing of Facelet VDL files.



 _<process-as>html5</process-as> +
HTML 5 (default)_

 _<process-as>xhtml</process-as> +
Facelets XHTML_

<process-as>xml</process-as> +
XML View

<process-as>jspx</process-as> +
Facelets JSPX

XML Doctype

Simplified to _<!DOCTYPE html>_

passed through

consumed

consumed

 _XML declaration_

passed through __

passed through

consumed

consumed

 _Processing instructions_

passed through

passed through

consumed

consumed

 _CDATA section start and end tags_

passed through

passed through

consumed

consumed

 _Escaping of inline text_

escaped

escaped

escaped

not escaped

 _XML Comments_

passed through

passed through

consumed

consumed

In the preceding table, “passed through”
means that the content is passed through unmodified to the user agent.
“consumed” means the content is silently consumed on the server. Note
that for CDATA sections, the content of the CDATA section itself is
passed through, even if the start and end tags should be consumed.
“escaped” means that sensivite content in the response is automatically
escaped: _&_ becomes _&amp;_ , for example. “not escaped” means that
such content is not escaped.

The content of the _<file-extension>_ element
is particular to the file extension of the physical resource for the
Facelets VDL content, as specified in the
_javax.faces.FACELETS_VIEW_MAPPINGS_ and _javax.faces.DEFAULT_SUFFIX_
_<context-param>_ elements. Consider the following example
_faces-config.xml_ .

[width="100%",cols="100%",]
|===
a|
 _<?xml version='1.0' encoding='UTF-8'?>_

 _<faces-config_

 _xmlns="http://java.sun.com/xml/ns/javaee"_


_xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"_


_xsi:schemaLocation="http://java.sun.com/xml/ns/javaee_


_http://java.sun.com/xml/ns/javaee/web-facesconfig_2_1.xsd"_

 _version="2.1">_

 _<faces-config-extension>_

 _<facelets-processing>_

 _<file-extension>.jspx</file-extension>_

 _<process-as>jspx</process-as>_

 _</facelets-processing>_

 _<facelets-processing>_

 _<file-extension>.view.xml</file-extension>_

 _<process-as>xml</process-as>_

 _</facelets-processing>_

 _</faces-config-extension>_

 _</faces-config>_

|===

And _web.xml_ content

[width="100%",cols="100%",]
|===
a|
 _<context-param>_


_<param-name>javax.faces.FACELETS_VIEW_MAPPINGS</param-name>_


_<param-value>*.xhtml;*.view.xml;*.jspx</param-value>_

 _</context-param>_

 __ 

 _<context-param>_


_<param-name>javax.faces.DEFAULT_SUFFIX</param-name>_

 _<param-value>.xhtml .view.xml .jsp
.jspx</param-value>_

 _</context-param>_

 __ 

|===

This configuration states that .xhtml,
.view.xml, and .jspx files must be treated as Facelets VDL files
declares the processing mode of .jspx files to be jspx and declares the
processing mode of .view.xml files to be xml.

=== 

image:SF-60.png[image]

[[a7134]]XML Schema Definition For Facelet Taglib

The XML Schema Definition for Facelet Taglib
is included in a web browser optimized format along with the Javadoc.
That is the canonical location of the schemas in the specification.

[P1_start_facelet_taglib_decl]To ease
migration for Facelet taglibraries declared using pre-JSF 2.0 versions
of Facelets, implementations must support loading facelet taglibrary
files that conform to the pre-JSF 2.0 Facelets DTD. Per DTD conventions,
Facelet taglibrary files declare conformance to this DTD by including
text similar to the following in at the top of their declaring file.

[width="100%",cols="100%",]
|===
| _<!DOCTYPE facelet-taglib PUBLIC +
"-//Sun Microsystems, Inc.//DTD Facelet Taglib 1.0//EN"
"http://java.sun.com/dtd/facelet-taglib_1_0.dtd">_
|===

{empty}Use of this DTD is officially
deprecated. This DTD is included for reference in
link:JSF.html#a7139[See Deprecated DTD for Facelet Taglibraries
Used by Versions of Facelets Prior to JSF 2.0]. It is expected that
proper JSF 2.0 Facelet Taglibraries will declare conformance to the
following schema, rather than the deprecated
DTD.[P1_end_facelet_taglib_decl]

=== [[a7139]]Deprecated DTD for Facelet Taglibraries Used by Versions of Facelets Prior to JSF 2.0

This DTD is deprecated and is included so
implementors will have a reference.

<!ELEMENT facelet-taglib
(library-class|(namespace,(tag|function)+))>

<!ATTLIST facelet-taglib xmlns CDATA #FIXED
"http://java.sun.com/JSF/Facelet">

<!ELEMENT namespace (#PCDATA)>

<!ELEMENT library-class (#PCDATA)>

<!ELEMENT tag
(tag-name,(handler-class|component|converter|validator|source))>

<!ELEMENT tag-name (#PCDATA)>

<!ELEMENT handler-class (#PCDATA)>

<!ELEMENT component
(component-type,renderer-type?,handler-class?)>

<!ELEMENT component-type (#PCDATA)>

<!ELEMENT renderer-type (#PCDATA)>

<!ELEMENT converter (converter-id,
handler-class?)>

<!ELEMENT converter-id (#PCDATA)>

<!ELEMENT validator (validator-id,
handler-class?)>

<!ELEMENT validator-id (#PCDATA)>

<!ELEMENT source (#PCDATA)>

<!ELEMENT function
(function-name,function-class,function-signature)>

<!ELEMENT function-name (#PCDATA)>

<!ELEMENT function-class (#PCDATA)>

<!ELEMENT function-signature (#PCDATA)>



=== 

image:SF-60.png[image]

[[a7162]]XML Schema Definition for Composite Components

<xsd:schema


targetNamespace="http://java.sun.com/xml/ns/javaee"


xmlns:javaee="http://java.sun.com/xml/ns/javaee"

 xmlns:xsd="http://www.w3.org/2001/XMLSchema"


xmlns:xml="http://www.w3.org/XML/1998/namespace"

 elementFormDefault="qualified"

 attributeFormDefault="unqualified"

 version="2.0">



 <xsd:annotation>

 <xsd:documentation>

 $Id: web-facesuicomponent_2_0.xsd,v 1.1.8.2
2008/03/20 21:12:50 edburns Exp $

 </xsd:documentation>

 </xsd:annotation>



 <xsd:annotation>

 <xsd:documentation>



 Copyright 2007 Sun Microsystems, Inc.,

 901 San Antonio Road,

 Palo Alto, California 94303, U.S.A.

 All rights reserved.



 Sun Microsystems, Inc. has intellectual
property

 rights relating to technology described in
this document. In

 particular, and without limitation, these
intellectual

 property rights may include one or more of
the U.S. patents

 listed at http://www.sun.com/patents and one
or more

 additional patents or pending patent
applications in the

 U.S. and other countries.



 This document and the technology which it
describes are

 distributed under licenses restricting their
use, copying,

 distribution, and decompilation. No part of
this document

 may be reproduced in any form by any means
without prior

 written authorization of Sun and its
licensors, if any.



 Third-party software, including font
technology, is

 copyrighted and licensed from Sun suppliers.



 Sun, Sun Microsystems, the Sun logo,
Solaris, Java, Java EE,

 JavaServer Pages, Enterprise JavaBeans and
the Java Coffee

 Cup logo are trademarks or registered
trademarks of Sun

 Microsystems, Inc. in the U.S. and other
countries.



 Federal Acquisitions: Commercial Software -
Government Users

 Subject to Standard License Terms and
Conditions.



 </xsd:documentation>

 </xsd:annotation>



 <xsd:annotation>

 <xsd:documentation>



 <![CDATA[



 The XML Schema for a JavaServer Faces
UIComponent (Version 2.0).



 The elements in this schema may be used in
an XHTML page for

 a composite component, by pulling in the
composite namespace:



<html xmlns="http://www.w3.org/1999/xhtml"


xmlns:composite="http://java.sun.com/jsf/composite">



 <composite:interface>

 <composite:attribute name="foo"
default="bar" />

 </composite:/interface>

 <!-- the rest omitted -->

</html>



 The elements in this schema may also be used
in a facelet taglibrary

 file in the same manner:



<facelet-taglib
xmlns="http://java.sun.com/xml/ns/javaee"


xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"


xmlns:composite="http://java.sun.com/jsf/composite"


xsi:schemaLocation="http://java.sun.com/xml/ns/javaee
http://java.sun.com/xml/ns/javaee/web-facelettaglibary_2_0.xsd"

 version="2.0">


<namespace>http://domain.com/test_schema</namespace>

 <tag>

 <tag-name>testSchema</tag-name>

 <component>


<component-type>javax.faces.Input</component-type>


<renderer-type>javax.faces.Text</renderer-type>


<handler-class>com.sun.faces.facelets.tag.jsf.ComponentHandler</handler-class>

 <component-extension>



 <composite:attribute name="foo"
default="bar" />



 </component-extension>

 </component>

 </tag>

</facelet-taglib>



 The instance documents may indicate the
published

 version of the schema using
xsi:schemaLocation attribute

 for javaee namespace with the following
location:




http://java.sun.com/xml/ns/javaee/web-facesuicomponent_2_0.xsd



 ]]>



 </xsd:documentation>

 </xsd:annotation>



 <xsd:include schemaLocation="javaee_5.xsd"/>



 <!--
**************************************************** -->



 <xsd:element name = "attribute"
type="javaee:uicomponent-attributeType">

 </xsd:element>



 <!--
**************************************************** -->



 <xsd:complexType
name="uicomponent-attributeType">

 <xsd:annotation>

 <xsd:documentation>



 The "attribute" element declares an
attribute of this

 ui component.



 </xsd:documentation>

 </xsd:annotation>



 <xsd:choice minOccurs="0"
maxOccurs="unbounded">

 <xsd:element name="attribute"

 type="javaee:uicomponent-attributeType"/>

 </xsd:choice>



 <xsd:attribute name="name"

 type="xsd:string"

 use="required"/>



 <xsd:attribute name="displayName"

 type="xsd:string"

 use="optional"/>



 <xsd:attribute name="shortDescription"

 type="xsd:string"

 use="optional"/>



 <xsd:attribute name="default"

 type="xsd:string"

 use="optional"/>



 <xsd:attribute name="method-signature"

 type="xsd:string"

 use="optional">



 <xsd:annotation>

 <xsd:documentation>

 <![CDATA[



 Provides the signature of the Java method.
The syntax of

 the method-signature element is as follows
(taken from

 function-signature in
web-jsptaglibrary_2_1.xsd):



 MethodSignature ::= ReturnType S MethodName
S?

 '(' S? Parameters? S? ')'



 ReturnType ::= Type



 MethodName ::= Identifier



 Parameters ::= Parameter

 | ( Parameter S? ',' S? Parameters )



 Parameter ::= Type



 Where:



 * Type is a basic type or a fully qualified

 Java class name (including package name),

 as per the 'Type' production in the Java

 Language Specification, Second Edition,

 Chapter 18.



 * Identifier is a Java identifier, as per

 the 'Identifier' production in the Java

 Language Specification, Second

 Edition, Chapter 18.



 Example:



 java.lang.String nickName( java.lang.String,
int )



 ]]>

 </xsd:documentation>

 </xsd:annotation>



 </xsd:attribute>



 <xsd:attribute name="applyTo"

 type="xsd:string"

 use="optional"/>



 <xsd:attribute name="required"

 type="xsd:boolean"

 use="optional"/>



 <xsd:attribute name="preferred"

 type="xsd:boolean"

 use="optional"/>



 <xsd:attribute name="expert"

 type="xsd:boolean"

 use="optional"/>





 </xsd:complexType>



 <!--
**************************************************** -->



</xsd:schema>

 __ 

=== 

image:SF-61.png[image]

Appendix B - Change Log

image:SF-62.png[image]

=== 

image:SF-63.png[image]

Changes between 2.1 and 2.2

This section gives the reader a survey of the
changes between this version of the specification and the previous
version, using the categories from the issue tracker at <
http://jsf-spec.java.net/issues/ >.

=== Big Ticket Features

HTML5 Friendly Markup

http://java.net/jira/browse/JAVASERVERFACES_SPEC_PUBLIC-1090

{empty}Start with
link:JSF.html#a5581[See HTML5 Friendly Markup]

Resource Library Contracts

http://java.net/jira/browse/JAVASERVERFACES_SPEC_PUBLIC-1142

Start with link:JSF.html#a5526[See
Resource Library Contracts Background].

Faces Flows

http://java.net/jira/browse/JAVASERVERFACES_SPEC_PUBLIC-730

Start with link:JSF.html#a3840[See
FlowHandler].

Stateless Views

http://java.net/jira/browse/JAVASERVERFACES_SPEC_PUBLIC-1055

Start with link:JSF.html#a4126[See
Stateless Views].

=== Other Features, by Functional Area

Components/Renderers

=== Larger Changes

http://java.net/jira/browse/JAVASERVERFACES_SPEC_PUBLIC-479-UIDataCollection +
UIData supports the Collection Interface rather than List.

http://java.net/jira/browse/JAVASERVERFACES_SPEC_PUBLIC-1134 +
- Add the "role" pass through attribute.

=== Smaller Changes

http://java.net/jira/browse/JAVASERVERFACES_SPEC_PUBLIC-1080-FindComponentWarning +
Warn about some important corner cases when
_UIComponent.findComponent()_ may not provide the expected results.

http://java.net/jira/browse/JAVASERVERFACES_SPEC_PUBLIC-1068-PartialResponseProcessing

New section describing what happens with
respect to partial processing during render response. See
link:JSF.html#a480[See Render Response Partial Processing].

http://java.net/jira/browse/JAVASERVERFACES_SPEC_PUBLIC-1067-cc:insertChildren +
Spec clarifications. See the VDLDoc for _cc:insertChildren_ ,
_cc:insertFacet_

http://java.net/jira/browse/JAVASERVERFACES_SPEC_PUBLIC-1061

Clarify that both
_Application.publishEvent()_ and the manual traversal based delivery are
required for publishing the _PostRestoreStateEvent_ .

http://java.net/jira/browse/JAVASERVERFACES_SPEC_PUBLIC-1030 +
Clarify docs for h:message h:messages

http://java.net/jira/browse/JAVASERVERFACES_SPEC_PUBLIC-1023 +
- Modify JavaDoc to relax requirements for PostAddToViewEvent publishing

http://java.net/jira/browse/JAVASERVERFACES_SPEC_PUBLIC-1019 +
Modify spec for ResponseWriter.writeURIAttribute() to explicitly require
adherence to the W3C URI spec

http://java.net/jira/browse/JAVASERVERFACES_SPEC_PUBLIC-997 +
javax.faces.component.ComponentSystemEvent: Override
isAppropriateListener so that it first asks the listener, "are you a
ComponentSystemEventListener", then, if not, asks
super.isAppropriateListener()

http://java.net/jira/browse/JAVASERVERFACES_SPEC_PUBLIC-984 +
Component Context Manager, see
_javax.faces.component.visit.ComponentModificationManager_ .

http://java.net/jira/browse/JAVASERVERFACES_SPEC_PUBLIC-943 +
See _javax.faces.view.ViewDeclarationLanguageWrapper_

http://java.net/jira/browse/JAVASERVERFACES_SPEC_PUBLIC-784 +
Deprecate the CURRENT_COMPONENT and CURRENT_COMPOSITE_COMPONENT
attributes

http://java.net/jira/browse/JAVASERVERFACES_SPEC_PUBLIC-599 +
Make it possible to programmatically create components in the same way
as they are created by Facelets. See
_javax.faces.application.Application.createComponent(FacesContext,
String taglibUri, String tagName, Map attrs)_

http://java.net/jira/browse/JAVASERVERFACES_SPEC_PUBLIC-703 +
Make "value" optional for @FacesComponent.

http://java.net/jira/browse/JAVASERVERFACES_SPEC_PUBLIC-585 +
outputText and inputText do not render children by default

http://java.net/jira/browse/JAVASERVERFACES_SPEC_PUBLIC-550 +
OutputStylesheet "media" attribute

http://java.net/jira/browse/JAVASERVERFACES_SPEC_PUBLIC-1125 +
_javax.faces.application.Application_ event subscription clarifications.

Lifecycle

=== Larger Changes

http://java.net/jira/browse/JAVASERVERFACES_SPEC_PUBLIC-949-ClientWindow +
http://java.net/jira/browse/JAVASERVERFACES_SPEC_PUBLIC-947-ClientWindow +
Give JSF the ability to correctly handle browsing context (tab, browser
window, pop-up, etc). See _javax.faces.lifecycle.ClientWindow_ .

http://java.net/jira/browse/JAVASERVERFACES_SPEC_PUBLIC-758-f:viewAction
and +
http://java.net/jira/browse/JAVASERVERFACES_SPEC_PUBLIC-1042

A
jsf-api/src/main/java/javax/faces/component/UIViewAction.java

The heart of this changebundle, this class
came over from the JBoss Seam Faces Module, but I've rewritten most of
the javadoc.

M
jsf-api/src/main/java/javax/faces/event/PhaseId.java

new methods

public String getName()

public static PhaseId phaseIdValueOf(String
phase)

Change link:JSF.html#a3571[See
Default NavigationHandler Algorithm] to account for UIViewAction

http://java.net/jira/browse/JAVASERVERFACES_SPEC_PUBLIC-1062
and http://java.net/jira/browse/JAVASERVERFACES_SPEC_PUBLIC-802 +
File Upload

http://java.net/jira/browse/JAVASERVERFACES_SPEC_PUBLIC-766 +
Events from the flash

http://java.net/jira/browse/JAVASERVERFACES_SPEC_PUBLIC-1050 +
Add support for delay value in options for Ajax requests

=== Smaller Changes

http://java.net/jira/browse/JAVASERVERFACES_SPEC_PUBLIC-1129 +
In validate(), clarify that setSubmittedValue() null must be called if
validation succeeds.

http://java.net/jira/browse/JAVASERVERFACES_SPEC_PUBLIC-1071

Add FlashFactory. See
link:JSF.html#a6336[See Delegating Implementation Support].

http://java.net/jira/browse/JAVASERVERFACES_SPEC_PUBLIC-1065

{empty}When calculating the locale for the
resource library prefix, if there is a UIViewRoot, use its locale first,
otherwise, just use the Applications’s ViewHandler’s calculateLocale()
method. See link:JSF.html#a836[See Libraries of Localized and
Versioned Resources]

http://java.net/jira/browse/JAVASERVERFACES_SPEC_PUBLIC-1039 +
In ApplicationWrapper, mark things as deprecated

http://java.net/jira/browse/JAVASERVERFACES_SPEC_PUBLIC-1028 +
Deprecate StateManager, point to StateManagementStrategy. In
StateManagementStrategy, require the use of the visit API to perform the
saving.

http://java.net/jira/browse/JAVASERVERFACES_SPEC_PUBLIC-993 +
Wrapper for ActionListener

Tweak circumstances for skipping intervening
lifecycle phases in the case of view metadata
http://java.net/jira/browse/JAVASERVERFACES_SPEC_PUBLIC-762

Section 2.2.1. Now has this text.

Otherwise, call getViewMetadata() on the
ViewDeclarationLanguage instance. If the result is non-null, call
createMetadataView() on the ViewMetadata instance. Call
ViewMetadata.getViewParameters(). If the result is a non-empty
Collection, do not call facesContext.renderResponse(). If the result is
an empty collection, try to obtain the metadata facet of the UIViewRoot
by asking the UIViewRoot for the facet named
UIViewRoot.METADATA_FACET_NAME. This facet must exist. If the facet has
no children, call facesContext.renderResponse(). Otherwise, none of the
previous steps have yielded the discovery any of metadata, so call
facesContext.renderResponse().

http://java.net/jira/browse/JAVASERVERFACES_SPEC_PUBLIC-566 +
UIOutput.getValue() value returns.

http://java.net/jira/browse/JAVASERVERFACES_SPEC_PUBLIC-220

In web-partialresponse_2_2.xsd, require that
the <partial-response> element has an “id” attribute whose value is the
return from _UIViewRoot.getContainerClientId()_ .



Platform Integration

http://java.net/jira/browse/JAVASERVERFACES_SPEC_PUBLIC-763

Change link:JSF.html#a2536[See
Managed Bean Annotations] to account for new injectability requirements.

http://java.net/jira/browse/JAVASERVERFACES_SPEC_PUBLIC-976 +
In Javadoc for “Faces Managed Bean Annotation Specification For
Containers Conforming to Servlet 2.5 and Beyond”, indicate that
_javax.faces.bean_ will be deprecated in the next version.

http://java.net/jira/browse/JAVASERVERFACES_SPEC_PUBLIC-1087 +
Introduce CDI based @ViewScoped annotation.

Facelets/VDL

=== Larger Changes

http://java.net/jira/browse/JAVASERVERFACES_SPEC_PUBLIC-1001 +
Allow cc and non-cc components in one taglib

A jsf-api/doc/web-facelettaglibrary_2_2.xsd

First change to the facelet taglib schema in
2.2: introduce the ability to declare a resource which will be the
composite component for a tag. Now, before you get all excited about
what conventions we can use to make this easier, let me stop you right
there. Here is a summary of the ease of use story regarding taglib
files.

The 80/20 rule says we should make taglib
files optional most of the time. Here are the 80% cases.

Employs the cc naming convention
http://java.sun.com/jsf/composite/<libraryName>

The user employs a java component has a
@FacesComponent on it that declares the necessary metadata.
JAVASERVERFACES_SPEC_PUBLIC-594

Here are some of the cases where you must
have a taglib file, the 20% cases.

If you want to employ a cc with a namespace
other than http://java.sun.com/jsf/composite/<libraryName> you need to
have a taglib file that declares <composite-library-name>. Currently you
must not detlare any <tag> elements in such a taglib file. All the tags
in such a library must come from the same resource library.

If the user is not employs a java component
but is not using @FacesComponent.

This patch introduces the following syntax.

<?xml version="1.0" encoding="UTF-8"?> +
<facelet-taglib xmlns="http://java.sun.com/xml/ns/javaee" +
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" +
xsi:schemaLocation="http://java.sun.com/xml/ns/javaee +
http://java.sun.com/xml/ns/javaee/web-facelettaglibary_2_2.xsd" +
version="2.2"> +
<namespace>test</namespace> +
<tag> +
<tag-name>layout</tag-name> +
<resource-id>myCC/whatever.xhtml</resource-id> +
</tag> +
</facelet-taglib>

Where _<resource-id>_ is a valid resource
identifier as specified in section 2.6.1.3.

http://java.net/jira/browse/JAVASERVERFACES_SPEC_PUBLIC-548

Require additional check to handle the case
where, in one resource library, there are both localized and
non-localized resources. See link:JSF.html#a836[See Libraries
of Localized and Versioned Resources].

=== Smaller Changes

http://java.net/jira/browse/JAVASERVERFACES_SPEC_PUBLIC-1038

Declare an annotation corresponding to the
_javax.faces.FACELETS_RESOURCE_RESOLVER_ application configuration
parameter. See link:JSF.html#a6598[See Requirements for scanning
of classes for annotations] and link:JSF.html#a6088[See
Application Configuration Parameters].

http://java.net/jira/browse/JAVASERVERFACES_SPEC_PUBLIC-1082

Account for DOCTYPE discrepancy between
server side representation of Facelet VDL files, which are proper XHTML,
and processed files which are sent to the client, which now, by default,
are HTML5 HTML syntax files. See link:JSF.html#a7061[See The
facelets-processing element].

Fix incorrect VDLDoc
http://java.net/jira/browse/JAVASERVERFACES_SPEC_PUBLIC-967
f:selectItems itemValue description incorrect.

http://java.net/jira/browse/JAVASERVERFACES_SPEC_PUBLIC-922 +
Remove maxlength from f:viewParam

http://java.net/jira/browse/JAVASERVERFACES_SPEC_PUBLIC-998 +
Document that ui:fragment should not be bound to a bean with wider than
request scope, document that the type of the property must extend from
UIComponent.

http://java.net/jira/browse/JAVASERVERFACES_SPEC_PUBLIC-999 +
Changes to "template" attribute requiredness for ui:decorate and
ui:composition

http://java.net/jira/browse/JAVASERVERFACES_SPEC_PUBLIC-901 +
Deprecate “targets” concept.

http://java.net/jira/browse/JAVASERVERFACES_SPEC_PUBLIC-1088 +
add short-name to schema.

http://java.net/jira/browse/JAVASERVERFACES_SPEC_PUBLIC-746 +
Missing _method-signature_ element in taglib xsd.

Spec Clarifications

http://java.net/jira/browse/JAVASERVERFACES_SPEC_PUBLIC-1136 +
In _ExternalContext.dispatch()_ , clarify what is to be done if
_getRequestDispatcher()_ returns _null_ .

http://java.net/jira/browse/JAVASERVERFACES_SPEC_PUBLIC-1132 +
Replace literal strings with symbolic constants where possible.

http://java.net/jira/browse/JAVASERVERFACES_SPEC_PUBLIC-1127 +
State Saving Serializability concerns.

http://java.net/jira/browse/JAVASERVERFACES_SPEC_PUBLIC-1114 +
_javax.faces.view.facelets.Facelet.apply()_ spec version reference
error.

http://java.net/jira/browse/JAVASERVERFACES_SPEC_PUBLIC-1100
http://java.net/jira/browse/JAVASERVERFACES_SPEC_PUBLIC-1097 +
HTML5 id attribute sensitivity

http://java.net/jira/browse/JAVASERVERFACES_SPEC_PUBLIC-1064

In link:JSF.html#a7061[See The
facelets-processing element], clarify that in XML and JSPX modes, only
the CDATA section start and end tags, not the entire CDATA section and
contents, should be consumed.

http://java.net/jira/browse/JAVASERVERFACES_SPEC_PUBLIC-1063 +
_javax.faces.component.UIViewParameter.getSubmittedValue()_ return
value.

http://java.net/jira/browse/JAVASERVERFACES_SPEC_PUBLIC-1058 +
ui:repeat tag size attribute

http://java.net/jira/browse/JAVASERVERFACES_SPEC_PUBLIC-1036

In link:JSF.html#a911[See
ValueExpression properties], clarify which attributes are expression
enabled,

http://java.net/jira/browse/JAVASERVERFACES_SPEC_PUBLIC-1035

Change section
link:JSF.html#a3300[See FacesMessage]to clarify the meaning of
having _FacesMessage_ instances on the _FacesContext._

http://java.net/jira/browse/JAVASERVERFACES_SPEC_PUBLIC-1026 +
f:ajax event attribute is String (not VE)

http://java.net/jira/browse/JAVASERVERFACES_SPEC_PUBLIC-1014

12.1.3

The specification for the context-param that
declares the list of TagDecorator implementations to the runtime should
have always been javax.faces.FACELETS_DECORATORS. Prior to this
revision, the name of this context param was incorrectly specified as
javax.faces.DECORATORS. The reference implementation has always used the
correct name, however.

http://java.net/jira/browse/JAVASERVERFACES_SPEC_PUBLIC-1010 +
Check existing usages of the state saving method parameter to ensure
case insensitivity.

http://java.net/jira/browse/JAVASERVERFACES_SPEC_PUBLIC-1004

M usingFacesInWebapps.fm

- 12.1.3 Set default for
javax.faces.FACELETS_BUFFER_SIZE to be 1024.

http://java.net/jira/browse/JAVASERVERFACES_SPEC_PUBLIC-998 +
Additional clarification about binding attribute in VDLdocs

http://java.net/jira/browse/JAVASERVERFACES_SPEC_PUBLIC-915
http://java.net/jira/browse/JAVASERVERFACES_SPEC_PUBLIC-1015
Non-normative text about http methods and prefix mapping

http://java.net/jira/browse/JAVASERVERFACES-2740 +
In link:JSF.html#a923[See Component Bindings], clarify a corner
case regarding bean scope and component binding.

Resources

=== Larger Changes

http://java.net/jira/browse/JAVASERVERFACES_SPEC_PUBLIC-809 +
This commit introduces a cleaner contract for allowing views to be
loaded from the Filesystem (including inside of JAR files). All VDL
resources must be loaded using ResourceHandler.createViewResource().

=== Smaller Changes

http://java.net/jira/browse/JAVASERVERFACES_SPEC_PUBLIC-996

Enable configuring the web app resources
directory. See link:JSF.html#a6088[See Application Configuration
Parameters].

http://java.net/jira/browse/JAVASERVERFACES_SPEC_PUBLIC-719 +
Method to map a viewId to a resourcePath

{empty}http://java.net/jira/browse/JAVASERVERFACES_SPEC_PUBLIC-1130-SerializeServerState +
Modify link:JSF.html#a4135[See State Saving Alternatives and
Implications] to clarify there is no requirement to serialize server
state by default when state saving method is server. Introduce a context
parameter to this effect in link:JSF.html#a6088[See Application
Configuration Parameters]

Expression Language

http://java.net/jira/browse/JAVASERVERFACES_SPEC_PUBLIC-1092

Remove text from
MethodExpressionValueChangeListener and MethodExpressionActionListener
regarding wrapping any exception thrown by the invoked method being
wrapped in an AbortProcessingException. Such a requirement is incorrect
and should not have been introduced.

In section link:JSF.html#a3253[See
ExceptionHandler], add _AbortProcessingException_ , to the list of
exceptions that do not get to the _ExceptionHandler_ .

http://java.net/jira/browse/JAVASERVERFACES_SPEC_PUBLIC-1043 +
When publishing a ComponentSystemEvent, ensure the EL current component
is pushed correctly

http://java.net/jira/browse/JAVASERVERFACES_SPEC_PUBLIC-1164 +
If running in a container that supports EL 3.0, add the necessary
ELResolvers. See link:JSF.html#a2966[See Stream, StaticField,
Map, List, Array, and Bean ELResolvers].

Configuration and Bootstrapping

http://java.net/jira/browse/JAVASERVERFACES_SPEC_PUBLIC-533-ProgrammaticFacesConfig

Modify link:JSF.html#a6201[See
Application Startup Behavior] to account for requirement to call new API
when starting up.

Miscellaneous

http://java.net/jira/browse/JAVASERVERFACES_SPEC_PUBLIC-1169

New XML Namespace for XSD files introduced in
JSF 2.2, and also for facelet tag libraries.

The following XSD files are new for JSF 2.2,
and each will be in the XML namespace
_http://xmlns.jcp.org/xml/ns/javaee_ .

 _web-facelettaglibrary_2_2.xsd_

 _web-facesconfig_2_2.xsd_

 _web-partialresponse_2_2.xsd_

Facelet Tag Libraries will now respond to the
following URIs

[width="100%",cols="34%,33%,33%",options="header",]
|===
|Library |Old URI
|New URI
|Composite Components
|http://java.sun.com/jsf/composite a|
http://xmlns.jcp.org/jsf/composite



|Faces Core
|http://java.sun.com/jsf/core a|
http://xmlns.jcp.org/jsf/core



|HTML_BASIC
|http://java.sun.com/jsf/html a|
http://xmlns.jcp.org/jsf/html



|JSTL Core a|
http://java.sun.com/jsp/jstl/core



a|
http://xmlns.jcp.org/jsp/jstl/core



|JSTL Functions
|http://java.sun.com/jsp/jstl/functions a|
http://xmlns.jcp.org/jsp/jstl/functions



|Facelets Templating
|http://java.sun.com/jsf/facelets a|
http://xmlns.jcp.org/jsf/facelets



|Pass Through Attributes
|http://java.sun.com/jsf/passthrough a|
http://xmlns.jcp.org/jsf/passthrough



|Pass Through Elements
|http://java.sun.com/jsf a|
http://xmlns.jcp.org/jsf



|===

Developers are requested to use the values
from the New URI column, though both columns will work.

http://java.net/jira/browse/JAVASERVERFACES_SPEC_PUBLIC-997

M
jsf-api/src/main/java/javax/faces/event/ComponentSystemEvent.java

Override isAppropriateListener so that it
first asks the listener, "are you a ComponentSystemEventListener", then,
if not, asks super.isAppropriateListener()

M
jsf-api/src/main/java/javax/faces/event/SystemEvent.java

in isAppropriateListener(), document the
default implementation.

M
jsf-api/src/main/java/javax/faces/component/UIComponent.java

Make inner class
ComponentSystemEventListenerAdapter implement
ComponentSystemEventListener.

http://java.net/jira/browse/JAVASERVERFACES_SPEC_PUBLIC-917

javax.faces.application.ResourceWrapper:

 - getContentType()

 - getLibraryName()

 - getResourceName()

 - setContentType(String)

 - setLibraryName(String)

 - setResourceName(String)

 javax.faces.context.ExternalContextWrapper:

 - getSessionMaxInactiveInterval()

 - isSecure()

 - setSessionMaxInactiveInterval()


javax.faces.context.PartialViewContextWrapper

 - setPartialRequest(boolean)

12.1.3 add this text to the
javax.faces.STATE_SAVING_METHOD spec. When examining the value, the
runtime must ignore the case.

Add
ExternalContext.getApplicationContextPath()
http://java.net/jira/browse/JAVASERVERFACES_SPEC_PUBLIC-1012

http://java.net/jira/browse/JAVASERVERFACES_SPEC_PUBLIC-787 +
restore ViewScope before templates are processed with buildView()

7.6.2.6 typo in spec for renderView(). Should
be

Return immediately if calling isRendered() on
the argument UIViewRoot returns false.

Per Matt Benson, remove duplicate
descriptions of the cc and component implicit object from the getValue()
specification for the composite component ELResolver in section 5.6.2.1.

http://java.net/jira/browse/JAVASERVERFACES_SPEC_PUBLIC-869

Specify Cross Site Request Forgery
protection.

Add text in link:JSF.html#a404[See
Restore View] to describe how non-postback requests are inspected for
protection, if necessary.

Remove text for writeState() in
link:JSF.html#a4288[See ResponseStateManager], point to the
JavaDocs.

Add View Protection methods to
link:JSF.html#a3874[See Overview] for ViewHandler.

Introduce subsections to
link:JSF.html#a3910[See Default ViewHandler Implementation] that
group the methods by their purpose. Add a new section
link:JSF.html#a3997[See ViewHandler Methods that relate to View
Protection], which points to the javadocs. In
link:JSF.html#a3955[See ViewHandler Methods Relating to
Navigation], in the spec for _getActionUrl()_ , specify how view
protection is affected.

{empty}Remove tables in section
link:JSF.html#a6598[See Requirements for scanning of classes for
annotations]

The Javadoc tool lists annotations in a
separate section, making the tables that list JSF related annotations
redundant.

.

http://java.net/jira/browse/JAVASERVERFACES_SPEC_PUBLIC-1082-DoctypeElement

Add new section
link:JSF.html#a5635[See DOCTYPE and XML Declaration].

http://java.net/jira/browse/JAVASERVERFACES_SPEC_PUBLIC-1141-SlashInResourceNames

In link:JSF.html#a758[See Resource
Identifiers], declare that resourceName and resourceVersion, in addition
to the already listed other segments, are subject to the same
constraints.

http://java.net/jira/browse/JAVASERVERFACES_SPEC_PUBLIC-1129-ResetValues

In link:JSF.html#a480[See Render
Response Partial Processing], require calling _UIViewRoot.resetValues()_
if necessary.

=== Backward Compatibility with Previous Versions

Faces 2.2 is backwards compatible with Faces
2.1 and 2.0. This means that a web-application that was developed to run
with Faces 2.1 or 2.0 won’t require any modification when run with Faces
2.2 except in the cases described in the following section.

=== Breakages in Backward Compatibility

http://java.net/jira/browse/JAVASERVERFACES_SPEC_PUBLIC-1092

Due to an error in previous versions of the
specification, exceptions were silently being swallowed that now will
bubble up to the exception handler. Code that was relying on this
incorrect behavior may need to be modified to account for fixing this
problem.

http://java.net/jira/browse/JAVASERVERFACES_SPEC_PUBLIC-745

5.6.2.2 Table 5-11. Make the following
changes to the spec for Composite Component Attribute ELResoler

Modify getType() according to new
specification language.

Require the implementation of containsKey()
on the Map.

containsKey(): If the attributes map contains
the key, return true. Otherwise, if a default value has been declared
for the attribute, return true. Otherwise, return false.

{empty}link:JSF.html#a1671[See
Composite Component Metadata]

New text dealing with <cc:attribute>

Any additional attributes on
_<composite:attribute/ >_ are exposed as attributes accessible from the
_getValue()_ and _attributeNames()_ methods on _PropertyDescriptor_ .
The return type from getValue() must be a _ValueExpression_ with the
exception of the _getValue(“type”)_ . The return type from
_getValue(“type”)_ must be _Class_ . If the value specified for the
_type_ attribute of _<cc:attribute/>_ cannot be converted to an actual
_Class_ , a _TagAttributeException_ must be thrown, including the _Tag_
and _TagAttribute_ instances in the constructor.

Yes, this is a backwards incompatible change,
but because the usecase is so specific, and the performance benefit so
substantial, it was judged to be worth the cost.



=== 

image:SF-63.png[image]

Changes between 2.1 and 2.2

This section gives the reader a survey of the
changes between this version of the specification and the previous
version, using the categories from the issue tracker at <
http://jsf-spec.java.net/issues/ >.

=== Big Ticket Features

HTML5 Friendly Markup

http://java.net/jira/browse/JAVASERVERFACES_SPEC_PUBLIC-1090

{empty}Start with
link:JSF.html#a5581[See HTML5 Friendly Markup]

Resource Library Contracts

http://java.net/jira/browse/JAVASERVERFACES_SPEC_PUBLIC-1142

Start with link:JSF.html#a5526[See
Resource Library Contracts Background].

Faces Flows

http://java.net/jira/browse/JAVASERVERFACES_SPEC_PUBLIC-730

Start with link:JSF.html#a3840[See
FlowHandler].

Stateless Views

http://java.net/jira/browse/JAVASERVERFACES_SPEC_PUBLIC-1055

Start with link:JSF.html#a4126[See
Stateless Views].

=== Other Features, by Functional Area

Components/Renderers

=== Larger Changes

http://java.net/jira/browse/JAVASERVERFACES_SPEC_PUBLIC-479-UIDataCollection +
UIData supports the Collection Interface rather than List.

http://java.net/jira/browse/JAVASERVERFACES_SPEC_PUBLIC-1134 +
- Add the "role" pass through attribute.

=== Smaller Changes

http://java.net/jira/browse/JAVASERVERFACES_SPEC_PUBLIC-1080-FindComponentWarning +
Warn about some important corner cases when
_UIComponent.findComponent()_ may not provide the expected results.

http://java.net/jira/browse/JAVASERVERFACES_SPEC_PUBLIC-1068-PartialResponseProcessing

New section describing what happens with
respect to partial processing during render response. See
link:JSF.html#a480[See Render Response Partial Processing].

http://java.net/jira/browse/JAVASERVERFACES_SPEC_PUBLIC-1067-cc:insertChildren +
Spec clarifications. See the VDLDoc for _cc:insertChildren_ ,
_cc:insertFacet_

http://java.net/jira/browse/JAVASERVERFACES_SPEC_PUBLIC-1061

Clarify that both
_Application.publishEvent()_ and the manual traversal based delivery are
required for publishing the _PostRestoreStateEvent_ .

http://java.net/jira/browse/JAVASERVERFACES_SPEC_PUBLIC-1030 +
Clarify docs for h:message h:messages

http://java.net/jira/browse/JAVASERVERFACES_SPEC_PUBLIC-1023 +
- Modify JavaDoc to relax requirements for PostAddToViewEvent publishing

http://java.net/jira/browse/JAVASERVERFACES_SPEC_PUBLIC-1019 +
Modify spec for ResponseWriter.writeURIAttribute() to explicitly require
adherence to the W3C URI spec

http://java.net/jira/browse/JAVASERVERFACES_SPEC_PUBLIC-997 +
javax.faces.component.ComponentSystemEvent: Override
isAppropriateListener so that it first asks the listener, "are you a
ComponentSystemEventListener", then, if not, asks
super.isAppropriateListener()

http://java.net/jira/browse/JAVASERVERFACES_SPEC_PUBLIC-984 +
Component Context Manager, see
_javax.faces.component.visit.ComponentModificationManager_ .

http://java.net/jira/browse/JAVASERVERFACES_SPEC_PUBLIC-943 +
See _javax.faces.view.ViewDeclarationLanguageWrapper_

http://java.net/jira/browse/JAVASERVERFACES_SPEC_PUBLIC-784 +
Deprecate the CURRENT_COMPONENT and CURRENT_COMPOSITE_COMPONENT
attributes

http://java.net/jira/browse/JAVASERVERFACES_SPEC_PUBLIC-599 +
Make it possible to programmatically create components in the same way
as they are created by Facelets. See
_javax.faces.application.Application.createComponent(FacesContext,
String taglibUri, String tagName, Map attrs)_

http://java.net/jira/browse/JAVASERVERFACES_SPEC_PUBLIC-703 +
Make "value" optional for @FacesComponent.

http://java.net/jira/browse/JAVASERVERFACES_SPEC_PUBLIC-585 +
outputText and inputText do not render children by default

http://java.net/jira/browse/JAVASERVERFACES_SPEC_PUBLIC-550 +
OutputStylesheet "media" attribute

http://java.net/jira/browse/JAVASERVERFACES_SPEC_PUBLIC-1125 +
_javax.faces.application.Application_ event subscription clarifications.

Lifecycle

=== Larger Changes

http://java.net/jira/browse/JAVASERVERFACES_SPEC_PUBLIC-949-ClientWindow +
http://java.net/jira/browse/JAVASERVERFACES_SPEC_PUBLIC-947-ClientWindow +
Give JSF the ability to correctly handle browsing context (tab, browser
window, pop-up, etc). See _javax.faces.lifecycle.ClientWindow_ .

http://java.net/jira/browse/JAVASERVERFACES_SPEC_PUBLIC-758-f:viewAction
and +
http://java.net/jira/browse/JAVASERVERFACES_SPEC_PUBLIC-1042

A
jsf-api/src/main/java/javax/faces/component/UIViewAction.java

The heart of this changebundle, this class
came over from the JBoss Seam Faces Module, but I've rewritten most of
the javadoc.

M
jsf-api/src/main/java/javax/faces/event/PhaseId.java

new methods

public String getName()

public static PhaseId phaseIdValueOf(String
phase)

Change link:JSF.html#a3571[See
Default NavigationHandler Algorithm] to account for UIViewAction

http://java.net/jira/browse/JAVASERVERFACES_SPEC_PUBLIC-1062
and http://java.net/jira/browse/JAVASERVERFACES_SPEC_PUBLIC-802 +
File Upload

http://java.net/jira/browse/JAVASERVERFACES_SPEC_PUBLIC-766 +
Events from the flash

http://java.net/jira/browse/JAVASERVERFACES_SPEC_PUBLIC-1050 +
Add support for delay value in options for Ajax requests

=== Smaller Changes

http://java.net/jira/browse/JAVASERVERFACES_SPEC_PUBLIC-1129 +
In validate(), clarify that setSubmittedValue() null must be called if
validation succeeds.

http://java.net/jira/browse/JAVASERVERFACES_SPEC_PUBLIC-1071

Add FlashFactory. See
link:JSF.html#a6336[See Delegating Implementation Support].

http://java.net/jira/browse/JAVASERVERFACES_SPEC_PUBLIC-1065

{empty}When calculating the locale for the
resource library prefix, if there is a UIViewRoot, use its locale first,
otherwise, just use the Applications’s ViewHandler’s calculateLocale()
method. See link:JSF.html#a836[See Libraries of Localized and
Versioned Resources]

http://java.net/jira/browse/JAVASERVERFACES_SPEC_PUBLIC-1039 +
In ApplicationWrapper, mark things as deprecated

http://java.net/jira/browse/JAVASERVERFACES_SPEC_PUBLIC-1028 +
Deprecate StateManager, point to StateManagementStrategy. In
StateManagementStrategy, require the use of the visit API to perform the
saving.

http://java.net/jira/browse/JAVASERVERFACES_SPEC_PUBLIC-993 +
Wrapper for ActionListener

Tweak circumstances for skipping intervening
lifecycle phases in the case of view metadata
http://java.net/jira/browse/JAVASERVERFACES_SPEC_PUBLIC-762

Section 2.2.1. Now has this text.

Otherwise, call getViewMetadata() on the
ViewDeclarationLanguage instance. If the result is non-null, call
createMetadataView() on the ViewMetadata instance. Call
ViewMetadata.getViewParameters(). If the result is a non-empty
Collection, do not call facesContext.renderResponse(). If the result is
an empty collection, try to obtain the metadata facet of the UIViewRoot
by asking the UIViewRoot for the facet named
UIViewRoot.METADATA_FACET_NAME. This facet must exist. If the facet has
no children, call facesContext.renderResponse(). Otherwise, none of the
previous steps have yielded the discovery any of metadata, so call
facesContext.renderResponse().

http://java.net/jira/browse/JAVASERVERFACES_SPEC_PUBLIC-566 +
UIOutput.getValue() value returns.

http://java.net/jira/browse/JAVASERVERFACES_SPEC_PUBLIC-220

In web-partialresponse_2_2.xsd, require that
the <partial-response> element has an “id” attribute whose value is the
return from _UIViewRoot.getContainerClientId()_ .



Platform Integration

http://java.net/jira/browse/JAVASERVERFACES_SPEC_PUBLIC-763

Change link:JSF.html#a2536[See
Managed Bean Annotations] to account for new injectability requirements.

http://java.net/jira/browse/JAVASERVERFACES_SPEC_PUBLIC-976 +
In Javadoc for “Faces Managed Bean Annotation Specification For
Containers Conforming to Servlet 2.5 and Beyond”, indicate that
_javax.faces.bean_ will be deprecated in the next version.

http://java.net/jira/browse/JAVASERVERFACES_SPEC_PUBLIC-1087 +
Introduce CDI based @ViewScoped annotation.

Facelets/VDL

=== Larger Changes

http://java.net/jira/browse/JAVASERVERFACES_SPEC_PUBLIC-1001 +
Allow cc and non-cc components in one taglib

A jsf-api/doc/web-facelettaglibrary_2_2.xsd

First change to the facelet taglib schema in
2.2: introduce the ability to declare a resource which will be the
composite component for a tag. Now, before you get all excited about
what conventions we can use to make this easier, let me stop you right
there. Here is a summary of the ease of use story regarding taglib
files.

The 80/20 rule says we should make taglib
files optional most of the time. Here are the 80% cases.

Employs the cc naming convention
http://java.sun.com/jsf/composite/<libraryName>

The user employs a java component has a
@FacesComponent on it that declares the necessary metadata.
JAVASERVERFACES_SPEC_PUBLIC-594

Here are some of the cases where you must
have a taglib file, the 20% cases.

If you want to employ a cc with a namespace
other than http://java.sun.com/jsf/composite/<libraryName> you need to
have a taglib file that declares <composite-library-name>. Currently you
must not detlare any <tag> elements in such a taglib file. All the tags
in such a library must come from the same resource library.

If the user is not employs a java component
but is not using @FacesComponent.

This patch introduces the following syntax.

<?xml version="1.0" encoding="UTF-8"?> +
<facelet-taglib xmlns="http://java.sun.com/xml/ns/javaee" +
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" +
xsi:schemaLocation="http://java.sun.com/xml/ns/javaee +
http://java.sun.com/xml/ns/javaee/web-facelettaglibary_2_2.xsd" +
version="2.2"> +
<namespace>test</namespace> +
<tag> +
<tag-name>layout</tag-name> +
<resource-id>myCC/whatever.xhtml</resource-id> +
</tag> +
</facelet-taglib>

Where _<resource-id>_ is a valid resource
identifier as specified in section 2.6.1.3.

http://java.net/jira/browse/JAVASERVERFACES_SPEC_PUBLIC-548

Require additional check to handle the case
where, in one resource library, there are both localized and
non-localized resources. See link:JSF.html#a836[See Libraries
of Localized and Versioned Resources].

=== Smaller Changes

http://java.net/jira/browse/JAVASERVERFACES_SPEC_PUBLIC-1038

Declare an annotation corresponding to the
_javax.faces.FACELETS_RESOURCE_RESOLVER_ application configuration
parameter. See link:JSF.html#a6598[See Requirements for scanning
of classes for annotations] and link:JSF.html#a6088[See
Application Configuration Parameters].

http://java.net/jira/browse/JAVASERVERFACES_SPEC_PUBLIC-1082

Account for DOCTYPE discrepancy between
server side representation of Facelet VDL files, which are proper XHTML,
and processed files which are sent to the client, which now, by default,
are HTML5 HTML syntax files. See link:JSF.html#a7061[See The
facelets-processing element].

Fix incorrect VDLDoc
http://java.net/jira/browse/JAVASERVERFACES_SPEC_PUBLIC-967
f:selectItems itemValue description incorrect.

http://java.net/jira/browse/JAVASERVERFACES_SPEC_PUBLIC-922 +
Remove maxlength from f:viewParam

http://java.net/jira/browse/JAVASERVERFACES_SPEC_PUBLIC-998 +
Document that ui:fragment should not be bound to a bean with wider than
request scope, document that the type of the property must extend from
UIComponent.

http://java.net/jira/browse/JAVASERVERFACES_SPEC_PUBLIC-999 +
Changes to "template" attribute requiredness for ui:decorate and
ui:composition

http://java.net/jira/browse/JAVASERVERFACES_SPEC_PUBLIC-901 +
Deprecate “targets” concept.

http://java.net/jira/browse/JAVASERVERFACES_SPEC_PUBLIC-1088 +
add short-name to schema.

http://java.net/jira/browse/JAVASERVERFACES_SPEC_PUBLIC-746 +
Missing _method-signature_ element in taglib xsd.

Spec Clarifications

http://java.net/jira/browse/JAVASERVERFACES_SPEC_PUBLIC-1136 +
In _ExternalContext.dispatch()_ , clarify what is to be done if
_getRequestDispatcher()_ returns _null_ .

http://java.net/jira/browse/JAVASERVERFACES_SPEC_PUBLIC-1132 +
Replace literal strings with symbolic constants where possible.

http://java.net/jira/browse/JAVASERVERFACES_SPEC_PUBLIC-1127 +
State Saving Serializability concerns.

http://java.net/jira/browse/JAVASERVERFACES_SPEC_PUBLIC-1114 +
_javax.faces.view.facelets.Facelet.apply()_ spec version reference
error.

http://java.net/jira/browse/JAVASERVERFACES_SPEC_PUBLIC-1100
http://java.net/jira/browse/JAVASERVERFACES_SPEC_PUBLIC-1097 +
HTML5 id attribute sensitivity

http://java.net/jira/browse/JAVASERVERFACES_SPEC_PUBLIC-1064

In link:JSF.html#a7061[See The
facelets-processing element], clarify that in XML and JSPX modes, only
the CDATA section start and end tags, not the entire CDATA section and
contents, should be consumed.

http://java.net/jira/browse/JAVASERVERFACES_SPEC_PUBLIC-1063 +
_javax.faces.component.UIViewParameter.getSubmittedValue()_ return
value.

http://java.net/jira/browse/JAVASERVERFACES_SPEC_PUBLIC-1058 +
ui:repeat tag size attribute

http://java.net/jira/browse/JAVASERVERFACES_SPEC_PUBLIC-1036

In link:JSF.html#a911[See
ValueExpression properties], clarify which attributes are expression
enabled,

http://java.net/jira/browse/JAVASERVERFACES_SPEC_PUBLIC-1035

Change section
link:JSF.html#a3300[See FacesMessage]to clarify the meaning of
having _FacesMessage_ instances on the _FacesContext._

http://java.net/jira/browse/JAVASERVERFACES_SPEC_PUBLIC-1026 +
f:ajax event attribute is String (not VE)

http://java.net/jira/browse/JAVASERVERFACES_SPEC_PUBLIC-1014

12.1.3

The specification for the context-param that
declares the list of TagDecorator implementations to the runtime should
have always been javax.faces.FACELETS_DECORATORS. Prior to this
revision, the name of this context param was incorrectly specified as
javax.faces.DECORATORS. The reference implementation has always used the
correct name, however.

http://java.net/jira/browse/JAVASERVERFACES_SPEC_PUBLIC-1010 +
Check existing usages of the state saving method parameter to ensure
case insensitivity.

http://java.net/jira/browse/JAVASERVERFACES_SPEC_PUBLIC-1004

M usingFacesInWebapps.fm

- 12.1.3 Set default for
javax.faces.FACELETS_BUFFER_SIZE to be 1024.

http://java.net/jira/browse/JAVASERVERFACES_SPEC_PUBLIC-998 +
Additional clarification about binding attribute in VDLdocs

http://java.net/jira/browse/JAVASERVERFACES_SPEC_PUBLIC-915
http://java.net/jira/browse/JAVASERVERFACES_SPEC_PUBLIC-1015
Non-normative text about http methods and prefix mapping

http://java.net/jira/browse/JAVASERVERFACES-2740 +
In link:JSF.html#a923[See Component Bindings], clarify a corner
case regarding bean scope and component binding.

Resources

=== Larger Changes

http://java.net/jira/browse/JAVASERVERFACES_SPEC_PUBLIC-809 +
This commit introduces a cleaner contract for allowing views to be
loaded from the Filesystem (including inside of JAR files). All VDL
resources must be loaded using ResourceHandler.createViewResource().

=== Smaller Changes

http://java.net/jira/browse/JAVASERVERFACES_SPEC_PUBLIC-996

Enable configuring the web app resources
directory. See link:JSF.html#a6088[See Application Configuration
Parameters].

http://java.net/jira/browse/JAVASERVERFACES_SPEC_PUBLIC-719 +
Method to map a viewId to a resourcePath

{empty}http://java.net/jira/browse/JAVASERVERFACES_SPEC_PUBLIC-1130-SerializeServerState +
Modify link:JSF.html#a4135[See State Saving Alternatives and
Implications] to clarify there is no requirement to serialize server
state by default when state saving method is server. Introduce a context
parameter to this effect in link:JSF.html#a6088[See Application
Configuration Parameters]

Expression Language

http://java.net/jira/browse/JAVASERVERFACES_SPEC_PUBLIC-1092

Remove text from
MethodExpressionValueChangeListener and MethodExpressionActionListener
regarding wrapping any exception thrown by the invoked method being
wrapped in an AbortProcessingException. Such a requirement is incorrect
and should not have been introduced.

In section link:JSF.html#a3253[See
ExceptionHandler], add _AbortProcessingException_ , to the list of
exceptions that do not get to the _ExceptionHandler_ .

http://java.net/jira/browse/JAVASERVERFACES_SPEC_PUBLIC-1043 +
When publishing a ComponentSystemEvent, ensure the EL current component
is pushed correctly

http://java.net/jira/browse/JAVASERVERFACES_SPEC_PUBLIC-1164 +
If running in a container that supports EL 3.0, add the necessary
ELResolvers. See link:JSF.html#a2966[See Stream, StaticField,
Map, List, Array, and Bean ELResolvers].

Configuration and Bootstrapping

http://java.net/jira/browse/JAVASERVERFACES_SPEC_PUBLIC-533-ProgrammaticFacesConfig

Modify link:JSF.html#a6201[See
Application Startup Behavior] to account for requirement to call new API
when starting up.

Miscellaneous

http://java.net/jira/browse/JAVASERVERFACES_SPEC_PUBLIC-1169

New XML Namespace for XSD files introduced in
JSF 2.2, and also for facelet tag libraries.

The following XSD files are new for JSF 2.2,
and each will be in the XML namespace
_http://xmlns.jcp.org/xml/ns/javaee_ .

 _web-facelettaglibrary_2_2.xsd_

 _web-facesconfig_2_2.xsd_

 _web-partialresponse_2_2.xsd_

Facelet Tag Libraries will now respond to the
following URIs

[width="100%",cols="34%,33%,33%",options="header",]
|===
|Library |Old URI
|New URI
|Composite Components
|http://java.sun.com/jsf/composite a|
http://xmlns.jcp.org/jsf/composite



|Faces Core
|http://java.sun.com/jsf/core a|
http://xmlns.jcp.org/jsf/core



|HTML_BASIC
|http://java.sun.com/jsf/html a|
http://xmlns.jcp.org/jsf/html



|JSTL Core a|
http://java.sun.com/jsp/jstl/core



a|
http://xmlns.jcp.org/jsp/jstl/core



|JSTL Functions
|http://java.sun.com/jsp/jstl/functions a|
http://xmlns.jcp.org/jsp/jstl/functions



|Facelets Templating
|http://java.sun.com/jsf/facelets a|
http://xmlns.jcp.org/jsf/facelets



|Pass Through Attributes
|http://java.sun.com/jsf/passthrough a|
http://xmlns.jcp.org/jsf/passthrough



|Pass Through Elements
|http://java.sun.com/jsf a|
http://xmlns.jcp.org/jsf



|===

Developers are requested to use the values
from the New URI column, though both columns will work.

http://java.net/jira/browse/JAVASERVERFACES_SPEC_PUBLIC-997

M
jsf-api/src/main/java/javax/faces/event/ComponentSystemEvent.java

Override isAppropriateListener so that it
first asks the listener, "are you a ComponentSystemEventListener", then,
if not, asks super.isAppropriateListener()

M
jsf-api/src/main/java/javax/faces/event/SystemEvent.java

in isAppropriateListener(), document the
default implementation.

M
jsf-api/src/main/java/javax/faces/component/UIComponent.java

Make inner class
ComponentSystemEventListenerAdapter implement
ComponentSystemEventListener.

http://java.net/jira/browse/JAVASERVERFACES_SPEC_PUBLIC-917

javax.faces.application.ResourceWrapper:

 - getContentType()

 - getLibraryName()

 - getResourceName()

 - setContentType(String)

 - setLibraryName(String)

 - setResourceName(String)

 javax.faces.context.ExternalContextWrapper:

 - getSessionMaxInactiveInterval()

 - isSecure()

 - setSessionMaxInactiveInterval()


javax.faces.context.PartialViewContextWrapper

 - setPartialRequest(boolean)

12.1.3 add this text to the
javax.faces.STATE_SAVING_METHOD spec. When examining the value, the
runtime must ignore the case.

Add
ExternalContext.getApplicationContextPath()
http://java.net/jira/browse/JAVASERVERFACES_SPEC_PUBLIC-1012

http://java.net/jira/browse/JAVASERVERFACES_SPEC_PUBLIC-787 +
restore ViewScope before templates are processed with buildView()

7.6.2.6 typo in spec for renderView(). Should
be

Return immediately if calling isRendered() on
the argument UIViewRoot returns false.

Per Matt Benson, remove duplicate
descriptions of the cc and component implicit object from the getValue()
specification for the composite component ELResolver in section 5.6.2.1.

http://java.net/jira/browse/JAVASERVERFACES_SPEC_PUBLIC-869

Specify Cross Site Request Forgery
protection.

Add text in link:JSF.html#a404[See
Restore View] to describe how non-postback requests are inspected for
protection, if necessary.

Remove text for writeState() in
link:JSF.html#a4288[See ResponseStateManager], point to the
JavaDocs.

Add View Protection methods to
link:JSF.html#a3874[See Overview] for ViewHandler.

Introduce subsections to
link:JSF.html#a3910[See Default ViewHandler Implementation] that
group the methods by their purpose. Add a new section
link:JSF.html#a3997[See ViewHandler Methods that relate to View
Protection], which points to the javadocs. In
link:JSF.html#a3955[See ViewHandler Methods Relating to
Navigation], in the spec for _getActionUrl()_ , specify how view
protection is affected.

{empty}Remove tables in section
link:JSF.html#a6598[See Requirements for scanning of classes for
annotations]

The Javadoc tool lists annotations in a
separate section, making the tables that list JSF related annotations
redundant.

.

http://java.net/jira/browse/JAVASERVERFACES_SPEC_PUBLIC-1082-DoctypeElement

Add new section
link:JSF.html#a5635[See DOCTYPE and XML Declaration].

http://java.net/jira/browse/JAVASERVERFACES_SPEC_PUBLIC-1141-SlashInResourceNames

In link:JSF.html#a758[See Resource
Identifiers], declare that resourceName and resourceVersion, in addition
to the already listed other segments, are subject to the same
constraints.

http://java.net/jira/browse/JAVASERVERFACES_SPEC_PUBLIC-1129-ResetValues

In link:JSF.html#a480[See Render
Response Partial Processing], require calling _UIViewRoot.resetValues()_
if necessary.

=== Backward Compatibility with Previous Versions

Faces 2.2 is backwards compatible with Faces
2.1 and 2.0. This means that a web-application that was developed to run
with Faces 2.1 or 2.0 won’t require any modification when run with Faces
2.2 except in the cases described in the following section.

=== Breakages in Backward Compatibility

http://java.net/jira/browse/JAVASERVERFACES_SPEC_PUBLIC-1092

Due to an error in previous versions of the
specification, exceptions were silently being swallowed that now will
bubble up to the exception handler. Code that was relying on this
incorrect behavior may need to be modified to account for fixing this
problem.

http://java.net/jira/browse/JAVASERVERFACES_SPEC_PUBLIC-745

5.6.2.2 Table 5-11. Make the following
changes to the spec for Composite Component Attribute ELResoler

Modify getType() according to new
specification language.

Require the implementation of containsKey()
on the Map.

containsKey(): If the attributes map contains
the key, return true. Otherwise, if a default value has been declared
for the attribute, return true. Otherwise, return false.

{empty}link:JSF.html#a1671[See
Composite Component Metadata]

New text dealing with <cc:attribute>

Any additional attributes on
_<composite:attribute/ >_ are exposed as attributes accessible from the
_getValue()_ and _attributeNames()_ methods on _PropertyDescriptor_ .
The return type from getValue() must be a _ValueExpression_ with the
exception of the _getValue(“type”)_ . The return type from
_getValue(“type”)_ must be _Class_ . If the value specified for the
_type_ attribute of _<cc:attribute/>_ cannot be converted to an actual
_Class_ , a _TagAttributeException_ must be thrown, including the _Tag_
and _TagAttribute_ instances in the constructor.

Yes, this is a backwards incompatible change,
but because the usecase is so specific, and the performance benefit so
substantial, it was judged to be worth the cost.



=== 

image:SF-63.png[image]

Changes between 2.0 Rev a and 2.1

=== link:JSF.html#a5638[See Facelet Tag Library mechanism]

Document that the unprefixed namespace must
pass through.

=== New feature: <facelets-processing>

{empty}link:JSF.html#a7040[See
Required Handling of *-extension elements in the application
configuration resources files]

=== Update schema for 2.1

The only new element is
<facelet-cache-factory>. See the full schema in the Javadoc section of
the documents.

=== Change Restore View Phase

Change link:JSF.html#a404[See
Restore View] to require a call to _ViewHandler.deriveLogicalViewId()_
before trying to find the _ViewDeclarationLanguage_ .

=== link:JSF.html#a3910[See Default ViewHandler Implementation]

Document _deriveLogicalViewId()._

=== 

image:SF-63.png[image]

Changes between 2.0 Final and 2.0 Rev a

=== Global changes

ExceptionQueuedEvent

The specification incorrectly refers to the
ExceptionQueuedEvent as the ExceptionEvent. All instances should be
replaced, as there is no such class ExceptionEvent in JSF.

Usage of the term "page" in the JSF 2.0 spec

This might be kind of nit-picky, but there
are several occurrences of the term "Facelet page" in the JSF 2.0 spec,
but I'd like to set forth the argument that the term "Facelet document"
or "Facelet view" would be more appropriate, depending on context.
Similarly, the spec uses the term "Composite component markup page"
which isn't always appropriate either. Better to call it a "Composite
component markup document" or something like that.

All Facelet XHTML files are documents, but
not all Facelet XHTML files are pages. There is a built-in bias to the
word "page" that assumes the markup output will be rendered as a "web
page" which is not always the case. In the case of portlets, the
rendered output is a fragment of markup (normally a <div>...</div>). In
the case of a custom renderkit, the rendered output might be some mobile
device. In the case of ICEfaces, the rendered markup is a server-side
DOM tree. In the case of a composite component, a Facelet XHTML file is
not a page, but a "Composite Component markup document" (or definition)
file.

For example.. Instead of a "Facelet Page", I
think the following should be called a "Facelet Document" or a "Facelet
View" (since the f:view tag is optional, but implied)

<html xmlns="http://www.w3.org/1999/xhtml"

 xmlns:h="http://java.sun.com/jsf/html"

 xmlns:f="http://java.sun.com/jsf/core"


xmlns:ez="http://java.sun.com/jsf/composite/ezcomp">

 <h:head>

 <title>A simple example of EZComp</title>

 </h:head>

 <h:body>

 <h:form>

 </h:form>

 </h:body>

</html>

But in the case of Portlets, the <html> ,
<head>, and <body> tags are forbidden. The equivalent "Facelet Document"
or "Facelet View" for portlets would look like this:

<f:view xmlns="http://www.w3.org/1999/xhtml"

 xmlns:h="http://java.sun.com/jsf/html"

 xmlns:f="http://java.sun.com/jsf/core"


xmlns:ez="http://java.sun.com/jsf/composite/ezcomp">

 ...

</f:view>

=== Front Matter

Change Sun logo to Oracle Logo. Sun postal
address to Oracle postal address, and Sun phone number to Oracle phone
number

Update spec license.

=== Chapter 2

{empty}link:JSF.html#a404[See
Restore View]

Per Andy Schwartz recommendation, loosen the
spec requirements for the delivery of the PostRestoreStateEvent to be
"somewhere during RestoreView".

{empty}link:JSF.html#a584[See
Localized Application Messages]

Suggestion: Change to

Validation Error: Length is less than
allowable minimum of 5.

{empty}link:JSF.html#a710[See JSR
303 Bean Validation]

Change "leas" to "least"

link:JSF.html#a710[See JSR 303 Bean
Validation]needs to reference "Bean Validation Integration" section

While reading section 2.5.7, one becomes very
disappointed with the limited about of information that it provides. But
section 3.5.6 provides more information, so the recommendation is that
these sections reference eachother, or perhaps are combined in some way
if that makes sense.

{empty}link:JSF.html#a758[See
Resource Identifiers]

Tighten spec for the localePrefix,
libraryName, and resourceVersion segments of the resource identifier.

=== Chapter 3

{empty}Clarify meaning of "javax.faces.bean"
in link:JSF.html#a1464[See Bean Validator Activation]

Section 3.5.6.1 says:

"If Bean Validation is present in the runtime
environment, the system must ensure that the javax.faces.Bean standard
validator is added with a call to Application.addDefaultValidatorId()"

But the reader of the Spec has no idea what
the "javax.faces.Bean" standard validator is, within the context of this
paragraph. Recommend adding some verbiage that says that
javax.faces.Bean is the validatorId of the standard JSR 303 validator of
the JSF 2.0 API, which equates to the
javax.faces.validator.BeanValidator class as mentioned in Section
10.4.1.4.

Need to be consistent between
link:JSF.html#a1393[See Declarative Listener Registration]of the
JSF 2.0 Spec and the VDLDoc for f:event

Section 3.4.3.4 of the JSF 2.0 Spec reads:

The method signature for the MethodExpression
pointed to by the listener attribute must match the signature of

javax.faces.event.ComponentSystemEventListener.processEvent().

And the VDLDocs for f:event read:

(signature must match public void
listener(javax.faces.event.ComponentSystemEvent event) throws
javax.faces.event.AbortProcessingException)

Both of these are true, and indeed saying the
same thing. But I think it would be helpful to say BOTH things, in BOTH
documents.

Typo in link:JSF.html#a1393[See
Declarative Listener Registration] of the JSF 2.0 Spec regarding
"beforeRender"

Section 3.4.3.4 of the JSF 2.0 Spec has this
example:

<h:inputText value="#\{myBean.text}">

 <f:event type="beforeRender"
listener="#\{myBean.beforeTextRender}" />

</h:inputText>

But "beforeRender" is a typo. The correct
value is "preRenderComponent" as stated in the f:event VDLDocs.

{empty}link:JSF.html#a1419[See
Validation Registration], link:JSF.html#a1518[See What does it
mean to be a JSF User Interface component?]

Remove references to UInput.encodeEnd(). Not
for a very long time has this method been used to instigate validation.

{empty}link:JSF.html#a1671[See
Composite Component Metadata]

Section 3.6.2.1 of the Spec indicates that
the "hidden" property of the javax.bean.FeatureDescriptor is to appear
as an attribute for tags like composite:actionSource,
composite:attribute, composite:facet, and composite:interface but the
VDLDocs do not declare that the "hidden" property is available.

=== Chapter 4

{empty}link:JSF.html#a2268[See
Events]

Remove text pertaining to
PostRestoreStateEvent, rely instead on text in setion 2.2.1.

Chapter 7

{empty}link:JSF.html#a3562[See
Overview]

getNavigationCase should return
NavigationCase and not void.

{empty}link:JSF.html#a3571[See
Default NavigationHandler Algorithm]

Add faces-include-view-params

{empty}link:JSF.html#a3910[See
Default ViewHandler Implementation]

Fix typo the specified createView() should be
called in renderView() and restoreView().

=== Chapter 9

link:JSF.html#a4654[See
<f:actionListener>] of Spec PDF -- Missing "for" attribute of
f:actionListener in Spec PDF

The example for f:selectItems includes a
noSelectionValue attribute, but that attribute isn't documented. VDLDocs
for f:selectItems does not document the noSelectionValue attribute.

Actually, it does document it, but it only
looks like it doesn't. It seems as though the itemLabelEscaped attribute
is documented twice, but really the second occurance is the
noSelectionValue.

{empty}link:JSF.html#a4654[See
<f:actionListener>] and link:JSF.html#a5282[See
<f:valueChangeListener>]

Add this non-normative text.

Note that if the binding attribute is used,
the scope of the ValueExpression must be chosen carefully so as not to
introduce undesireable results. In general, when using the binding
attribute, do not point to beans in request or narrower scope.

=== Chapter 10

Need to change "confirm with" to "conform
with".

Confusing verbiage in table 10-1 of JSF 2.0
spec regarding the word "template"

In table 10-1, it correctly says that "page
templating" is not a feature of JSP.

But later on in the table, it says
"Expressions in template text cause unexpected behavior when used in
JSP."

Somehow there needs to be an explanation of
the distinction of "page templating" and "template text" here. Right now
it kind of reads as a contradiction.

{empty}link:JSF.html#a5632[See
General Requirements]

Add an assertion to section 10.3.1 stating
that EL expressions that appear in the facelet XHTML page must appear in
the rendered view as if they were the right hand side of the value
attribute of an at the same point in the page as the EL expression

{empty}link:JSF.html#a5638[See
Facelet Tag Library mechanism]

Section 10.3.2. Correct xref to point to
section in appendix that includes the facelet taglib schema.

Correct xref to point to section in appendix
that includes the facelet taglib schema.

VDLDocs and PDL documentation

link:JSF.html#a6043[See
Facelet Templating Tag Library],
link:JSF.html#a6043[See Facelet
Templating Tag Library], and link:JSF.html#a6047[See JSTL Core
and Function Tag Libraries] refer the reader to the "VDLDocs" for
Facelet, CC, and JSTL tag libraries respectively.

However, when one checks out the Mojarra
2.0.0 Beta 2 page, it talks about the "PDL" tag library documentation.
Also, when one clicks on the "PDL Documentation for Facelets2", it uses
the term "PDL" in several places.

So it looks like the View Declaration
Language (VDL) terminology hasn't made its way into the tag library docs
yet.

Possible error in section
link:JSF.html#UNKNOWN[See <f:ajax>] of the JSF 2.0 Spec regarding
f:ajax and h:panelGrid

Section 10.4.1.1, shows this example:

<f:ajax>

 <h:panelGrid>

 <h:inputText id=˝text1˝/>

 <h:commandButton id=˝button1˝/>

 </h:panelGrid>

 </f:ajax>

And then has the following about the example:

<h:panelGrid> has no default event so in this
case a behavior would not be applied.

BUT the very next example is this:

<f:ajax event=˝click˝>

 <h:panelGrid id=˝grid1˝>

 <h:inputText id=˝text1˝/>

 <h:commandButton id=˝button1˝>

 <f:ajax event=˝mouseover˝/>

 </h:commandButton>

 </h:panelGrid>

 </f:ajax>

And then has the following comment:

From this example, grid1˝ and text1˝ would
have ajax behavior applied for an onclick˝ event

So... which is it? Does h:panelGrid get ajax
behavior or not? Can an HTML table have an "onclick" JavaScript event?

Redundant mentioning of Facelets in
link:JSF.html#a5828[See <f:validateBean>] of the JSF 2.0 Spec

Since the parent section (10.4.1) indicates
that sub-sections are Facelets-only in nature, then it is not necessary
to have (Facelets only) in the "Constraints" paragraph of Section
10.4.1.4 of the spec.

Availability of f:validateBean and
f:validateRequired in JSP

link:JSF.html#a5691[See Standard
Facelet Tag Libraries] outlines the f: namespaced tags that are only
applicable to Facelets (and not JSP). In that section, f:validateBean,
and f:validateRequired are listed. However, they are both listed as
working with JSP as well (kind of like f:validateRegex), as can be seen
from the JSP TLDDocs.

According to Dan Allen: "those tags only work
partially in JSP. Yes, they work as single field validators. But the
branch validator capability does not work (wrapping the validator tag
around a branch). The later feature is Facelets only. So the validators
do have their feet in both ponds, but only Facelets has full support. I
suppose we could mention this tidbit in the JSP section."

Dan is correct that it should be mentoned in
the JSP section, but also, that f:validateBean and f:validateRequired
belong in both Section 10.4 and 9.4, with the limits of their
functionality described in each section.

=== Chapter 13

Redundancy in
link:JSF.html#a6831[See Partial View
Processing] of the JSF 2.0 Spec

Section 13.4.2 of the JSF 2.0 spec has this
sentence:

The request contains special parameters that
indicate the request is a partial execute request or a partial execute
request that was triggered using Ajax

This needs clarification -- does this mean to
say:

partial execute request (not triggered by
Ajax) or a partial execute request (that was triggered using Ajax)

"Execute portions" of the JSF request
processing lifecycle in the JSF 2.0 Spec

Section 13.4.2 reads:

Although the diagram in Section 13.4 Partial
View Traversal˝ depicts the execute˝ portion as encompassing everything
except the Render Response Phase˝, it really is the Apply Request Values
Phase˝, Update Model Values Phase˝ and Process Validations Phase˝.

Why does the diagram include the
INVOKE_APPLICATION phase if it's not "really" considered to be part of
the execute portions?

=== Chapter 14

link:JSF.html#a6856[See
Initiating an Ajax Request] Typo in table 14.2.2 of the JSF 2.0 Spec

Table 14.2.2 reads:

"execute" phase

But in order to be consistent with the rest
of the spec, it should read:

"execute" portion

Also, the same goes for "render" in that the
word "portion" should be used instead of "phase".

link:JSF.html#a6933[See
Request/Response Event Handling]Table 14.4.1

Change responseTxt to responseText.

Table 14.3: Reorder rows

=== Appendix A Metadata

Update schema to remove partial-traversal, as
well as fixing 768.

{empty}link:JSF.html#a7139[See
Deprecated DTD for Facelet Taglibraries Used by Versions of Facelets
Prior to JSF 2.0]

To ease migration for Facelet taglibraries
declared using pre-JSF 2.0 versions of Facelets, implementations must
support loading facelet taglibrary files that conform to the pre-JSF 2.0
Facelets DTD. Per DTD conventions, Facelet taglibrary files declare
conformance to this DTD by including text similar to the following in at
the top of their declaring file.

<!DOCTYPE facelet-taglib PUBLIC

"-//Sun Microsystems, Inc.//DTD Facelet
Taglib 1.0//EN"

"http://java.sun.com/dtd/facelet-taglib_1_0.dtd">

Use of this DTD is officially deprecated.
This DTD is included for reference in Section 1.2.1 "Deprecated DTD for
Facelet Taglibraries Used by Versions of Facelets Prior to JSF 2.0". It
is expected that proper JSF 2.0 Facelet Taglibraries will declare
conformance to the following schema, rather than the deprecated DTD.

=== VDLDoc changes

Typo in f:selectItems VDLDocs

Change "mest" to "must"

Need clarification on execute attribute of
f:ajax

The VDLDocs for f:ajax say "Identifiers of
components" but, for some reason, it wasn't obvious to me that this term
referred to the "id" attributes of components. The recommendation isthat
this be clarified to say "list of <b>id</b> attribute values" instead.
Also, the value of an id attribute like "mycomponent" or something
should be added to an example that includes a keyword... something like
this: "@this componentone componenttwo"

Spelling error in VDLDocs for f:ajax

This one from Lincoln:

See the "onerror" attribute

There is an extra 'e' -> "oneerror"

Need clarification on required attribute in
VDLDocs for tags that got a new "for" attribute in JSF 2.0

The VDLDocs correctly have green for the new
"for" attribute, but the "required" column says false, when that's not
always the case.

For example, with f:actionListener the
VDLDocs say that that it is not required. However, when the tag is used
as a child of a Composite Component, then the for attribute is indeed
required. This would be true of all tags like that, such as
f:convertDateTime, f:convertNumber, etc.

Uppercase typo in VDLDocs for f:event

Change uppercase "P" to lowercase for:
PostAddToView for the f:event VDLDocs

Need to change "JSP" to "Facelets" in "Body
Content" of VDLDocs

Search for "JSP" on the f:event VDLDocs [1].
My suspicion is that this is a problem across the board.

Need clarification in VDLDocs for f:metadata

In the VDLDocs for f:metadata, recommend
changing:

"This tag must reside within the top level
XHTML file for the given viewId, not in a template"

to this:

"This tag must reside within the top level
Facelet view, or in a template-client, but not in a template"

Also, it needs to be clarified that the
page01.xhtml example is a template-client. So recommend changing this:

"viewId XHTML page, page01.xhtml"

to this:

"template-client XHTML page, page01.xhtml"

Missing description in VDLDocs for name
attribute of f:viewParam

The VDLDocs for f:viewParam are missing
documentation of the "name" attribute, which is pretty important since
it is required.

VLDDocs on "for" attribute of f:viewParam
claim it can be used in a CC

The VDLDocs for f:viewParam claim that the
"for" attribute is supported. I just checked Mojarra's jsf-api and
UIViewParameter.java does not support the "for" attribute, since it does
not have a getter/setter for "for" like HtmlOutputLabel does. There are
restrictions on f:viewParam such that it may only be used inside of
f:metadata, and f:metadata may only be used inside of f:view. So that
disqualifies the f:viewParam tag from being able to be used inside of a
Composite Component. Therefore I recommend that the documentation of the
"for" attribute be totally removed.

Miscellaneous VDLDoc items

VDLDocs for "execute" attribute of f:ajax say
(must evaluate to java.lang.Object) but then say "Evaluates to
Collection"

VDLDocs f:selectItem lists the new JSF 2.0
"noSelectionOption" but is not colored green to indicate "new in JSF
2.0" and the link for f:selectItem in the navigation frame needs to be
orange

VDLDocs for f:validateBean should have all of
its attributes in green to indicate "new in JSF 2.0" since it is a new
tag.

VDLDocs for f:validateRegex has a typo in the
description which reads "RegexpValidator" rather than "RegexValidator"

In spec, the "Changes between 1.2 and EDR2"
section refers the reader to section 3.5.2 for the addition of
"javax.faces.RegularExpressionValidator" but actually it should be
section 3.5.5

VDLDocs for h:button say that the outcome
attribute is not required, but really it should be required otherwise
there is no purpose of f:button -- you would end up navigating back to
the current view. The whole point of f:button is to perform navigation
to a different view that potentially contains view parameters. Why have
a bookmarkable URL back to itself?

VDLDocs for h:button don't mention a disabled
attribute, but the h:link one does have the disabled attribute. My guess
would be that both should have this attribute?

VDLDocs for h:outputScript and
h:outputStylesheet should indicate that even though the UIOutput class
implements the ValueHolder interface, the coverter and value attributes
are basically ignored by the renderers, since the value attribute has no
meaning. This is basically a design flaw -- a new class named
UIOutputResource should have been created instead of UIOutput being
reused.

{empty}VDLDocs for h:outputScript and
h:outputStylesheet should indicate that the "name" attribute is
required, since section 2.6.1.3 implies that this is the case with the
following resource pattern:
[localePrefix/][libraryName/][libraryVersion/]resourceName[/resourceVersion]

VDLDocs for h:outputScript needs to have all
the possible values for the target attribute documented. I think the
only valid values are "head", "body", and "form"

VDLDocs for h:graphicImage has a dead
hyperlink to "Common Algorithm for Obtaining A Resource to Render

VDLDocs for h:selectManyCheckbox indicate
orange for the collectionType and hideNoSelectionOption attributes but
they should be green to indicate "new in JSF 2.0"

VDLDocs for h:selectManyCheckbox says that
the return type must evaluate to a String, but that's not entirely true.
It can also evaluate to a concrete class that implements
java.util.Collection

VDLDocs for ui:param have two "name"
attributes specified. The second one should be the "value" attribute

Should TLDDocs now be VDLDocs?

The Spec introduces this term VDLDocs (which
as I said in the other email, was formerly PDLDocs), but it also refers
the reader to the TLDDocs. Should we just settle on VDLDocs as the
standard term throughout the Spec?

Typo in VDLDocs for f:event.

The VDLDocs for f:event specify a "name"
attribute, but the Description column of the page talks about a "type"
column (not "name"), which would be consistent with Section 3.4.3.4 of
the Spec which talks about a "type" column.

Jim Driscoll verified that there is a doc bug
in the VDLDocs for f:event and that the "name" attribute is actually
"type"

=== Accepted Changes from JCP Change Log for JSF 2.0 Rev a

The referenced spec public issue number can
be found in the issue tracker at +
https://javaserverfaces-spec-public.dev.java.net/servlets/ProjectIssues





[width="100%",cols="20%,20%,20%,20%,20%",]
|===
|ID |Category
|Description
|Fixed in Source Code Repository of
Specification |Issue

|C002 |Errata
|Section 5.6.2.2 is out of sync with the
current resolver implementation. |yes
|
_https://javaserverfaces-spec-public.dev.java.net/issues/show_bug.cgi?id=848[Spec
Public:848]_

|C004 |Errata
|RenderKitDoc for _OutcomeTarget_ Renderers
are incorrect with respect to intended design. Refer to
_link:appendixB-changelog.html#UNKNOWN[]ChangeC006_ in the
footnotes section below. |yes
|
_https://javaserverfaces-spec-public.dev.java.net/issues/show_bug.cgi?id=823[Spec
Public:823]_

|C007 |Errata
|Section JSF.11.4.7 Ordering. After the
sentence "The <others /> element must be handled as follows" add a
bullet point: "The <others /> element represents a set of application
configuration resources. This set is described as the set of all
application configuration resources discovered in the application minus
the one currently being processed, minus the application configuration
resources mentioned by name in the <ordering /> section. If this set is
the empty set, at the time the application configuration resources are
being processed, the <others > element must be ignored."
|yes |
_https://javaserverfaces-spec-public.dev.java.net/issues/show_bug.cgi?id=824[Spec
Public:824]_

|C008 |Errata
|taglib docs for composite:interface are
missing documentation for _componentType_ attribute.
|yes |
_https://javaserverfaces-spec-public.dev.java.net/issues/show_bug.cgi?id=849[Spec
Public:849]_

|C011 |Errata
|Section JSF.3.6.2.1 Composite Component
Metadata Specification. Add _BehaviorHolderAttachedObjectTarget_ after
iii. _ActionSource2AttachedObjectTarget_ |yes
|
_https://javaserverfaces-spec-public.dev.java.net/issues/show_bug.cgi?id=825[Spec
Public:825]_

|C012 |Errata
|Javadocs for
_ResourceHandler.createResource(String resourceId)_ need to me ammended
to state that if there is an error in argument resourceId, null must be
returned by this method. |yes
|
_https://javaserverfaces-spec-public.dev.java.net/issues/show_bug.cgi?id=851[Spec
Public:851]_

|C013 |Errata
|PDL DOCS: f:event listener attribute
clarification:Change description to: "A method expression that JSF
invokes when an event occurs. That event is specified with the name
attribute." |yes |
_https://javaserverfaces-spec-public.dev.java.net/issues/show_bug.cgi?id=586[Spec
Public:586]_

|C015 |Errata
| _UIViewRoot.setBeforePhaseListeners()_
removed the statement that all phases including _RestoreView_ will have
their _beforePhaseListeners_ called. Reverted to the way it was in 1.2
|yes |
_https://javaserverfaces-spec-public.dev.java.net/issues/show_bug.cgi?id=826[Spec
Public:826]_

|C016 |Errata
|Section 2.6.2.1 Relocatable Resources: code
snippet: <f:view..../> should be <f:view...>
|yes |
_https://javaserverfaces-spec-public.dev.java.net/issues/show_bug.cgi?id=565[Spec
Public:565]_

|C017 |Errata
| _UISelectItem_ doesn't mention
_itemEscaped_ . |yes
|
_https://javaserverfaces-spec-public.dev.java.net/issues/show_bug.cgi?id=430[Spec
Public:430]_

|C018 |Errata
|
_ViewDeclarationLanguage.retargetAttachedObjects()_ misses talking about
Behaviors |yes |
_https://javaserverfaces-spec-public.dev.java.net/issues/show_bug.cgi?id=827[Spec
Public:827]_

|C021 |Errata
|ui:insert missing existing "name" attribute,
implemented, tested, but not documented |yes
|
_https://javaserverfaces-spec-public.dev.java.net/issues/show_bug.cgi?id=667[Spec
Public:667]_

|C022 |Errata
| _f:valueChangeListener_ missing "for"
attribute. Implemented, tested, but not documented
|yes |
_https://javaserverfaces-spec-public.dev.java.net/issues/show_bug.cgi?id=828[Spec
Public:828]_

|C023 |Change
|in facelets VDLdoc, mark f:verbatim and
f:subview as deprecated |no
|
_https://javaserverfaces-spec-public.dev.java.net/issues/show_bug.cgi?id=852[Spec
Public:852]_

|C024 |Errata
|Add an assertion to section 10.3.1 stating
that EL expressions that appear in the facelet XHTML page must appear in
the rendered view as if they were the right hand side of the value
attribute of an _<h:outputText>_ at the same point in the page as the EL
expression |yes |
_https://javaserverfaces-spec-public.dev.java.net/issues/show_bug.cgi?id=829[Spec
Public:829]_

|C027 |Errata
|web-facelettaglibrary_2_0.xsd type incorrect
for composite-library-name. Should be ***javae:string***
|no |
_https://javaserverfaces-spec-public.dev.java.net/issues/show_bug.cgi?id=854[Spec
Public:854]_

|C028 |Errata
| _ui:remove_ VDLDoc has attribute with no
name |no |
_https://javaserverfaces-spec-public.dev.java.net/issues/show_bug.cgi?id=842[Spec
Public:842]_

|C029 |Errata
| _ui:param_ has attribute duplicated. One of
them should be "value" |yes
|
_https://javaserverfaces-spec-public.dev.java.net/issues/show_bug.cgi?id=855[Spec
Public:855]_

|C030 |Errata
|RenderKit Docs _javax.faces.CompositeFacet_
change " The implementation of _encodeBegin()_ , must obtain " to be "
The implementation of _encodeChildren()_ , must obtain "
|no |
_https://javaserverfaces-spec-public.dev.java.net/issues/show_bug.cgi?id=843[Spec
Public:843]_

|C031 |Errata
|VDL docs state that _composite:attribute_
has a target attribute with _required=true_ . This attribute is not
really required on _composite:attribute_ .
|yes |
_https://javaserverfaces-spec-public.dev.java.net/issues/show_bug.cgi?id=644[Spec
Public:644]_

|C032 |Errata
|Mention in spec that Objects put in view
scope may need to be Serializable |yes
|
_https://javaserverfaces-spec-public.dev.java.net/issues/show_bug.cgi?id=830[Spec
Public:830]_

|C033 |Errata
|Modify the javadoc for _ResourceHandler_ to
state that for resources residing at
_META-INF/resources/<resourceidentifier>_ . The implementation is not
required to support the optional _libraryVersion_ and _resourceVersion_
segments |yes |
_https://javaserverfaces-spec-public.dev.java.net/issues/show_bug.cgi?id=844[Spec
Public:844]_

|C034 |Change
|Modify table 5-10 to state that implicit
object cc returns the current composite component, relative to the
composite component markup page in which the expression appears
|yes |
_https://javaserverfaces-spec-public.dev.java.net/issues/show_bug.cgi?id=831[Spec
Public:831]_

|C035 |Errata
|3.6.2.1 Modify composite component metadata
specification to state that, within the _cc:interface_ element, the
following attributes are not available unless _ProjectStage_ is
_Development_ : displayName, expert, hidden, preferred, shortDescription
|yes |
_https://javaserverfaces-spec-public.dev.java.net/issues/show_bug.cgi?id=832[Spec
Public:832]_

|C037 |Errata
| _UIComponent.restoreState()_ javadocs must
be changed to ***say*** NPE is thrown if context is null, but no action
is taken if state argument is null |yes
|
_https://javaserverfaces-spec-public.dev.java.net/issues/show_bug.cgi?id=845[Spec
Public:845]_

|C040 |Errata
|VDLDocs for _f:metadata_ . Don't mention
_f:view_ . State, "This tag must reside within the top level facelet
page whose filename corresponds ot the _viewid_ being loaded."
|yes |
_https://javaserverfaces-spec-public.dev.java.net/issues/show_bug.cgi?id=856[Spec
Public:856]_

|C043 |Errata
|Document _SEPARATOR_CHAR_ in section 11.1.3
where all the other context-params are documented
|yes |
_https://javaserverfaces-spec-public.dev.java.net/issues/show_bug.cgi?id=833[Spec
Public:833]_

|C044 |Errata
|Section 11.4.6 doesn't include
_ViewDeclarationLanguage_ , _VisitContextFactory_ ,
_ExceptionHandlerFactory_ , _PartialViewContext_ ,
_TagHandlerDelegateFactory_ as decoratable
|yes |
_https://javaserverfaces-spec-public.dev.java.net/issues/show_bug.cgi?id=834[Spec
Public:834]_

|C046 |Errata
|Section 10.4.1.1 specifies the use of
_AjaxBehaviors pushBehavior_ but _AjaxBehaviors_ is an implementation
detail (the class exists under com package)
|yes |
_https://javaserverfaces-spec-public.dev.java.net/issues/show_bug.cgi?id=836[Spec
Public:836]_

|C047 |Errata</TD
|Add "defaults" for "execute", "render"
_AjaxBehavior_ in vdldocs. |yes
|
_https://javaserverfaces-spec-public.dev.java.net/issues/show_bug.cgi?id=568[Spec
Public:568]_

|C048 |Errata
|JSP should not have _f:viewParam_ . Facelets
_f:viewParam_ must have _name_ attribute.
|yes |
_https://javaserverfaces-spec-public.dev.java.net/issues/show_bug.cgi?id=656[Spec
Public:656]_

|C049 |Errata
|Spec section 3.2.5 is empty. Fix that
|yes |
_https://javaserverfaces-spec-public.dev.java.net/issues/show_bug.cgi?id=835[Spec
Public:835]_

|C050 |Errata
|Spec for _UIComponent.setParent()_
incomplete |yes |
_https://javaserverfaces-spec-public.dev.java.net/issues/show_bug.cgi?id=837[Spec
Public:837]_

|C054 |Errata
| _f:event name_ attribute should be type.
|yes |
_https://javaserverfaces-spec-public.dev.java.net/issues/show_bug.cgi?id=639[Spec
Public:639]_

|C058 |Errata
|Section 14.4.1: Table 14-4: responseTxt
should be responseText. Table 14-4: Add _status_ property; Table 14-4:
There is no "name" property. Table 14-3: reorder "status" values to be
in chronological order. Section 14.4.1.1: Fix use case.
|yes |
_https://javaserverfaces-spec-public.dev.java.net/issues/show_bug.cgi?id=642[Spec
Public:642]_

|C060 |Change
|Replace the last sentence in the javadoc for
_FacesServlet.service()_ to say "The implementation must make it so
_FacesContext.release()_ is called within a finally block as late as
possible in the processing for the JSF related portion of this request".
|yes |
_https://javaserverfaces-spec-public.dev.java.net/issues/show_bug.cgi?id=846[Spec
Public:846]_

|C061 |Change
|Non-normatively document that JavaBeans
PropertyEditors will be used for EL Coercion. Mention this in the
context of JSF converters |yes
|
_https://javaserverfaces-spec-public.dev.java.net/issues/show_bug.cgi?id=838[Spec
Public:838]_

|C062 |Change
|In 3.1.5, explicitly mention not to use view
scope |yes |
_https://javaserverfaces-spec-public.dev.java.net/issues/show_bug.cgi?id=839[Spec
Public:839]_

|C063 |Change
|7.4.1 Clarify that, in the case of
navigation actions, an empty string should be treated the same way as
null: stay on the same page. |yes
|
_https://javaserverfaces-spec-public.dev.java.net/issues/show_bug.cgi?id=747[Spec
Public:747]_

|C064 |Change
|Correct _StateHolder.setTransient_ JavaDoc
(specified backwards) |yes
|
_https://javaserverfaces-spec-public.dev.java.net/issues/show_bug.cgi?id=840[Spec
Public:840]_

|C065 |Change
|Correct typos in _Composite.tld_ (for
pdldocs). Specifically, quotes around _actionListener_ ,
_method-signature_ (spelling). Also clarify the default value "false"
for "required" attribute. |yes
|
_https://javaserverfaces-spec-public.dev.java.net/issues/show_bug.cgi?id=841[Spec
Public:841]_

|C066 |Change
|Specify that the Component Resource
container facet must be marked transient. Specifically, the JavaDocs for
_UIViewRoot.getComponentResources_ should include: "Set the transient
property of the facet to true." |yes
|
_https://javaserverfaces-spec-public.dev.java.net/issues/show_bug.cgi?id=800[Spec
Public:800]_

|C068 |Change
|Modify the facelet taglib xsd so that older
versions of taglibs are acceptable. |yes
|
_https://javaserverfaces-spec-public.dev.java.net/issues/show_bug.cgi?id=744[Spec
Public:744]_

|C069 |Change
|Make sure vdldocs for _f:event_ list event
all possible event types |yes
|
_https://javaserverfaces-spec-public.dev.java.net/issues/show_bug.cgi?id=712[Spec
Public:712]_

|C072 |Errata
|Neither applyNextHandler of
DelegatingMetaTagHandler or nextHandler of TagHandler are documented.
|yes |
_https://javaserverfaces-spec-public.dev.java.net/issues/show_bug.cgi?id=780[Spec
Public:780]_

|C073 |Errata
|Specify f:ajax execute/render id behavior in
vdldocs (as outlined in Section 10.4.1.1 of the spec).
|yes |
_https://javaserverfaces-spec-public.dev.java.net/issues/show_bug.cgi?id=567[Spec
Public:567]_

|C074 |Errata
|<view-param> has no business being a child
of <redirect> and should be renamed to <redirect-param>.
|yes |
_https://javaserverfaces-spec-public.dev.java.net/issues/show_bug.cgi?id=698[Spec
Public:698]_

|C075 |Errata
|includeViewParams implicit navigation flag
should be faces-include-view-params. |yes
|
_https://javaserverfaces-spec-public.dev.java.net/issues/show_bug.cgi?id=699[Spec
Public:699]_

|C077 |Errata
|Event broadcasting should apply to Behaviors
(not just ClientBehaviors). |yes
|
_https://javaserverfaces-spec-public.dev.java.net/issues/show_bug.cgi?id=798[Spec
Public:798]_

|C078 |Errata
|PostAddToViewEvent delivery specification
needs clarification. Clarify UIComponent.getParent and getChildren for
consistency. |yes
|
_https://javaserverfaces-spec-public.dev.java.net/issues/show_bug.cgi?id=805[Spec
Public:805]_

|C079 |Errata
|RenderKit Docs - TableRenderer:Clarification
- the docs say to render the footer the same as the header which causes
the problem. |yes
|
_https://javaserverfaces-spec-public.dev.java.net/issues/show_bug.cgi?id=255[Spec
Public:255]_

|C080 |Errata
|RenderKit Docs - ButtonRenderer Encode
behavior w/r/t onclick attribute - should not be passthrough attribute.
|yes |
_https://javaserverfaces-spec-public.dev.java.net/issues/show_bug.cgi?id=257[Spec
Public:257]_

|C081 |Errata
|h:message "for" attribute is
mis-specified:"for" attribute should be relative id (not clientid).
|yes |
_https://javaserverfaces-spec-public.dev.java.net/issues/show_bug.cgi?id=266[Spec
Public:266]_

|C082 |Errata
|clarify whether expression of
binding-attribute of f:xxxxListener should be evaluated on postback.
|yes |
_https://javaserverfaces-spec-public.dev.java.net/issues/show_bug.cgi?id=320[Spec
Public:320]_

|C083 |Errata
|Option rendering, specifically when dealing
with SelectItemGroups, is too generic. |yes
|
_https://javaserverfaces-spec-public.dev.java.net/issues/show_bug.cgi?id=420[Spec
Public:420]_

|C084 |Errata
|submittedValue get/set methods
underspecified |yes
|
_https://javaserverfaces-spec-public.dev.java.net/issues/show_bug.cgi?id=434[Spec
Public:434]_

|C085 |Errata
|Current wording in renderkit docs leads to
double encoding of query parameters |yes
|
_https://javaserverfaces-spec-public.dev.java.net/issues/show_bug.cgi?id=436[Spec
Public:436]_

|C086 |Errata
|SelectManyCheckBox Clarification
|yes |
_https://javaserverfaces-spec-public.dev.java.net/issues/show_bug.cgi?id=466[Spec
Public:466]_

|C087 |Errata
|PDL document for JSTL(Facelets) has the
incorrect URI for the NameSpace. |yes
|
_https://javaserverfaces-spec-public.dev.java.net/issues/show_bug.cgi?id=509[Spec
Public:509]_

|C088 |Errata
|API docs missing for ExceptionEventContext.
|yes |
_https://javaserverfaces-spec-public.dev.java.net/issues/show_bug.cgi?id=515[Spec
Public:515]_

|C089 |Errata
|composite:attribute component documentation
for the attribute type should be for attribute method-signature.
|yes |
_https://javaserverfaces-spec-public.dev.java.net/issues/show_bug.cgi?id=524[Spec
Public:524]_

|C090 |Errata
|The UML Diagram for javax.faces.event is out
of date. |yes |
_https://javaserverfaces-spec-public.dev.java.net/issues/show_bug.cgi?id=525[Spec
Public:525]_

|C091 |Errata
|Minor typo in the Interface BehaviorHolder
API. |yes |
_https://javaserverfaces-spec-public.dev.java.net/issues/show_bug.cgi?id=534[Spec
Public:534]_

|C092 |Errata
|Two references to the itemLabelEscaped
attribute. |yes |
_https://javaserverfaces-spec-public.dev.java.net/issues/show_bug.cgi?id=56[Spec
Public:536]_

|C093 |Errata
|Missing class description for
javax.faces.event.PostValidateEvent and
javax.faces.event.PreValidateEvent. |yes
|
_https://javaserverfaces-spec-public.dev.java.net/issues/show_bug.cgi?id=537[Spec
Public:537]_

|C094 |Errata
|Section 3.7.5 typo - ClientBehavorHolder
should be ClientBehaviorHolder. |yes
|
_https://javaserverfaces-spec-public.dev.java.net/issues/show_bug.cgi?id=540[Spec
Public:540]_

|C095 |Errata
|Section 4.1.3 typo - NamingContaier should
be NamingContainer. |yes
|
_https://javaserverfaces-spec-public.dev.java.net/issues/show_bug.cgi?id=541[Spec
Public:541]_

|C096 |Errata
|API Docs: Application.publishEvent: Docs say
to throw NPE if any of the arguments is null. However, sourceBaseType
arg can be null. |yes
|
_https://javaserverfaces-spec-public.dev.java.net/issues/show_bug.cgi?id=553[Spec
Public:553]_

|C097 |Errata
|Facelets TLD Docs: Missing "for" attribute
for "message" and "messages" tags. |yes
|
_https://javaserverfaces-spec-public.dev.java.net/issues/show_bug.cgi?id=558[Spec
Public:558]_

|C099 |Errata
|ResourceHandler docs: Clarify that relative
paths are disallowed in library names. |yes
|
_https://javaserverfaces-spec-public.dev.java.net/issues/show_bug.cgi?id=577[Spec
Public:577]_

|C100 |Errata
|Renderkit Docs: h:link - Formatting - add
paragraphs |yes |
_https://javaserverfaces-spec-public.dev.java.net/issues/show_bug.cgi?id=588[Spec
Public:588]_

|C101 |Errata
|Spec Section 2.5.9: Fix Grammar: "The first
client behavior to provided by the JSF specification is the
AjaxBehavior." should be: "The first client behavior provided by the JSF
specification is the AjaxBehavior." |yes
|
_https://javaserverfaces-spec-public.dev.java.net/issues/show_bug.cgi?id=590[Spec
Public:590]_

|C102 |Errata
|Spec Section 9.4 doesn't list all the
validation tags and it lists the validateDoubleRange tag twice.
|no |
_https://javaserverfaces-spec-public.dev.java.net/issues/show_bug.cgi?id=591[Spec
Public:591]_

|C103 |Errata
|Vdldocs and Spec section 3.6.2.1 have
component:actionSource target attribute with commas as delimiters -
should be "space" as delimiter. |yes
|
_https://javaserverfaces-spec-public.dev.java.net/issues/show_bug.cgi?id=592[Spec
Public:592]_

|C104 |Errata
|Spec Section 7.4.1: getNavigationCase should
return NavigationCase and not void. |yes
|
_https://javaserverfaces-spec-public.dev.java.net/issues/show_bug.cgi?id=605[Spec
Public:605]_

|C105 |Errata
|Spec Section 10.4.1.4 says: f:validateBean
should extend validateHandler. Should be ValidatorHandler.
|yes |
_https://javaserverfaces-spec-public.dev.java.net/issues/show_bug.cgi?id=615[Spec
Public:615]_

|C106 |Errata
|Typo: Pages in the TLD docs says "JSF 2.0
Page Decraration Language". Should be "Declaration".
|yes |
_https://javaserverfaces-spec-public.dev.java.net/issues/show_bug.cgi?id=617[Spec
Public:617]_

|C107 |Errata
|Typos: Table 14-1, 14-2, page 14-3.
|yes |
_https://javaserverfaces-spec-public.dev.java.net/issues/show_bug.cgi?id=629[Spec
Public:629]_

|C108 |Errata
|UIData.invokeOnComponent docs need to be
updated to include handling of column level facets.
|yes |
_https://javaserverfaces-spec-public.dev.java.net/issues/show_bug.cgi?id=632[Spec
Public:632]_

|C109 |Errata
|Spec Section 3.5.6.1 needs to be corrected
to state that default validators are added during tag execution time.
|yes |
_https://javaserverfaces-spec-public.dev.java.net/issues/show_bug.cgi?id=635[Spec
Public:635]_

|C110 |Errata
|validateBean and validateRequired tags need
to be removed from the JSP PDL documentation
|yes |
_https://javaserverfaces-spec-public.dev.java.net/issues/show_bug.cgi?id=645[Spec
Public:645]_

|C111 |Errata
|jsf.ajax.response update element
clarification needed in JavaScript docs. |yes
|
_https://javaserverfaces-spec-public.dev.java.net/issues/show_bug.cgi?id=646[Spec
Public:646]_

|C112 |Errata
|Spec Section 10.4.1.1: Clarify what happens
when nesting and wrapping f:ajax tags collide.
|yes |
_https://javaserverfaces-spec-public.dev.java.net/issues/show_bug.cgi?id=652[Spec
Public:652]_

|C113 |Errata
|Typo: Spec Section 8.3.1: "renderkit-id"
should be "render-kit-id" and "renderkit" should be "render-kit".
|yes |
_https://javaserverfaces-spec-public.dev.java.net/issues/show_bug.cgi?id=660[Spec
Public:660]_

|C114 |Errata
|Add "rendered" attribute to VDL docs for
ui:component and ui:fragment. |yes
|
_https://javaserverfaces-spec-public.dev.java.net/issues/show_bug.cgi?id=661[Spec
Public:661]_

|C115 |Errata
|JavaDocs for UIComponent.processValidators
is incomplete. It should mention _popComponentFromEL_ .
|yes |
_https://javaserverfaces-spec-public.dev.java.net/issues/show_bug.cgi?id=664[Spec
Public:664]_

|C116 |Errata
|Dead link in VDL docs.
|yes |
_https://javaserverfaces-spec-public.dev.java.net/issues/show_bug.cgi?id=666[Spec
Public:666]_

|C117 |Errata
|Spec Section 2.5.2.4: Standard messages for
LengthValidator are confusing. |yes
|
_https://javaserverfaces-spec-public.dev.java.net/issues/show_bug.cgi?id=668[Spec
Public:668]_

|C118 |Errata
|Spec/pdldocs don't say what the default is
for "target" in h:outputScript. |yes
|
_https://javaserverfaces-spec-public.dev.java.net/issues/show_bug.cgi?id=673[Spec
Public:673]_

|C119 |Errata
|partial-view-context-factory is only
mentioned in the schema part of the spec. Houls be added to Spec Section
13.4.2. |yes |
_https://javaserverfaces-spec-public.dev.java.net/issues/show_bug.cgi?id=705[Spec
Public:705]_

|C120 |Errata
|Specification edits needed - see:
_http://docs.google.com/Doc?docid=0AW2H0u_g8JuTZGYycDZzdmhfMTRmOHo3ZmJncQ&hl=en[here]_
|no |
_https://javaserverfaces-spec-public.dev.java.net/issues/show_bug.cgi?id=714[Spec
Public:714]_

|C121 |Errata
|Typo - Spec Section 7.5.2: "ViewHanlder"
should be "ViewHandler"; "renderView" and "restoreView" methods should
call "ViewDeclarationLanguage.renderView" and
"ViewDeclarationLanguage.restoreView". |yes
|
_https://javaserverfaces-spec-public.dev.java.net/issues/show_bug.cgi?id=729[Spec
Public:729]_

|C122 |Errata
|Spec Section 2.6.1.3: Specify that a
libraryName or resourceName contains only XML NameChar, but not a colon;
a libraryName or resourceName does not match the regex "[0-9]+(_[0-9]+)*
or [A-Za-z]\{2}(_[A-Za-z]\{2}(_[A-Za-z]+)*)?"
|yes |
_https://javaserverfaces-spec-public.dev.java.net/issues/show_bug.cgi?id=740[Spec
Public:740]_

|C123 |Errata
|Typos in PDLDocs for ui:repeat
|yes |
_https://javaserverfaces-spec-public.dev.java.net/issues/show_bug.cgi?id=743[Spec
Public:743]_

|C124 |Errata
|Remove "partial-traversal" application
element from the spec as it does not exist in the schema.
|yes |
_https://javaserverfaces-spec-public.dev.java.net/issues/show_bug.cgi?id=767[Spec
Public:767]_

|C125 |Errata
|Add mssing ID attributes to schema for:
faces-config-orderingType,faces-config-ordering-orderingType,faces-config-absoluteOrderingType,faces-config-default-valueType,faces-config-from-view-idType,faces-config-client-behavior-rendererType,faces-config-behaviorType,faces-config-value-classType,faces-config-rendererType
|yes |
_https://javaserverfaces-spec-public.dev.java.net/issues/show_bug.cgi?id=768[Spec
Public:768]_

|C126 |Errata
|UIInput JavaDocs: Specify the handling of
conversion failures. |yes
|
_https://javaserverfaces-spec-public.dev.java.net/issues/show_bug.cgi?id=775[Spec
Public:775]_

|C127 |Errata
|EditableValueHodler JavaDocs: Missing
"@Since 2.0" for "resetValue" method. |yes
|
_https://javaserverfaces-spec-public.dev.java.net/issues/show_bug.cgi?id=779[Spec
Public:779]_

|C128 |Errata
|VDL documentation for f:selectItem
references the "escape" attribute. It should be "itemEscaped".
|yes |
_https://javaserverfaces-spec-public.dev.java.net/issues/show_bug.cgi?id=788[Spec
Public:788]_

|C129 |Errata
|Specify description for "f:param" "disabled"
attribute. |yes |
_https://javaserverfaces-spec-public.dev.java.net/issues/show_bug.cgi?id=794[Spec
Public:794]_

|C130 |Errata
|Simplify PostRestoreStateEvent delivery
requirements. |yes
|
_https://javaserverfaces-spec-public.dev.java.net/issues/show_bug.cgi?id=806[Spec
Public:806]_
|===













=== 

image:SF-63.png[image]

Changes between 1.2 Final and 2.0 Final

This section gives a change-by-change
accounting of the modifications to the spec since the draft listed in
the title of this section.

=== link:JSF.html#a383[See Request Processing Lifecycle Scenarios]

Modified to define and explain resource
requests and responses.

=== link:JSF.html#a401[See Standard Request Processing Lifecycle Phases]

Specify how and when the _currentPhaseId_
property of the current _FacesContext_ must be updated.

=== link:JSF.html#a404[See Restore View]

Modified to indicate that the
_PostAddToViewEvent_ event must be sent after the view was created. Also
specify that if the VDL is Facelets, the tree must be fully constructed
before exiting Restore View.

Change how the “binding” attribute is
handled. In the case of a programmatically created view, manually
traverse the tree and send each node the _AfterRestoreViewEvent_ . In
the case of a normally restored tree, the “binding” attribute is handled
by _UIViewRoot.processRestoreState()_ , which is already called from
_StateManager.restoreView()_ .

Modify the non-faces-request case to include
view parameter processing.

=== link:JSF.html#a427[See Apply Request Values]

Specified additional behavior to recognize
partial requests and to perform partial processing.

=== link:JSF.html#a436[See Apply Request Values Partial Processing]

Specified behavior for partial processing.

=== link:JSF.html#a438[See Process Validations]

Specified additional behavior to recognize
partial requests and to perform partial processing.

=== link:JSF.html#a444[See Partial Validations Partial Processing]

Specified behavior for partial processing.

=== link:JSF.html#a446[See Update Model Values]

Specified additional behavior to recognize
partial requests and to perform partial processing.

=== link:JSF.html#a452[See Update Model Values Partial Processing]

Specified behavior for partial processing.

=== link:JSF.html#a457[See Render Response]

Generalized to remove JSP specific language.

Added the requirement for (partial requests)
to prevent writing to the response at the start of this phase (to
prevent content from being written outside f:view)

=== link:JSF.html#a584[See Localized Application Messages]

Added message key for Bean Validation.

=== link:JSF.html#a685[See Resource Handling]

Add non-normative section traversing this
feature.

=== link:JSF.html#a695[See View Parameters]

Add non-normative section traversing this
feature.

=== link:JSF.html#a707[See Bookmarkability]

Add non-normative section traversing this
feature.

=== link:JSF.html#a710[See JSR 303 Bean Validation]

Add non-normative section traversing this
feature.

=== link:JSF.html#a716[See Ajax]

Add non-normative section traversing this
feature.

=== link:JSF.html#a720[See Component Behaviors]

Add non-normative section traversing this
feature.

=== New link:JSF.html#a746[See Resource Handling]

This section is the starting point for the
specification of the Resource Handler facility, which is also specified
in the JavaDocs and the Standard RenderKit Docs.

=== New link:JSF.html#a842[See Rendering Resources]

This section briefly talks about how
resources (such as images, stylesheets and scripts) use the resource
handling mechanism.

=== New link:JSF.html#a847[See Relocatable Resources]

This section outlines the mechanism that
script and stylesheet resources use to render themselves in a different
location (with respect to tag or component placement in the view).

=== New link:JSF.html#a869[See Resource Rendering Using Annotations]

This section describes the use of an
annotation to mark that a component requires a resource.

=== link:JSF.html#a946[See Component Tree Navigation]

Added descriptions for
UIComponent.getCurrentComponent and
UIComponent.getCurrentCompositeComponent.

Added descriptions for visitTree().

=== link:JSF.html#a983[See Managing Component Behavior]

Described additional method implementations
of the BehaviorHolder interface.

=== link:JSF.html#a993[See Generic Attributes]

Described additional responsibilities for Map
get() method if the component instance is a composite component.

=== link:JSF.html#a1006[See Special Attributes]

Describe UIComponent contants that are used
in attribute Map(s).

=== link:JSF.html#a1041[See Component Specialization Methods]

Mentioned the default behavior of
UIComponentBasse encodeChildren if no associated renderer. Mentioned
encodeBegin() must publish PreRenderComponentEvent.

=== link:JSF.html#a1059[See Lifecycle Management Methods]

Added pointers to _pushComponentToEL_ ()
_popComponentFromEL_ () in support of “component” implicit object.

=== link:JSF.html#a1075[See Utility Methods]

Added UIComponent utility method
getResourceBundleMap().

=== link:JSF.html#a1175[See Properties]

Mentioned
ResourceDependency/ResourceDependencies lookup for ValueHolder
setConverter method.

=== link:JSF.html#a1215[See Methods]

Mentioned
ResourceDependency/ResourceDependencies lookup for EditableValueHolder
addValidator method..

=== link:JSF.html#a1229[See SystemEventListenerHolder]

Added section describing this new behavioral
interface.

=== link:JSF.html#a1258[See Converter]

Added verbage about Resource annotations
attached to Converters.

=== link:JSF.html#a1302[See Overview]

Updated UML diagram of event package

{empty}Moved existing event content to be in
new subsection: link:JSF.html#a1306[See Application Events], and
created a new subsection link:JSF.html#a1359[See System Events]

=== link:JSF.html#a1349[See Event Broadcasting]

Clarification made: throwing an
AbortProcessingException tells an implementation that no further
broadcast of the current event occurs. Does not affect future events.

=== link:JSF.html#a1361[See Event Classes]

Added descriptions for
PostConstructApplicationEvent and PreDestroyApplicationEvent.

=== link:JSF.html#a1393[See Declarative Listener Registration]

New section for declarative events.

=== link:JSF.html#a1403[See Listener Registration By Annotation]

Added verbiage about ListenerFor and
ListenersFor annotations.

=== link:JSF.html#a1414[See Validator Classes]

Added verbage about Resource annotations
attached to Validators.

=== link:JSF.html#a1414[See Validator Classes]

Add “javax.faces.RegularExpressionValidator”
standard validator

=== link:JSF.html#a1414[See Validator Classes]

Added validaor requirements with respect to
dealing with null or empty values.

=== link:JSF.html#a1419[See Validation Registration]

Added default validator registration
requirements.

=== link:JSF.html#a1446[See Standard Validator Implementations]

Added requirements for BeanValidator and
RequiredValidator.

=== link:JSF.html#a1461[See Bean Validation Integration]

Bean Validation integration.

=== link:JSF.html#a1707[See Component Behavior Model]

Section describes adding behavior to the
component model.

=== link:JSF.html#a2230[See Properties]

=== Specify the _viewMap_ property on UIViewRoot.

=== link:JSF.html#a2257[See Methods]

Specify new methods on UIViewRoot for
handling resources for the view.

=== link:JSF.html#a2268[See Events]

Added UIViewRoot getPhaseListeners().

=== link:JSF.html#a2277[See Partial Processing]

Specify additional behavior for UIViewRoot
methods to faciliate partial processing.

=== link:JSF.html#a2298[See Methods]

Specify iterator() method for DataModel.

=== link:JSF.html#a1515[See Composite User Interface Components]

New section specifying composite components.

=== link:JSF.html#a2403[See MethodExpression Syntax and Semantics]

Modify content relating to managed-bean-scope
to include “view” scope.

=== link:JSF.html#a2601[See Managed Bean Lifecycle Annotations]

Modify _@PostConstruct_ to state that an
exception thrown during the @PostConstruct must cause a log message to
be logged.

Modify content to clarify when _@PreDestroy_
must be called in the case of view scoped managed beans.

=== link:JSF.html#a2830[See Faces Implicit Object ELResolver For JSP] and link:JSF.html#50638862_50118[See Implicit Object ELResolver for Facelets and Programmatic Access]

Specify how the new implicit object ”
_resource_ “ must be handled by the Implicit Object ELResolver.

Specify how _viewScope_ , _component_ , and
_cc_ are resolved.

=== link:JSF.html#a2711[See ManagedBean ELResolver]

Modify setValue() to allow for atomic lazy
creation. This eliminates the need to do a get() before doing a set().

=== link:JSF.html#a2830[See Implicit Object ELResolver for Facelets and Programmatic Access]

Add a new implicit object: “resource”. This
allows easily encoding resources into markup using EL expressions

Corrected behavior of getType with respect to
"requestScope", "sessionScope", or “applicationScope” - should return
null, not Object.class.

=== link:JSF.html#a2940[See Resource ELResolver]

=== This section specifies the behavior of the Resource EL Resolver

=== link:JSF.html#a2908[See Composite Component Attributes ELResolver]

New ELResolver that ensures that #\{cc.attrs}
resolves to a special Map.

=== link:JSF.html#a2970[See ScopedAttribute ELResolver]

Specify that setPropertyResolved(true) is
called in all cases.

=== link:JSF.html#a3096[See Attributes]

Add new section after 6.1.1 documenting the
new _Map_ returned from _FacesContext.getAttributes()_ .

=== link:JSF.html#a3198[See ResponseStream and ResponseWriter]

Add FacesContext enableResponseWriting
method.

=== link:JSF.html#a3225[See Partial Processing Methods]

Specify the FacesContext contants and methods
that facilitate partial request processing.

=== link:JSF.html#a3229[See Partial View Context]

Specify this class is used to facilitate
partial view processing and partial view rendering.

=== link:JSF.html#a3231[See Access To The Current FacesContext Instance]

Specify how this method must behave during
application startup time.Corrected access keyword for
FacesContext.setCurrentInstance() to be _protected_ instead of _public_
.

=== link:JSF.html#a3237[See CurrentPhaseId]

New property to access the current phase.

=== link:JSF.html#a3253[See ExceptionHandler]

New property to access the _ExceptionHandler_
for this request.

=== link:JSF.html#a3375[See ExceptionHandlerFactory]

New factory for _ExceptionHandler_ instances.

=== link:JSF.html#a3384[See ExternalContextFactory]

New factory for _ExternalContext._

=== link:JSF.html#a3455[See ProjectStage Property]

This section documents the new ProjectStage
property. This is similar in use to the RAILS_ENV environment variable
from the Ruby on Rails framework.

=== link:JSF.html#a3526[See System Event Methods]

New section describing system events.

=== link:JSF.html#a3571[See Default NavigationHandler Algorithm]

Specify how to handle implicit navigation.

Specify how to handle conditional navigation

Require that
_context.getFlash().setRedirect(true)_ is called if the navigation is a
redirect.

Specify that an informative message must be
rendered in the page if there is no outcome match and _ProjectStage_ is
not _Production_ .

Special handling for view parameters and
redirect.

=== link:JSF.html#a3874[See Overview]

In _createView()_ , if the VDL is Facelets,
make sure the view is fully populated before returning.

=== link:JSF.html#a3910[See Default ViewHandler Implementation]

Move the viewId derivation algorithm to be
inside of the new _ViewHandler.deriveViewId()_ method and specify it to
deal with the new DEFAULT_SUFFIX definition.

Modify getActionURL() to remove the use of
DEFAULT_SUFFIX and instead take a simpler implementation.

Refactored VDL specific logic into new
_ViewDeclarationLanguage_ class.

=== link:JSF.html#a4003[See ViewDeclarationLanguage]

New section which coveres how Facelets and
JSP are handled via the ViewDeclarationLanguage class.

=== link:JSF.html#a4223[See RenderKit]

New methods on _RenderKit_ :
_getComponentFamilies()_ and _getRendererTypes()_ .

=== link:JSF.html#a4245[See Renderer]

Mentioned the ListenerFor annotation.

=== link:JSF.html#a4264[See ClientBehaviorRenderer]

Renderer for component Behavior.

=== link:JSF.html#a4697[See <f:convertDateTime>]

Extends ConverterELTag, not ConverterTag.

=== link:JSF.html#a4752[See <f:convertNumber>]

Extends ConverterELTag, not ConverterTag

=== link:JSF.html#UNKNOWN[See <f:validateDoubleRange>]

Extends ValidatorELTag, not ValidatorTag

=== link:JSF.html#UNKNOWN[See <f:validateRegex>]

New standard validator

=== link:JSF.html#a5223[See <f:validateLongRange>]

Extends ValidatorELTag, not ValidatorTag

=== link:JSF.html#a5325[See <f:view>]

Extends UIComponentELTag, not
UIComponentBodyTag

=== link:JSF.html#a5476[See Facelets and its use in Web Applications]

New chapter insterted after
link:JSF.html#a4404[See] , titled, “Integration with Facelets”.
This implies increasing the remaining chapter numbers by one.

=== link:JSF.html#UNKNOWN[See <f:ajax>]

Declarative Ajax tag.

=== link:JSF.html#a5815[See Override default Ajax action. “button1” is associated with the Ajax “execute=’cancel’” action:]

Bean Validation tag.

=== link:JSF.html#a5857[See <f:validateRequired>]

Bean Validation tag.

=== link:JSF.html#a6088[See Application Configuration Parameters]

New _javax.faces.PROJECT_STAGE_
ServletContext init param.

New
_javax.faces.INTERPRET_EMPTY_STRING_SUBMITTED_VALUES_AS_NULL_
ServletContext init param.

New
_javax.faces.DISABLE_FACES_VDL_VIEWHANDLER_ ServletContext init param.

Modify _javax.faces.DEFAULT_SUFFIX_ init
param, add _javax.faces.FACELETS_DEFAULT_SUFFIX_ ,
_javax.faces.FACELETS_VIEW_MAPPINGS_ init params.

New _javax.faces.VALIDATE_EMPTY_FIELDS_
ServletContext init param.

New _javax.faces.PARTIAL_STATE_SAVING_
ServletContext init param

New _javax.faces.FULL_STATE_SAVING_VIEW_IDS_
servlet context init param.

Explicitly ignore “
_/WEB-INF/faces-config.xml_ ” in _javax.faces.CONFIG_FILES_ , if
present.

=== link:JSF.html#a6201[See Application Startup Behavior]

Change rules to support ordering of
configuration resources.

=== link:JSF.html#a6297[See Configuration Impact on JSF Runtime]

Specify requirements for handling
_resource-handler_ elements within the application configuration
resources.

Specify requirements for handling
_faces-lifecycle-listener_ elements within the application configuration
resources.

Declare _exception-handler-factory_ .

Declare _discovery-handler-factory_ .

Declare _view-declaration-language-factory_ .

=== link:JSF.html#a6336[See Delegating Implementation Support]

List decoratable artifacts.

=== link:JSF.html#a6435[See Ordering of Artifacts]

Define the rules for ordering of
configuratino resources.

=== link:JSF.html#a6596[See Annotations that correspond to and may take the place of entries in the Application Configuration Resources]

New section detailing new annotations.

=== link:JSF.html#a6626[See PhaseEvent]

Statement should read: encapsulated by
FacesContext...

=== link:JSF.html#a6699[See Ajax Integration]

New chapter describing how Ajax will
integrate with JavaServer Faces.

=== link:JSF.html#a6702[See JavaScript Resource]

This section describes the standard Ajax
JavaScript resource that will be used in JavaServer Faces.

=== link:JSF.html#a6704[See JavaScript Resource Loading]

This section describes how the Ajax resource
will leverage the resource loading feature.

=== link:JSF.html#a6706[See The Annotation Approach]

This section mentions the use of the resource
annotation to specify that a component or renderer requires the Ajax
ressource.

=== link:JSF.html#a6712[See The Resource API Approach]

Component authors can also specify that a
custom component or renderer requires the Ajax resource by using the
resource APIs.

=== link:JSF.html#a6738[See The Page D eclaration Language Approach]

Page authors can make the Ajax resource
available through the standard resource tags.

=== link:JSF.html#a6754[See JavaScript Namespacing]

This section discusses the JavaScript
namespacing requirements for the Ajax resource to avoid collisions with
other JavaScript libraries.

=== link:JSF.html#a6766[See Ajax Interaction]

This section describes the JavaScript
functions that will be available to allow clients to perform Ajax
interactions with JavaServer Faces.

=== link:JSF.html#a6769[See Sending an Ajax Request]

This section describes the process of sending
an Ajax request to the server.

=== link:JSF.html#a6771[See Ajax Request Queueing]

Higher level requirements about queueing Ajax
requests before they are sent.

=== link:JSF.html#a6773[See Request Callback Function]

Describes the functionality when a response
comes back from the server.

=== link:JSF.html#a6781[See Receiving The Ajax Response]

Describes the requirements of
javax.faces.Ajax.ajaxResponse - the function that gets called from the
Ajax request callback function.

=== link:JSF.html#a6783[See Monitoring Events On The Client]

Describes the JavaScript functions used to
register event and error callback functions that will be notified when
events and errors occur.

=== link:JSF.html#a6785[See Monitoring Events For An Ajax Request]

Details about specifying the “onevent”
attribute.

=== link:JSF.html#a6790[See Monitoring Events For All Ajax Requests]

Specifics about the jsf.ajax.addOnEvent
function.

=== link:JSF.html#a6792[See Sending Events]

Details about sending client side events.

=== link:JSF.html#a6797[See Handling Errors On the Client]

Specifics about the JavaScript functions to
use for handling errors on the client.

=== link:JSF.html#a6799[See Handling Errors For An Ajax Request]

Details about specifying “onerror” attribute.

=== link:JSF.html#a6804[See Handling Errors For All Ajax Requests]

Details about jsf.ajax.addOnError function.

=== link:JSF.html#a6806[See Signaling Errors]

Specifics about signaling client side errors.

=== link:JSF.html#a6812[See Handling Errors On The Server]

Specifics about exception handling on the
server for Ajax requests.

=== link:JSF.html#a6825[See Partial View Traversal]

This section provides a summary of how Faces
can process one or more components in a view - know as partial
processing.

=== link:JSF.html#a6829[See Partial Traversal Strategy]

This section provides a summary of how
frameworks can plug in strategies for performing partial view processing
and partial view rendering.

=== link:JSF.html#a6831[See Partial View Processing]

This section describes how one or more
components can be processed in the “execute” portion of the request
processing lifecycle.

=== link:JSF.html#a6833[See Partial View Rendering]

This section describes how one or more
components can be processed in the “render” portion of the request
processing lifecycle.

=== link:JSF.html#a6835[See Sending The Response to The Client]

Describes the server side responsibilities
for preparing and sending the response markup back to the client.

=== link:JSF.html#a6837[See Writing The Partial Response]

Describes the PartialResponseWriter
requirements.

=== link:JSF.html#a6841[See JavaScript API]

New Chapter - JavaScript API for JSF 2.0

=== link:JSF.html#a6844[See Collecting and Encoding View State]

Describes the JavaScript function that can be
used to return encoded state for a given form.

=== link:JSF.html#a6852[See Use Case]

Simple example of using the jsf.getViewState
function.

=== link:JSF.html#a6856[See Initiating an Ajax Request]

Describes the JavaScript function used to
send Ajax requests.

=== link:JSF.html#a6864[See Usage]

jsf.ajax.request function syntax and
arguments.

=== link:JSF.html#a6897[See Default Values]

Default values for the “execute” and “render”
arguments.

=== link:JSF.html#a6911[See Request Sending Specifics]

Implementation requirements for the
jsf.ajax.reqeust function.

=== link:JSF.html#a6921[See Use Case]

Simple example of the request function.

=== link:JSF.html#a7017[See Determining An Application’s Project Stage]

This section summarizes the implementation
requirements for the jsf.ajax.response function.

=== link:JSF.html#a6931[See Registering Callback Functions]

This section describes the functions that can
be used to register callback functions that will be notified when events
and errors occur.

=== link:JSF.html#a6933[See Request/Response Event Handling]

Describes the specifics of using the
JavaScript API to register event handling callback functions.

=== link:JSF.html#a6962[See Use Case]

Simple example of jsf.ajax.addOnEvent
function.

=== link:JSF.html#a6973[See Error Handling]

Describes the specifics of using the
JavaScript API to register error handling callback functions.

=== link:JSF.html#a7009[See Use Case]

Simple example of jsf.ajax.addOnError
function.

=== link:JSF.html#a7017[See Determining An Application’s Project Stage]

Describes the function used to determine an
application’s project stage.

=== link:JSF.html#a7020[See Use Case]

Simple example of jsf.getProjectStage
function.

=== link:JSF.html#a7029[See Script Chaining]

Describes the jsf.util.chain function that
can be used to chain function calls.

=== Javadoc XML Schema section

Add the _resource-handler_ element.

Add the _faces-lifecycle-listener_ element
and its children.

=== link:JSF.html#a7162[See XML Schema Definition for Composite Components]

New section - the layout for the Ajax
response.

=== Standard HTML RenderKit specification

component-family: javax.faces.Graphic
renderer-type: javax.faces.Image

Spec for what to do if “name”, “library” or
“target” attributes are present

component-family: javax.faces.Output
renderer-type: javax.faces.Body

This is a new Renderer in the
standard-html-renderkit

component-family: javax.faces.Output
renderer-type: javax.faces.Head

This is a new Renderer in the
standard-html-renderkit

component-family: javax.faces.Output
renderer-type: javax.faces.resource.Script

This is a new Renderer in the
standard-html-renderkit

component-family: javax.faces.Output
renderer-type: javax.faces.resource.Stylesheet

This is a new Renderer in the
standard-html-renderkit

=== General Changes

The numbers in the text below refer to issue
numbers in the issue tracker found at
<https://javaserverfaces-spec-public.dev.java.net/servlets/ProjectIssues>.

100 - New methods on _RenderKit_ :
_getComponentFamilies()_ and _getRendererTypes()_ .

170 - Allow commandButton to have f:param
children.

175 - Non-normatively clarify that the value
of the "src" attribute will have the context-root prepended to it if the
value starts with "/".

199 - Spec updates to clarify commandLink.

201 - Clean up convertNumber locale attribute
to match with convertDateTime locale attribute.

226 - Require that SelectOneListBox and all
similar renderers set "" if no request parameter can be found for the
component instance.

228 - add selectedClass and unselectedClass
to selectManyCheckbox

232 - Make javax.faces.model.DataModel
implement Iterable.

259 - For selectOneRadio and
selectManyCheckbox, normatively require the "style" and "border"
elements to end up on the respective attributes on the rendered "table".

310 - Add context-param for setting the
default timezone of DateTimeConverter instances

311 - Make the documentation in the spec
prose document and the javadocs for the “first” property of UIData be
consistent. In both cases, the value returned is relative to “zero”, not
“one”.

317 - Make it so you if you try to do
setValue on a managedBean that is not yet instantiated, it gets
automatically instantiated first.

331 - add getPhaseListeners() to UIViewRoot.

361 - Section 3.1.5, fix missed ValueBinding
to ValueExpression change. __

=== 

image:SF-63.png[image]

_Changes Between 1.1 and 1.2_

=== Unified Expression Language (EL)

Previous versions of the JavaServer Faces
included an innovative, EL tailored to the needs of Faces. The main
emphasis of this version of the Faces spec, and also the focus of the
JSP spec corresponding to it, is to take those innovations and expose
them to JSP page authors by creating a Unified EL that leverages the
combined power of the Faces and JSP ELs. The Faces EL would then be
deprecated, and the deprecated implementation would be written in terms
of the Unified EL to preserve backwards compatability.

=== [[a8777]]Guide to Deprecated Methods Relating to the Unified EL and their Corresponding Replacements

The following classes and methods have been
deprecated:

 _javax.faces.el_ . _EvaluationException_

replaced by: _javax.el.ELException_

 _javax.faces.el_ . _MethodBinding_

replaced by: _javax.el.MethodExpression_

 _javax.faces.el_ . _MethodNotFoundException_

replaced by:
_javax.el.MethodNotFoundException_

 _javax.faces.el_ .
_PropertyNotFoundException_

replaced by:
_javax.el.PropertyNotFoundException_

 _javax.faces.el_ . _PropertyResolver_

replaced by: _javax.el.ELResolver_

 _javax.faces.el_ .
_ReferenceSyntaxException_

replaced by: _javax.el.ELException_

 _javax.faces.el_ . _ValueBinding_

replaced by: _javax.el.ValueExpression_

 _javax.faces.el_ . _VariableResolver_

replaced by: _javax.el.ELResolver_


_javax.faces.application.Application.createComponent(ValueBinding
componentBinding, FacesContext context, String componentType)_

replaced by:
_javax.faces.application.Application.createComponent(ValueExpression
componentExpression, FacesContext context, String componentType)_


_javax.faces.application.Application.createMethodBinding_

replaced by:
_javax.faces.application.Application.createMethodExpression_


_javax.faces.application.Application.createValueBinding_

replaced by calling:
_javax.faces.application.Application.getExpressionFactory_ then
_ExpressionFactory.createValueExpression_

see Javadoc for
_javax.faces.application.Application.createValueBinding_


_javax.faces.application.Application.getPropertyResolver_

replaced by:
_javax.faces.application.Application.getELResolver_


_javax.faces.application.Application.setPropertyResolver_

see Javadoc for
_javax.faces.application.Application.setPropertyResolver_


_javax.faces.application.Application.getVariableResolver_

replaced by:
_javax.faces.application.Application.getELResolver_


_javax.faces.application.Application.setVariableResolver_

see Javadoc for
_javax.faces.application.Application.setVariableResolver_


_javax.faces.component.ActionSource.getAction_

replaced by:
_javax.faces.component.ActionSource2.getActionExpression_


_javax.faces.component.ActionSource.setAction_

replaced by:
_javax.faces.component.ActionSource2.setActionExpression_


_javax.faces.component.ActionSource.getActionListener_

replaced by:
_javax.faces.component.ActionSource.getActionListeners_

see Javadoc for
_javax.faces.component.ActionSource.getActionListener_


_javax.faces.component.ActionSource.setActionListener_

replaced by:
_javax.faces.component.ActionSource.addActionListener_


_javax.faces.component.EditableValueHolder.getValidator_

replaced by:
_javax.faces.component.EditableValueHolder.getValidators_

see Javadoc for:
_javax.faces.component.EditableValueHolder.getValidator_


_javax.faces.component.EditableValueHolder.setValidator_

replaced by:
_javax.faces.component.EditableValueHolder.addValidator_

see Javadoc for:
_javax.faces.component.EditableValueHolder.setValidator_


_javax.faces.component.EditableValueHolder.getValueChangeListener_

replaced by:
_javax.faces.component.EditableValueHolder.getValueChangeListeners_

see Javadoc for:
_javax.faces.component.EditableValueHolder.getValueChangeListener_


_javax.faces.component.EditableValueHolder.setValueChangeListener_

replaced by:
_javax.faces.component.EditableValueHolder.addValueChangeListener_

see Javadoc for:
_javax.faces.component.EditableValueHolder.setValueChangeListener_

 _javax.faces.component.UICommand.getAction_

replaced by:
_javax.faces.component.UICommand.getActionExpression_

 _javax.faces.component.UICommand.setAction_

replaced by:
_javax.faces.component.UICommand.setActionExpression_


_javax.faces.component.UICommand.getActionListener_

replaced by:
_javax.faces.component.UICommand.getActionListeners_

see Javadoc for:
_javax.faces.component.UICommand.getActionListener_


_javax.faces.component.UICommand.setActionListener_

replaced by:
_javax.faces.component.UICommand.addActionListener_

see Javadoc for:
_javax.faces.component.UICommand.setActionListener_


_javax.faces.component.UIComponentBase.getValueBinding_

replaced by:
_javax.faces.component.UIComponentBase.getValueExpression_


_javax.faces.component.UIComponentBase.setValueBinding_

replaced by:
_javax.faces.component.UIComponentBase.setValueExpression_


_javax.faces.component.UIComponent.getValueBinding_

replaced by:
_javax.faces.component.UIComponent.getValueExpression_


_javax.faces.component.UIComponent.setValueBinding_

replaced by:
_javax.faces.component.UIComponent.setValueExpression_


_javax.faces.component.UIData.setValueBinding_

replaced by:
_javax.faces.component.UIData.setValueExpression_


_javax.faces.component.UIGraphic.getValueBinding_

replaced by:
_javax.faces.component.UIGraphic.getValueExpression_


_javax.faces.component.UIGraphic.setValueBinding_

replaced by:
_javax.faces.component.UIGraphic.setValueExpression_

 _javax.faces.component.UIInput.getValidator_

replaced by:
_javax.faces.component.UIInput.getValidators_

see Javadoc for:
_javax.faces.component.UIInput.getValidator_

 _javax.faces.component.UIInput.setValidator_

replaced by:
_javax.faces.component.UIInput.addValidator_

see Javadoc for:
_javax.faces.component.UIInput.setValidator_


_javax.faces.component.UIInput.setValueChangeListener_

replaced by:
_javax.faces.component.UIInput.addValueChangeListener_

see Javadoc for:
_javax.faces.component.UIInput.setValueChangeListener_


_javax.faces.component.UISelectBoolean.getValueBinding_

replaced by:
_javax.faces.component.UISelectBoolean.getValueExpression_


_javax.faces.component.UISelectBoolean.setValueBinding_

replaced by:
_javax.faces.component.UISelectBoolean.setValueExpression_


_javax.faces.component.UISelectMany.getValueBinding_

replaced by:
_javax.faces.component.UISelectMany.getValueExpression_


_javax.faces.component.UISelectMany.setValueBinding_

replaced by:
_javax.faces.component.UISelectMany.setValueExpression_

New Methods not replacing a Deprecated
methods:


_javax.faces.component.UIViewRoot.getBeforePhaseListener_


_javax.faces.component.UIViewRoot.setBeforePhaseListener_


_javax.faces.component.UIViewRoot.getAfterPhaseListener_


_javax.faces.component.UIViewRoot.setAfterPhaseListener_

Guide to Deprecated Methods Relating to State
Management and their Corresponding Replacements

The following classes and methods have been
deprecated:


_javax.faces.application.StateManager.SerializedView_

 replaced by _java.lang.Object_ that
implements _java.io.Serializable_


_javax.faces.application.StateManager.saveSerializedView_

 replaced by
_javax.faces.application.StateManager.saveView_


_javax.faces.application.StateManager.getTreeStructureToSave_

The separation between tree structure and
component state is now a recommended implementation detail.


_javax.faces.application.StateManager.getComponentStateToSave_

The separation between tree structure and
component state is now a recommended implementation detail.


_javax.faces.application.StateManager.writeState_ that takes a
_SerializedView_

 replaced by
_javax.faces.application.StateManager.writeState_ that takes a
_java.lang.Object_ that implements _Serializable_ .


_javax.faces.application.StateManager.restoreTreeStructure_

The separation between tree structure and
component state is now a recommended implementation detail.


_javax.faces.application.StateManager.restoreComponentState_

The separation between tree structure and
component state is now a recommended implementation detail.


_javax.faces.render.ResponseStateManager.writeState_ that takes a
_javax.faces.application.StateManager.SerializedView_

Replaced by
_javax.faces.render.ResponseStateManager.writeState_ that takes a
_java.lang.Object_ that implements _java.io.Serializable._


_javax.faces.render.ResponseStateManager.getTreeStructureToRestore_

The separation between tree structure and
component state is now a recommended implementation detail. Semantically
has been replaced by _javax.faces.render.ResponseStateManager.getState_
.


_javax.faces.render.ResponseStateManager.getComponentStateToRestore_

The separation between tree structure and
component state is now a recommended implementation detail. Semantically
has been replaced by _javax.faces.render.ResponseStateManager.getState_
.

JavaServer Faces 1.2 Backwards Compatibility

Faces 1.2 is backwards compatible with Faces
1.1. This means that a web-application that was developed to run with
Faces 1.1 won’t require any modification when run with Faces 1.2 except
in the cases described in the following section.

Note that Faces is a part of the Java EE
platform as of Faces 1.2. A web application therefore does not need to
bundle a Faces implementation anymore when it runs on a web container
that is Java EE technology compliant. Should a Faces implementation be
bundled with a web-application, it will simply be ignored as the Faces
implementation provided by the platform always takes precedence.

The JSP aspects of backwards compatability
are described in the JSP specification in the Preface, in the section
titled “Backwards Compatability with JSP 2.0”.

Breakages in Backwards Compatability

{empty}In Faces 1.1 you could override
implicit objects in your custom resolvers. For example, for the
following expression: _$\{param[‘x’]}_ you could change the meaning of
_param_ in your custom _VariableResolver._ In Faces 1. _2,_ implicit
objects are always recognized - so _param_ will always mean a map of
parameters. See link:JSF.html#a2406[See The Managed Bean
Facility]

In Faces 1.1, any custom resolvers that do
not honor the “decorator” pattern - that is, delegate to their parent
resolver, will still work in Faces 1.2 with the following clarification:
those resolvers would operate independently with regards to other
resolvers in the chain. See link:JSF.html#a2667[See Faces
ELResolver for JSP Pages].

In Faces 1.1 it was valid to call
_setVariableResolver()_ or _setPropertyResolver()_ on the _Application_
at any point in the application’s lifetime. This allowed for the
application to be in an indeterminate state. In Faces 1.2, neither of
these methods may be called after the application has served any
requests.

In Faces 1.1, if a view couldn’t be restored
due to session expiration, we’d create a new one and go to render
response. In 1.2, this is not the case. We now throw a
_ViewExpiredException_ . 1.1-based applications may rely on the old
behavior to forward to a login page when a session expired. 1.2
circumvents this.

=== General changes

The numbers in the text below refer to issue
numbers in the issue tracker found at
<https://javaserverfaces-spec-public.dev.java.net/servlets/ProjectIssues>.

2 - Clarify that for client side state
saving, the state should be encrypted for security.

3 - Clarify the specification with respect to
constraint violations for tags in the Core Tag Library.

4 - Added _headerClass_ and _footerClass_
attributes at the “h:column” level. Please see
link:JSF.html#a4314[See Standard HTML RenderKit Implementation]
for more details.

5 - Clarified the use of a string literal for
the “action” attribute on ActionSource components.

6 - Introduced a new optional “label”
attribute for input components that will provide an association between
a component, and the message that the component (indirectly) produced.
Please refer to link:JSF.html#a4314[See Standard HTML RenderKit
Implementation] and link:JSF.html#a584[See Localized
Application Messages] for more details.

8 - Made UViewRoot a source of PhaseEvent(s)
for all phases of the request processing lifecycle except RestoreView.
Provided additional “before” and “after” phase listener attributes for
the <f:view> tag. Please see link:JSF.html#a2226[See UIViewRoot]
for more details.

9 - Clarified the behavior of PhaseListener
implementations in the following way: they must guarantee that if
“beforePhase()” is called, then “afterPhase()” must also be called,
regardless of any thrown exceptions. Please see
link:JSF.html#a6635[See PhaseListener] for more specifics.

11 - Provide a unique window identifier (in
addition to the “viewid”) to accomodate applications that have mutiple
instances of the same view, but perhaps in different browser windows or
frames.

13 - Specified “by type” converter
registration for BigDecimal and BigInteger.

15 - Enhanced the usage of the “Decorator
Pattern” for ViewHandler, StateManager and ResponseWriter classes by
providing abstract wrapper classes to make it easier to override a
subset of the total methods for those classes. Please see
link:JSF.html#a6336[See Delegating Implementation Support] for
more details.

16 - Provided additional I18n attributes “dir
and “lang” for the tags: <h:outputText>, <h:outputFormat>, <h:messages>,
<h:message>. Please see link:JSF.html#a4314[See Standard HTML
RenderKit Implementation] for descriptions of these components.

17 - Introduced a new optional “layout”
attribute on the “PanelGroup” component that controls the rendering of
either a “div” or “span” HTML element. Please see
link:JSF.html#a4314[See Standard HTML RenderKit Implementation]
for more details.

18 - When a resource lookup is done on the
java.util.Map (loaded from <f:loadBundle>) using a key, and the key is
not found in the Map, return the literal string ???KEY??? where KEY is
the key being looked up in the Map (instead of throwing a
MissingResourceException). Throw a JspException if the named bundle
identified by <f:loadBundle> does not exist. Please see
_link:JSF.html#a4860[See <f:loadBundle>]_ .

20 - Specify that the event queue should be
cleared after each phase (except RestoreViewPhase and RenderResponse) if
“responseComplete” or “renderResponse” has been set on the FacesContext.

21 - Provided an additional “binding”
attribute for the core Converter, Listener and Validator tags that would
be used as a ValueExpression to alternatively create the Converter,
Listener or Validator instance. Please see
link:JSF.html#a4636[See JSF Core Tag Library] for more details.

27 - <h:messages> now renders HTML list
elements (“<ul>”,”<li>”) if the “layout” attribute is “list” or the
“layout” attribute is not specified. If the “layout” is “table”, an HTML
“table” element is rendered instead of an outer “span”. Please see
link:JSF.html#a4314[See Standard HTML RenderKit Implementation]
for more details.

29 - Allow the use of user-defined “onclick”
Javascript on CommandLink.

30 - Make the “commandButton” “image”
attribute render the same as the “graphicImage” “img” attribute for
consistency. Please see link:JSF.html#a4314[See Standard HTML
RenderKit Implementation] for more information.

35 - Provided a new facet for DataTable
Renderer that allows the rendering of a table “caption” element
immediately following the “table” element. Also provided style sheet
attributes for this new element. Please see
link:JSF.html#a4314[See Standard HTML RenderKit Implementation]
for a descrption of this component.

43 - Migrated over to using XML Schema (from
DTD) for configuation file validation. Please see the schema section of
the Javadocs.

45 - Avoided concurrent read issues by using
a java.util.HashMap instead of java.util.WeakHashMap for a component’s
Property Descriptor Map. This also fixes the performance problem as
identified in the forum. Please refer to the Property Descriptor methods
and the constructor in _javax.faces.component.UIComponentBase._

47 - Introduced a mechanism to detect if a
request is a postback.

48 - Specify the algorithm used for client id
generation as well as provide a way to allow the page author to specify
exactly what the client Id should be, and preventing Faces from altering
it.

50 - Allow an application to specify multiple
render kits by introducing an optional “renderKitId” attribute on
“<f:view>”. It is no longer required to write a custom ViewHandler to
incorporate a different render kit. Please refer to
link:JSF.html#a4288[See ResponseStateManager] and
link:JSF.html#a5325[See <f:view>] for more details.

51 - Clarify the specification with respect
to “Application Startup Behavior”. Allow implementations to check for
the presence of a servlet-class definition in a web application
deployment descriptor as a means to abort the configuration and save
startup time.

54 - Added new extension elements to the
Faces XML schema. Please see the XML schema section of the Javadocs.

55 - For postback requests, in the
“RestoreViewPhase”, during _ValueExpression_ examination for each
component in the component tree, specify that calling the _setValue()_
method on each _ValueExpression_ , should be done in a “parent-first”
fashion, calling the _setValue()_ method and then traversing the
children.

58 - Enabed “protected” access to internal
“DataModel” in UIData.

59 - Avoid EL expression evaluation for
“value” attribute on “AttributeTag”. “AttributeTag” now passes the
expression to UIComponent for evaluation.

65 - Added standard converter messages.
Please see link:JSF.html#a584[See Localized Application
Messages] for more details.

66 - Specified that “FormRenderer” must
render the “name” attribute with the same value as the “id” attribute.
Please see link:JSF.html#a4314[See Standard HTML RenderKit
Implementation] for more details.

67 - Allow the resetting of an input
component’s value by introducing a _resetValue()_ method on _UIInput._

68 - Specify that the component tree may be
manipulated throughout the request processing lifecycle, except during
render. Please see link:JSF.html#a457[See Render Response] for
more details.

69 - Permit the passing of _a null_ value to
_SelectItem.setValue()._

72 - Improve XHTML compliance by rendering
both “lang” and “xml:lang” attributes.

73 - Added a new FacesException -
“javax.faces.application.ViewExpiredException”. Specified that
implementations must throw this exception when an attempt to restore a
view results in failure on postback. Please see
link:JSF.html#a404[See Restore View] for more details.

74 - Added “disabled” property to
“outputLink” and “commandLink”. Please see
link:JSF.html#a4314[See Standard HTML RenderKit Implementation]
for more details.

75 - Added “getRequestContentType” and
“getResponseContentType” to ExternalContext.

78 - Added a more “user-friendly” default
error message for UIInput “update model”. Please see
link:JSF.html#a584[See Localized Application Messages] for more
details.

80 - Specify that the JSF Core Tag Library
must not contain any tags that cause JavaScript to be rendered to the
client.

81 - Enable the message displayed for
“required” validation, conversion, and validation to be overridden by
the page author (JSP or non-JSP)

82 - Added new feature, the ability to
resolve ResourceBundles via the EL without the use of the <f:loadBundle>
tag.

84 - Added _rendered_ attribute to the core
_f:verbatim_ tag. Please see link:JSF.html#a4636[See JSF Core
Tag Library] for more details.

85 - Add new tag:
f:setPropertyActionListener. Useful for pushing values into managed
beans without allowing modification of the value.

86 - Specified that “OutputLinkRenderer” must
render the “name” attribute with the same value as the “id” attribute.
Please see link:JSF.html#a4314[See Standard HTML RenderKit
Implementation] for more details.

87 - Modified specification for the
_setVariableResolver()_ and _setPropertyResolver()_ methods on
_Application_ to state that they may not be called after the application
has served any requests.

93 - Added “escape” flag indicating the text
of UISelectItem should be escaped when rendering.

95 - Allow multiple instances of
_FacesServlet_ in a single webapp, mapped with different URI mappings,
to use different implementations of _Lifecycle_ by allowing the
lifecycle-id to be specified as an _init-param_ in addition to the
existing way of specifying it as a _context-param_ .

98 - Specified that
“SelectManyCheckboxListRenderer: and “RadioRenderer” must render the
“label” element after the “input element for each “SelectItem. Specified
that the “label” element must refer to the “input” element using the
“for” attribute. Please see link:JSF.html#a4314[See Standard
HTML RenderKit Implementation] for more details.

99 - Specified Java EE 5 Generics usage where
applicable.

105 - Specified that for commandButton
rendering, the “image” attribute value must not be escaped. Specified
that for graphicImage rendering, the “src” attribute value must not be
escaped.

108 - Specified that JSF implementations that
are part of a Java EE technology-compliant implementation are required
to validate the application resource file against the XML schema for
structural correctness. Also specified that validation is recommended,
but not required for JSF implementatons that are not part of a Java EE
technology compliant implementation. Please refer to
link:JSF.html#a6201[See Application Startup Behavior] for more
details.

111 - Specified that a component must allow
child components to be added to and removed from the child list of the
current component, even though the child component returns null from
getParent().

118 - Specified that an implementation of Map
returned from ExternalContext.getSessionMap implement a “clear” method
that calls “removeAttribute” on each attribute in the Servlet or Portlet
session.

119 - Specified that implementations running
in a JSR-250 compliant container have their managed bean methods
annotated with @PostConstruct be called after the object is
instantiated, and after injection is performed, but before the bean is
placed into scope. Specified that methods annotated with @PreDestroy be
called when the scope for the bean is ending.

120 - Specified in the renderkit docs that
commandButton rendering can generate javascript for “onclick” attribute.

122 - Clarified renderkit docs with respect
to what gets rendered for disabled command link attributes.

123 - Clarified renderkit docs with respect
to dataTable attribute rendering.

124 - Clarified renderkit docs with repsect
to graphicImage “alt” attribute.

131 - Specified that a compliant
implementation must allow the registration of a converter for class
java.lang.String and java.lang.String.TYPE that will be used to convert
values for these types.

133 - Removed the incorrect statement: “"It
is the callers responsibility to ensure that setViewId() is called on
the returned view, passing the same viewId value." pertaining to
ViewHandler.createView()

134 - Fixed backwards compatability issues.

135 - Support Java EE 5 enums as valid types/

138 - Change the required return type for
action methods to be Object instead of String. This allows the usage of
Enums for the return type of action methods, as long as the toString()
method of the enum matches the expected value in the application
configuration resources.

145 - Define new method on UIComponent,
invokeOnComponent(). This will find a component in the tree by clientId
and invoke a user specified callback on it. Please see
link:JSF.html#a946[See Component Tree Navigation] and
link:JSF.html#a1852[See Methods] [of UIData] for more details.

jsf-ri 127 - Specify that FacesContext
methods getClientIdsWithMessages( ) and getMessages( ) must be
implemented using order-preserving structures so the items in the
iterator are returned in the order they were added with
addMessage().Spec document changes

147 - Clarified grammer with respect to
component id.

151 - Specified standard converter for Enums

152 - Specified EL coercion usage in API
javadocs UISelectOne/UISelectMany (when items are compared in
validation) and standard html renderkit docs during encoding of select
components.

154 - Fixed FacesTag “name” attribute
discrepency - made it a String (was ValueExpression).

155 - Specified “columnClasses”, “rowClasses”
descriptions for panelGrid in renderkit docs.

160 - Added and specified
ResponseWriter.writeText method that takes a UIComponent argument.

The VDLDocs for the h: tag library are now a
normative part of the spec.

Following is a section by section breakdown
of the main changes since the last release of this document. This work
was done mainly to support changes in tree creation and content
interweaving for JSP based faces applications, as well as for fixing the
following issues from the above list: 2 3 4 5 6 8 9 11 13 15 16 17 18 20
21 27 29 30 35 43 45 47 48 50 51 53 54 55 58 59 65 66 67 68 69 72 73 74
75 78 80 81 82 84 85 86 93 95 98 99 105 108 111 118 119 120 122 123 124
131 133 134 135 138 145 147 151 152 154 155 160.

Preface

Added new section: Guide to Deprecated
Methods Relating to State Management and their Corresponding
Replacements.

{empty}link:JSF.html#a404[See
Restore View]

Do per-component actions in a "parent-first"
fashion, calling the setValue() method and *then* traversing the
children.

Describe the new responsibilities of this
phase with respect to the new StateSaving changes.

Describe when ViewHandler.initView() is to be
called.

Describe how the
ViewHandler.calculateRenderKitId() and ResponseStateManager.isPostback()
method are to be used.

Specify that implementations must throw
_javax.faces.application.ViewExpiredException_ when an attempt to
restore a view results in failure on postback.

=== link:JSF.html#a457[See Render Response]

Specify that the component tree may be
manipulated throughout the request processing lifecycle, except during
render.

{empty}link:JSF.html#a518[See Create
A New View]

Document that multiple renderkits are
supported.

{empty}link:JSF.html#a584[See
Localized Application Messages]

Added updates to standard messages; Also
mentioned new parameter substitution token for the generic input
component attribute "label".

{empty}link:JSF.html#a993[See
Generic Attributes]

Completely specify how attribute/property
transparency works.

{empty}link:JSF.html#a1041[See
Component Specialization Methods]

Add new method, encodeAll(), which is now the
preferred method for developers to call to render a child or facet().

{empty}link:JSF.html#a1932[See
UIForm]

Document the new _prependId_ property and
_getContainerClientId()_ method.

{empty}UIData link:JSF.html#a1878[See
Properties]

Added _protected_ property for _DataModel_ .

{empty}UIInput
link:JSF.html#a1981[See UIInput]

Document the behavior of the
_requiredMessage_ , _converterMessage_ and _validatorMessage_
properties.

{empty}UIInput
link:JSF.html#a2005[See Methods]

Add mention of resetValue() to the "Methods"
section for UIInput.

{empty}link:JSF.html#a2226[See
UIViewRoot]

Change callsite for saveSerializedView and
writeState().

Change to clear the event queue after each
phase if skipping to rendering response.

JSP tag no longer deals with state saving.

Section 5.1.2 and 5.1.3 “ValueExpression
Syntax” and “ValueExpression Semantics”

Removed and made reference to EL spec.

{empty}link:JSF.html#a2403[See
MethodExpression Syntax and Semantics]

Make reference to EL spec.

{empty}link:JSF.html#a2536[See
Managed Bean Annotations]

This new section covers the modifications
necessary to allow managed beans to be the target of container managed
dependency injection using the _@Resource_ and _@EJB_ annotations.

Added section 5.4.1 that specifies how the
_@PostConstruct_ and _@PreDestroy_ annotations must be handled.

{empty}link:JSF.html#a2651[See
ExpressionFactory]

Update signature of createValueExpresion()
and createMethodExpression() to include ELContext as the first argument.

{empty}link:JSF.html#a2741[See
ResourceBundle ELResolver for JSP Pages]

This resolver, when coupled with the
_javax.el.ResourceBundleELResolver_ , allows the resolution of
ResourceBundles and entries therein via the EL. See also
link:JSF.html#a2962[See el.ResourceBundleELResolver] and
link:JSF.html#a2964[See ResourceBundle ELResolver for
Programmatic Access].

link:JSF.html#a3874[See Overview]
ViewHandler

Document new methods initView() and
calculateCharacterEncoding();

{empty}link:JSF.html#a3910[See
Default ViewHandler Implementation]

modify createView() to reflect current
reality:

Do the viewId discovery algorithm formerly in
restoreView().

Redirect to the context root if no viewId can
be discerned.

Do the existing processing.

modify restoreView() to reflect current
reality:

Do the existing processing.

Do the viewId discovery algorithm now in
createView().

If no viewId can be discovered, return null.

Always call StateManager.restoreView().

no longer set the character encoding, this
has moved out to the Restore View phase implementation

change callsite for saveSerializedView() to
be saveView().

added ViewHandler.calculateRenderKitId
responsibility of returning the request parameter named
ResponseStateManager.RENDER_KIT_ID_PARAM if not null.

{empty}State Saving
link:JSF.html#a4119[See Overview]

Soften the wording about the separation
between tree structure and component state, say it's only a
recommendation to keep these two separate.

{empty}link:JSF.html#a4135[See State
Saving Alternatives and Implications]

Modified client state saving text to add "It
is advisable that this information be encrypted and tamper evident,
since it is being sent down to the client, where it may persist for some
time."

Modified server state saving text to add
"Implementations that wish to enable their saved state to fail over to a
different container instance must keep this in mind when implementing
their server side state saving strategy. The default implementation
Serializes the view in both the client and server modes. In the server
mode, this serialized view is stored in the session and a unique key to
retrieve the view is sent down to the client. By storing the serialized
view in the session, failover may happen using the usual mechanisms
provided by the container."

The values of all component attributes and
properties must implement _Serializable_ .

New section 7.7.6 StateManager in the
"Deprecated APIs" section (7.7)

New section 7.7.7 ResponseStateManager in the
"Deprecated APIs" section (7.7)

{empty}link:JSF.html#a4288[See
ResponseStateManager]

Describe the non-deprecated methods.

Added verbiage about ResponseStateManager
implementation's responsibility of writing out render kit identifier.

Describe the isPostback() method.

{empty}link:JSF.html#a4415[See
UIComponent Custom Actions]

Specify that _id_ is now _rtexprvalue_ _true_
.

{empty}link:JSF.html#a4536[See
Interoperability with JSP Template Text and Other Tag Libraries]

Changes in the current version of the EL
allow Faces applications to use JSTL _<c:forEach>_ tags with Faces
components as long as the _items_ attribute points to a deferred EL
expression (ie, a _#\{}_ expression, as opposed to an immediate _$\{}_
expression).

Also, remove the requirements that
_<f:verbatim>_ be used, and that components added to the tree
programmatically will only be rendered if they are the children of a
_rendersChildren==true_ component

{empty}link:JSF.html#a4406[See
Integration with JSP]

Changes to account for moving from
_UIComponentTag_ / _UIComponentBodyTag_ to _UIComponentELTag._

{empty}link:JSF.html#a4629[See Faces
1.0 and 1.1 Taglib migration story]

Describe the new _jsp-version_ TLD based
migration story.

{empty}link:JSF.html#a4636[See JSF
Core Tag Library]

For listener/converter/validator tags,
clarified that exceptions would be rethrown as JspException. Also specfy
JspException should be thrown if certain constraints are not met.

Specify that tags may have non-deferred
expressions as the value of their _id_ attribute.

Added _binding_ attribute to
listener/converter/validator tags.

Added _rendered_ attribute to verbatim tag.

Specify that none of the tags in the JSF Core
Tag Library may cause JavaScript to be rendered to the client.

{empty}link:JSF.html#a4679[See
<f:attribute>]

Specify that the argument value must be
interrogated to see if it isLiteralText(). If so, store in the
attributes set, If not, store in the ValueExpression set.

{empty}link:JSF.html#a5015[See
<f:setPropertyActionListener>]

New Section, document this new tag.

{empty}link:JSF.html#a5325[See
<f:view>]

Added renderKitId attribute description to
f:view;

{empty}link:JSF.html#a5363[See
Standard HTML RenderKit Tag Library]

Specify how to handle action attributes that
are string literals.

Call out to VDLDocs for parts of the
requirements. VDLDocs are now normative.

{empty}link:JSF.html#a6160[See
FacesServlet]

Describe how the _init-param_ then the
_context-param_ must be consulted for the lifecycleID for this
_FacesServlet_ instance.

{empty}link:JSF.html#a6182[See
Deprecated APIs in the webapp package]

New section describing deprecated APIs.
Previous section at this address moved to next section number.

{empty}link:JSF.html#a6201[See
Application Startup Behavior]

Implementations may check for the presence of
a servlet-class definition of class javax.faces.webapp.FacesServlet in
the web application deployment descriptor as a means to abort the
configuration process and reduce startup time for applications that do
not use JavaServer Faces Technology.



'''''

[.footnoteNumber]# 1.# [[a9083]]Typically, component
selection will be driven by the occurrence of special markup (such as
the existence of a JSP custom tag) in the template text associated with
the component tree.

[.footnoteNumber]# 2.# [[a9084]]For example, this
technique is used when custom tags in JSP pages are utilized as the
rendering technology, as described in link:JSF.html#a4406[See
Integration with JSP].

[.footnoteNumber]# 3.# [[a9085]]The default
_ViewHandler_ implementation performs a _RequestDispatcher.forward_ call
to the web application resource that will actually perform the
rendering, so it expects the tree identifier to be the context-relative
path (starting with a _/_ character) of the web application resource

[.footnoteNumber]# 4.# [[a9086]]In a JSP environment,
these steps are performed by a custom tag extending ConverterTag.

[.footnoteNumber]# 5.# [[a9087]]Accessing attributes
via this Map will cause the creation of a session associated with this
request, if none currently exists.

[.footnoteNumber]# 6.# [[a9088]]Converters can also be
requested based on the object class of the value to be converted.

[.footnoteNumber]# 7.# [[a9089]]It is an error to
specify more than one <navigation-case>, nested within one or more
<navigation-rule> elements with the same <from-view-id> matching
pattern, that have exactly the same combination of <from-xxx>, unless
each is discriminated by a unique <if> element.

[.footnoteNumber]# 8.# [[a9090]]The presence of the
<if> element in the absense of the <from-outcome> element is
characterized as an alternate, contextual means of obtai

ning a logical outcome and thus the
navigation case is checked even when the application action returns a a
null (or void) outcome value.

[.footnoteNumber]# 9.# [[a9092]]Note that multiple
conditions can be checked using the built-in operators and grouping
provided by the Expression Language (e.g., and, or, not).

[.footnoteNumber]# 10.# [[a9093]]Or, equivalently,
with no _<from-view-id>_ element at all.

[.footnoteNumber]# 11.# [[a9094]]The implementation
classes for attached object must include a public zero-arguments
constructor.

[.footnoteNumber]# 12.# [[a9095]]The actual _Method_
selected for execution must be selected as if by calling
Class.getMethod() and passing the method name and the parameters
signature specified in the createMethodBinding() call.

[.footnoteNumber]# 13.# [[a9096]]If this extension is
used, it must be declared in the web application deployment descriptor,
as described in the JSP 2.0 (or later) specification.

[.footnoteNumber]# 14.# [[a9097]]This example
illustrates a non-normative convention for naming custom actions based
on a combination of the component name and the renderer type. This
convention is useful, but not required; custom actions may be given any
desired custom action name; however the convention is rigorously
followed in the Standard HTML RenderKit Tag Library.

[.footnoteNumber]# 15.# [[a9098]]Consistent with the
way that namespace prefixes work in XML, the actual prefix used is
totally up to the page author, and has no semantic meaning. However, the
values shown above are the suggested defaults, which are used
consistently in tag library examples throughout this specification.

[.footnoteNumber]# 16.# [[a9099]]If you need multiple
components in a facet, nest them inside a <h:panelGroup> custom action
that is the value of the facet.

[.footnoteNumber]# 17.# [[a9100]]In a JSP 2.0 or later
environment, the same effect can be accomplished by using
<include-prelude> and <include-coda> elements in the <jsp-config>
element in the web application deployment descriptor.

[.footnoteNumber]# 18.# [[a9101]]This component has no
associated Renderer, so the getRendererType() method must return null
instead of a renderer type.

[.footnoteNumber]# 19.# [[a9102]]Identified by XPath
selection expressions.
